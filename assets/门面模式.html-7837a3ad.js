import{_ as e}from"./plugin-vue_export-helper-c27b6911.js";import{r as a,o as l,c as i,b as n,e as r,w as o,a as c,d as s}from"./app-f77a32f1.js";const p={},d={class:"hint-container details"},_=n("summary",null,"本文内容",-1),u={class:"table-of-contents"},g=c('<div class="hint-container info"><p class="hint-container-title">前言</p><p>我们平时在开发接口的时候，一个常见的问题就是 <strong>接口粒度</strong> 的问题。</p><p>为了保证接口的 <strong>可复用性</strong>（或叫通用性），我们需要把接口设计得 <strong>细粒度一点，职责单一一点</strong>。但这样又会导致调用者在使用时需要调用 n 多个细粒度的接口，才能完成某个功能，这称为接口的易用性不好。</p><p>而如果 <strong>接口的粒度设计得过大</strong>，一个接口要做 n 多件事情，返回 n 多个数据，就会导致接口 <strong>不够通用、可复用性不好</strong>。</p><p>那如何解决接口的 <strong>可复用性和易用性之间的矛盾</strong> 呢？这就要谈到我们本章的 <strong>门面模式</strong> 了。</p></div><h2 id="_1-什么是门面模式" tabindex="-1"><a class="header-anchor" href="#_1-什么是门面模式" aria-hidden="true">#</a> 1. 什么是门面模式</h2><p><strong>门面模式</strong>，也叫做外观模式，它的定义是：<strong>门面模式为子系统提供一组统一的接口，定义一组高层接口让子系统更易用</strong>。</p><p>举个例子，假设有一个系统 A，提供了 func1、func2、func3、func4 四个接口，系统 B 要完成某个功能，需要调用 A 系统的 func1、func2、func4 接口。</p><p>那么我们就可以利用 <strong>门面模式</strong>，提供一个 <strong>包裹 func1、func2、func4 接口调用的门面接口 func124</strong>，给系统 B 直接使用。</p><p>你可能会有疑问，如果外部需要调用的接口都各不相同，那就要为它们都提供一个门面接口吗？</p><p>这显然不是的，这样就要定义很多的接口，显然是不合理的。</p><p>所以我们应该根据实际情况来使用门面模式，有些情况可以直接让外部依次调用我们提供的接口，有些情况则需要提供门面接口。</p><p>这就涉及到门面模式的应用场景了，下面就具体来讲讲。</p><h2 id="_2-应用场景" tabindex="-1"><a class="header-anchor" href="#_2-应用场景" aria-hidden="true">#</a> 2. 应用场景</h2><p>在门面模式的定义中说到 “门面模式让子系统更易用”，实际上，门面模式除了解决易用性问题之外，还能解决其他很多方面的问题，也就是它的应用场景。</p><h3 id="_2-1-解决易用性问题" tabindex="-1"><a class="header-anchor" href="#_2-1-解决易用性问题" aria-hidden="true">#</a> 2.1 解决易用性问题</h3><p><strong>门面模式封装了系统的底层实现、隐藏了系统的复杂性，提供了一组更加简单易用、更高层的接口</strong>。</p><p>例如，Linux 系统的调用函数就可以看作一种门面，它是 Linux 系统暴漏给开发者使用的一组特殊的编程接口，它封装了低层更基础的 Linux 内核调用，使得开发者在使用时更加简单、易用。</p><p>再例如，Linux 的 Shell 命令也可以看作一种门面，它也封装了系统调用，提供了更加友好、简单的命令，让开发者可以直接通过命令与操作系统交互。</p><p>不知道你有没有发现，其实门面模式在解决易用性问题上，很像封装、抽象的设计思想，它提供更抽象的接口，封装了低层的实现细节。也很像迪米特法则（有依赖关系的类之间，只依赖必要的接口）和接口隔离原则（只为使用者提供与之有关的接口，不强迫使用者依赖它不需要的接口）。所以其实这些 <strong>设计原则、思想、模式很多都是相通的，都是为了解决系统的易用性、复用性、扩展性、维护性等问题</strong>。</p><h3 id="_2-2-解决性能问题" tabindex="-1"><a class="header-anchor" href="#_2-2-解决性能问题" aria-hidden="true">#</a> 2.2 解决性能问题</h3><p>如果我们的接口需要使用 <strong>网络通信</strong> 来进行请求，比如 RPC，而且外部系统在调用接口时，<strong>需要调用多个接口</strong> 才能完成某个功能，此时就需要进行多次接口调用，<strong>消耗多次网络通信的时间</strong>。所以，利用 <strong>门面模式</strong>，就可以将这多个接口包裹成一个门面接口，这样外部在调用时就只需要 <strong>进行一次网络通信</strong>，大大提高了响应速度。</p><p>那么在实现的时候，应该如何组织门面接口和非门面接口呢？</p><p>这可以根据门面接口的数量来决定：</p><ul><li>门面接口不多，那就可以将它跟非门面接口放到一块，当作普通接口来用即可；</li><li>门面接口很多，那就可以在已有的接口之上，再抽象出一层专门放置门面接口的类或包，从类、包的命名上跟原来的接口层做区分；</li><li>如果门面接口特别多，并且很多都是跨多个子系统的，那就可以将门面接口放到一个新的子系统中。</li></ul><h2 id="_3-总结" tabindex="-1"><a class="header-anchor" href="#_3-总结" aria-hidden="true">#</a> 3. 总结</h2><p>我们通过接口粒度的设计，引申到门面模式。<strong>接口粒度设计得过大会导致接口复用性不好、过小又会导致接口易用性不好</strong>。所以在实际开发中，需要权衡好这两方面。</p><p>我们要 <strong>尽量保持接口的可复用性，针对特殊的情况，可以使用冗余的门面接口，来提高更易用的接口</strong>。</p><p>门面模式除了解决易用性问题之外， 还能在进行网络通信的接口请求中 <strong>提高性能</strong>（接口响应速度）。</p>',25);function h(f,x){const t=a("router-link");return l(),i("div",null,[n("details",d,[_,n("nav",u,[n("ul",null,[n("li",null,[r(t,{to:"#_1-什么是门面模式"},{default:o(()=>[s("1. 什么是门面模式")]),_:1})]),n("li",null,[r(t,{to:"#_2-应用场景"},{default:o(()=>[s("2. 应用场景")]),_:1}),n("ul",null,[n("li",null,[r(t,{to:"#_2-1-解决易用性问题"},{default:o(()=>[s("2.1 解决易用性问题")]),_:1})]),n("li",null,[r(t,{to:"#_2-2-解决性能问题"},{default:o(()=>[s("2.2 解决性能问题")]),_:1})])])]),n("li",null,[r(t,{to:"#_3-总结"},{default:o(()=>[s("3. 总结")]),_:1})])])])]),g])}const v=e(p,[["render",h],["__file","门面模式.html.vue"]]);export{v as default};
