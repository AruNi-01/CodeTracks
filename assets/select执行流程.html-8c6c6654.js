import{_ as i}from"./plugin-vue_export-helper-c27b6911.js";import{r,o as a,c as p,a as t,d as n,w as e,b as o,e as g}from"./app-f0546e84.js";const c={},d={class:"hint-container details"},u=t("summary",null,"本文内容",-1),h={class:"table-of-contents"},_=g(`<div class="hint-container info"><p class="hint-container-title">前言</p><p>对于一个 CRUD Boy，每天最多使用的 SQL 语句非 select 莫属了吧。那么你知道一条 select 语句是如何执行的吗？</p><p>下面就以最常见的 MySQL 为例，来探究探究一条 select 语句到底要历经哪些坎坷，才能把数据呈现给我们。</p></div><h2 id="_1-客户端连接服务器" tabindex="-1"><a class="header-anchor" href="#_1-客户端连接服务器" aria-hidden="true">#</a> <strong>1. 客户端连接服务器</strong></h2><p>想要执行 select 语句，首先肯定要与 MySQL 服务器进行连接，这个连接是通过 <strong>连接器</strong> 来完成的。</p><p>首先，运行中的服务器程序和客户端程序本质上都是计算机上的一个进程，所以客户端与服务器连接的过程本质上就是 <strong>进程间通信</strong> 的过程。</p><p>在 Linux 中，进程间的通信方式有管道、共享内存、信号量、消息队列、Socket 通信等。前面的几种都是在同一台主机上进行通信，<strong>如果需要跨网络与不同主机的进程进行通信，则需要使用 Socket 通信</strong>。</p><blockquote><p>ps：Socket 也支持同主机上的进程间通信。</p></blockquote><p>在真实环境中，数据库服务器进程和客户端进程大概率是不在同一台主机上的，所以需要通过网络进行通信。</p><p>MySQL 采用的 Socket 类型是 <strong>TCP 字节流通信</strong>，MySQL 服务器在启动时会默认申请 3306 端口号，之后就在这个端口号上等待客户端进程的连接。</p><p>我们一般使用如下命令与 MySQL 服务器进行连接：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>mysql -h<span class="token variable">$ip</span> -u<span class="token variable">$username</span> -P<span class="token variable">$port</span> -p<span class="token variable">$password</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul><li><code>-h</code>：MySQL 服务器的 IP 地址，如果是本地连接可以省略；</li><li><code>-u</code>：用户名，管理员为 root；</li><li><code>-P</code>：指定端口号（注意是大写），使用默认端口可以省略；</li><li><code>-p</code>：连接密码（注意是小写），命令中可以不填（比较安全），在交互对话中进行填写。</li></ul><p>发起上面的命令后，就会进行 <strong>TCP 三次握手与服务端建立连接</strong>，然后就会校验客户端输入的用户名和密码，校验成功后就连接成功了，接下来就可以与 MySQL 服务器进行通信了，即可以发送 SQL 语句了。</p><div class="hint-container info"><p class="hint-container-title">客户端连接到 MySQL 后，一直不发起请求，会怎么样？</p><p>先来了解一下数据库里的 <strong>长连接</strong> 和 <strong>短连接</strong>：</p><ul><li>长连接：连接成功后，如果客户端有 N 个请求，则都会 <strong>复用</strong> 一个连接；</li><li>短连接：每次执行完几次请求就断开连接，下次请求需要 <strong>重新建立</strong> 一个连接。</li></ul><p>建立连接的过程是比较复杂的，因此我们一般都是使用 <strong>长连接</strong>。</p><p>在长连接的情况下，连接完成后，如果客户端没有任何操作，那么连接器就会 <strong>自动断开连接</strong>。这个时间由参数 <code>wait_timeout</code> 控制，默认值是 8 小时。</p><p>连接器断开连接后，如果客户端再次发送请求，就会收到一个错误提醒：Lost connection to MySQL server during query。这时候就需要重新建立连接，再发送请求。</p><p><strong>长连接的缺陷</strong>：可能会导致 MySQL <strong>占用的内存涨的非常快</strong>。因为 MySQL 在 <strong>执行过程中临时使用的内存是管理在连接对象里面的</strong>，这些资源 <strong>在连接断开时才会释放</strong>。所以长期累积下来，可能导致内存占用太大，被 OS 强行杀掉（OOM），看来是就像是 MySQL 异常重启了。</p><p><strong>解决方案</strong>：</p><ul><li><strong>定期断开长连接</strong>。</li><li>每次执行一个较大的操作后，通过 <strong>执行 <code>mysql_reset_connection</code> 来初始化连接资源</strong>。这个过程不需要重连和重新做权限验证，但是会将连接恢复到刚刚创建完时的状态。</li></ul></div><h2 id="_2-select-执行流程" tabindex="-1"><a class="header-anchor" href="#_2-select-执行流程" aria-hidden="true">#</a> <strong>2. select 执行流程</strong></h2><p>建立连接后，便可向 MySQL 服务器执行 SQL 语句，获取结果。</p><p>先从整体的角度来看看一条 select 请求会经历哪些过程，如下图所示：</p><p><img src="https://run-notes.oss-cn-beijing.aliyuncs.com/notes/202302151516142.png" alt="查询语句执行流程" loading="lazy"></p><p>从上面可以看出一条 select 语句大致的执行流程如下：</p><ol><li><p>首先会去 <strong>查询缓存</strong> 里面看之前是否执行过这条语句。查询缓存以 kv 形式存储在内存中，key 为 SQL 语句，value 为查询结果；</p><blockquote><p>注：由于缓存命中率不高，所以查询缓存在 MySQL 8.0 已移除。</p></blockquote></li><li><p>来到 <strong>解析器</strong>，主要是进行 SQL 语法的分析，生成对应的语法树；</p></li><li><p>再到 <strong>执行器</strong> 执行 SQL 语句，不过在执行之前，会先经过 <strong>预处理器</strong>（判断字段是否存在）和 <strong>优化器</strong>（基于成本生成执行计划）；</p></li><li><p>最后执行器会按照执行计划调用 <strong>存储引擎层，由存储引擎去真正地访问表中的数据</strong>；</p></li><li><p>执行器获取到查询结果，返回给客户端。</p></li></ol><p>可以发现，MySQL 执行请求的过程被划分为了 <strong>Server 层</strong> 和 <strong>存储引擎层</strong>。Server 层不涉及真实数据的存取，而存储引擎层具有存取真实数据的功能。</p><p>接下来就看看各个阶段主要做了什么事情。</p><h3 id="_2-1-查询缓存" tabindex="-1"><a class="header-anchor" href="#_2-1-查询缓存" aria-hidden="true">#</a> <strong>2.1 查询缓存</strong></h3><p>上面说到，在 <strong>MySQL 8.0 中已移除了查询缓存</strong>，来看看为什么呢？</p><p>查询缓存的设计是这样的：</p><ul><li>将之前查询的 SQL 语句作为 key，查询结果作为 value 存放在内存中；</li><li>新的查询会先经过查询缓存，通过 Hash 索引判断缓存是否命中，若命中则可直接返回缓存结果。</li></ul><p>这看上去和常见的缓存类似，没什么问题。但是查询缓存的 <strong>更新策略</strong> 是这样的：</p><ul><li>如果这张表有 <strong>更新操作</strong>，那么这个表的 <strong>所有查询缓存就会被清空</strong>。</li></ul><p>由于这种更新策略，当刚缓存了一系列的数据时，还没被使用呢，刚好这个表有个更新操作，那么这个缓存也就被清空了。</p><p>正是因为更新会导致查询缓存的命中率非常低，所以 MySQL 8.0 直接将查询缓存删除了。</p><h3 id="_2-2-解析阶段" tabindex="-1"><a class="header-anchor" href="#_2-2-解析阶段" aria-hidden="true">#</a> <strong>2.2 解析阶段</strong></h3><p>查询缓存被删除后，SQL 语句的第一站就是 <strong>解析器</strong>，它会对 SQL 语句做解析。主要做两件事：</p><ul><li>根据 SQL 语句 <strong>构建出语法树</strong>，方便后面获取 SQL 语句的类型、表名、字段名、where 条件等；</li><li>判断 SQL 语句是否满足 MySQL 的语法，即 <strong>检查是否有 SQL 语法错误</strong>。如果有误则会报错。</li></ul><p>不过需要注意，<strong>表不存在或者字段不存在，不是在解析器里判断的，而是在下面的执行阶段做的</strong>。</p><h3 id="_2-3-执行阶段" tabindex="-1"><a class="header-anchor" href="#_2-3-执行阶段" aria-hidden="true">#</a> <strong>2.3 执行阶段</strong></h3><p>通过了解析阶段后，SQL 语句就来到了执行阶段，每条 select 语句在执行阶段主要会经历以下三个阶段：</p><ul><li>prepare：预处理阶段；</li><li>optimize：优化阶段；</li><li>execute：真正的执行阶段。</li></ul><h4 id="阶段一-预处理阶段" tabindex="-1"><a class="header-anchor" href="#阶段一-预处理阶段" aria-hidden="true">#</a> <strong>阶段一：预处理阶段</strong></h4><p>在预处理阶段，<strong>预处理器</strong> 主要做两件事：</p><ul><li><strong>判断表是否存在或字段是否存在</strong>；</li><li><strong>将 <code>select *</code> 中的 <code>*</code> 替换为表上所有的列</strong>。</li></ul><h4 id="阶段二-优化阶段" tabindex="-1"><a class="header-anchor" href="#阶段二-优化阶段" aria-hidden="true">#</a> <strong>阶段二：优化阶段</strong></h4><p>在真正执行一条 select 语句之前，MySQL 在优化阶段的 <strong>优化器</strong> 会找出所有可以用来执行此语句的方案，然后 <strong>选择一个成本最低的方案，作为执行计划</strong>。</p><p>如果想要知道优化器选择了哪种方案，可以在 SQL 语句前加上 <code>explain</code> 命令，让它输出 SQL 语句的执行计划，执行计划中会有扫描方式、使用的索引等信息。</p><p>在 MySQL 中执行成本主要由两个方面组成：</p><ul><li><strong>I/O 成本</strong>：当我们的数据是存储在磁盘上时，需要将数据从磁盘加载到内存中，这个加载时间就称为 I/O 成本；</li><li><strong>CPU 成本</strong>：读取记录、判断记录是否满足搜索条件、对结果进行排序等等操作消耗的时间称为 CPU 成本；</li></ul><h4 id="阶段三-真正的执行阶段" tabindex="-1"><a class="header-anchor" href="#阶段三-真正的执行阶段" aria-hidden="true">#</a> <strong>阶段三：真正的执行阶段</strong></h4><p>选择出成本最低的执行方案后，才开始真正的执行阶段，执行阶段由 <strong>执行器</strong> 完成。</p><p>在执行的过程中，执行器会调用存储引擎层的 API，和存储引擎交互，<strong>交互是以记录为单位的</strong>。</p><p>存储引擎层 <strong>每查出一条记录，就要返回给 Server层判断该记录是否满足查询条件</strong>（<strong>每查询出一条记录就要返回判断</strong>）：</p><ul><li><p>满足条件则将记录发送给客户端；</p><blockquote><p>是的没错，<strong>Server 层每从存储引擎读到一条符合条件的记录就会发送给客户端</strong>，之所以客户端显示的时候是直接显示所有记录的，是因为客户端是等查询语句查询完成后，才会显示出所有的记录。</p></blockquote></li><li><p>不满足则跳过，继续读取下一条记录。</p></li></ul><p>当存储引擎把把表中的记录都读完时，就会像执行器返回读取完毕的信息，执行器收到后，就会停止查询。</p><p>停止查询后，执行器会提示客户端已经完成了查询操作，客户端就会显示出所有的查询记录了。</p><p>一条 SQL 语句到此也就执行完毕了。</p><h2 id="_3-总结" tabindex="-1"><a class="header-anchor" href="#_3-总结" aria-hidden="true">#</a> <strong>3. 总结</strong></h2><p>通过了上面的学习，现在应该知道一条 select 语句经历了哪些：</p><ol><li><strong>查询缓存</strong>（MySQL 8.0 已移除）：缓存命中则直接返回结果，否则继续往下走；</li><li><strong>解析阶段</strong>：解析器对 SQL 进行语法解析，生成语法树、判断语法是否有误；</li><li><strong>执行阶段</strong>： <ul><li><strong>预处理阶段</strong>：检查表或字段是否存在，将 <code>*</code> 替换成所有列；</li><li><strong>优化阶段</strong>：基于成本选择最优的执行计划；</li><li><strong>真正执行阶段</strong>：执行器根据执行计划从存储引擎读取记录，返回给客户端；</li></ul></li></ol><p>现在再来回看一开始的那张图，是不是就清晰多了：</p><p><img src="https://run-notes.oss-cn-beijing.aliyuncs.com/notes/202302151516142.png" alt="查询语句执行流程" loading="lazy"></p><h2 id="_4-参考文章" tabindex="-1"><a class="header-anchor" href="#_4-参考文章" aria-hidden="true">#</a> <strong>4. 参考文章</strong></h2>`,58),S=t("li",null,"《MySQL 是怎样运行的》",-1),L=t("li",null,"《MySQL 实战 45 讲》",-1),Q={href:"https://xiaolincoding.com/",target:"_blank",rel:"noopener noreferrer"};function y(b,f){const s=r("router-link"),l=r("ExternalLinkIcon");return a(),p("div",null,[t("details",d,[u,t("nav",h,[t("ul",null,[t("li",null,[n(s,{to:"#_1-客户端连接服务器"},{default:e(()=>[o("1. 客户端连接服务器")]),_:1})]),t("li",null,[n(s,{to:"#_2-select-执行流程"},{default:e(()=>[o("2. select 执行流程")]),_:1}),t("ul",null,[t("li",null,[n(s,{to:"#_2-1-查询缓存"},{default:e(()=>[o("2.1 查询缓存")]),_:1})]),t("li",null,[n(s,{to:"#_2-2-解析阶段"},{default:e(()=>[o("2.2 解析阶段")]),_:1})]),t("li",null,[n(s,{to:"#_2-3-执行阶段"},{default:e(()=>[o("2.3 执行阶段")]),_:1})])])]),t("li",null,[n(s,{to:"#_3-总结"},{default:e(()=>[o("3. 总结")]),_:1})]),t("li",null,[n(s,{to:"#_4-参考文章"},{default:e(()=>[o("4. 参考文章")]),_:1})])])])]),_,t("ul",null,[S,L,t("li",null,[t("a",Q,[o("小林 coding"),n(l)])])])])}const k=i(c,[["render",y],["__file","select执行流程.html.vue"]]);export{k as default};
