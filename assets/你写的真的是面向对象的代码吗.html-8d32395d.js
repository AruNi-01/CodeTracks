import{_ as p}from"./plugin-vue_export-helper-c27b6911.js";import{r as o,o as c,c as i,b as n,e as a,w as t,a as l,d as e}from"./app-ccb33381.js";const r={},u={class:"hint-container details"},d=n("summary",null,"本文内容",-1),k={class:"table-of-contents"},g=l(`<div class="hint-container info"><p class="hint-container-title">前言</p><p>虽然现在大部分人都是使用的面向对象编程的语言来编写代码，但是你觉得这样写出来的代码就是面向对象的吗？</p><p>其实，可能会因为一些无意的操作，导致我们编写出面向过程编程风格的代码。</p></div><h2 id="_1-有哪些代码看似面向对象-实际是面向过程的" tabindex="-1"><a class="header-anchor" href="#_1-有哪些代码看似面向对象-实际是面向过程的" aria-hidden="true">#</a> 1. 有哪些代码看似面向对象，实际是面向过程的？</h2><h3 id="_1-1-滥用-getter、setter-方法" tabindex="-1"><a class="header-anchor" href="#_1-1-滥用-getter、setter-方法" aria-hidden="true">#</a> 1.1 滥用 getter、setter 方法</h3><p>很多程序员在项目开发时，定义完一个类的属性之后，马上就会顺手把这些属性的 getter、setter 方法都自动生成上（或者直接使用 Lombok 插件）。</p><p>但是，我们真的需要吗？相反，这还 <strong>违反了</strong> 面向对象编程的 <strong>封装</strong> 特性，相当于将面向对象编程风格退化成了面向过程编程风格。</p><p>举个例子，下面是一个简易购物车的类：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ShoppingCart</span> <span class="token punctuation">{</span>
  <span class="token keyword">private</span> <span class="token keyword">int</span> itemsCount<span class="token punctuation">;</span>
  <span class="token keyword">private</span> <span class="token keyword">double</span> totalPrice<span class="token punctuation">;</span>
  <span class="token keyword">private</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">ShoppingCartItem</span><span class="token punctuation">&gt;</span></span> items <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  
  <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">getItemsCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>itemsCount<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  
  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setItemsCount</span><span class="token punctuation">(</span><span class="token keyword">int</span> itemsCount<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>itemsCount <span class="token operator">=</span> itemsCount<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  
  <span class="token keyword">public</span> <span class="token keyword">double</span> <span class="token function">getTotalPrice</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>totalPrice<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  
  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setTotalPrice</span><span class="token punctuation">(</span><span class="token keyword">double</span> totalPrice<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>totalPrice <span class="token operator">=</span> totalPrice<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">public</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">ShoppingCartItem</span><span class="token punctuation">&gt;</span></span> <span class="token function">getItems</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>items<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  
  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">addItem</span><span class="token punctuation">(</span><span class="token class-name">ShoppingCartItem</span> item<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    items<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span><span class="token punctuation">;</span>
    itemsCount<span class="token operator">++</span><span class="token punctuation">;</span>
    totalPrice <span class="token operator">+=</span> item<span class="token punctuation">.</span><span class="token function">getPrice</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// ...省略其他方法...</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>代码很简单，来看看这段代码有什么问题。</p><p>先看前两个属性 <code>itemsCount</code> 和 <code>totalPrice</code>，虽然它们都是 private 私有属性，但是 <strong>提供了 public 的 getter、setter 方法</strong>，这样外部就可以通过这些方法来修改这两个属性的值了。而且外部还可以随意调用 setter 方法，重新设置这两个属性的值，这样也会导致其跟 items 属性的值不一致。</p><p>而面向对象封装的定义是：隐藏内部数据，外部仅通过有限的接口进行访问、修改内部数据。所以当 <strong>暴露了不该暴露的 setter 方法时，就会导致数据没有任何的访问权限，任何代码都可以随意修改它，这就违反了面向对象的封装特性了</strong>，代码也就退化成了面向过程编程风格的了。</p><p>除了这两个基本属性的问题，另一个 <strong>引用类型的属性</strong> 其实也有大问题。items 属性是一个 List 类型的集合，如果给他提供 getter 方法，那么 <strong>外部在获取这个 List 集合后，是可以操作这个集合的内部数据的</strong>。比如：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">ShoppingCart</span> cart <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ShoppCart</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
cart<span class="token punctuation">.</span><span class="token function">getItems</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 清空购物车</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这样 <strong>外部就拥有了操作内部数据的能力</strong>，无疑是很危险的操作，可能会导致数据不一致。正确的做法应该是在内部提供一个操作内部数据的方法，比如 <code>clear()</code>，外部只能通过这个方法清空购物车，而不是自己拥有这个能力。</p><p>如果有一个需求就是要查看购物车里都有啥，那么这时除了提供一个返回 items 的 getter 方法外，还有其他的好办法吗？</p><p>我们可以让 getter 方法返回一个 <strong>不可被修改的 UnmodifiableList 集合容器</strong>，而这个容器类重写了 List 容器中跟修改数据相关的方法，比如 <code>add()</code>、<code>clear()</code> 等方法。<strong>一旦调用这些修改数据的方法，代码就会抛出 UnsupportedOperationException 异常</strong>，这样就避免了容器中的数据被修改。</p><p>不过这样还是有一个问题，虽然不能直接修改集合了，但是可以修改集合里面的具体数据，例如：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">ShoppingCart</span> cart <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ShoppingCart</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
cart<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ShoppingCartItem</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">ShoppingCartItem</span><span class="token punctuation">&gt;</span></span> items <span class="token operator">=</span> cart<span class="token punctuation">.</span><span class="token function">getItems</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">ShoppingCartItem</span> item <span class="token operator">=</span> items<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
item<span class="token punctuation">.</span><span class="token function">setPrice</span><span class="token punctuation">(</span><span class="token number">19.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 这里修改了item的价格属性</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>因为在 Java 中参数是值传递，所以将集合对象返回的时候，实际上是返回了该集合的地址，我们 <strong>只限制了对集合的操作会抛出异常，但是并没有限制集合里面的数据</strong>，所以能通过该地址直接修改里面的数据。</p><p>其实要解决这个问题，可以在返回集合时，采用 <strong>深拷贝克隆</strong>，这样就算修改了数据，实际的数据也不会受影响。</p><p>这个例子扩展得有点开，简单总结来说，就是需要我们合理的编写 getter、setter 方法，在可能出现问题的地方多做一些处理。而不是一股脑的就把所有不需要的方法也生成了。</p><h3 id="_1-2-滥用全局变量和全局方法" tabindex="-1"><a class="header-anchor" href="#_1-2-滥用全局变量和全局方法" aria-hidden="true">#</a> 1.2 滥用全局变量和全局方法</h3><p>在面向对象编程中，常见的 <strong>全局变量</strong> 有 <strong>单例类对象、静态成员变量、常量</strong> 等，常见的 <strong>全局方法有静态方法</strong>。</p><p><strong>常量</strong> 是一种非常常见的全局变量，比如一些代码中的配置参数，一般都设置为常量，<strong>放到一个 Constants 类中</strong>。</p><p><strong>静态方法一般用来操作静态变量或者外部数据</strong>。常用的各种 Utils 类，里面的方法一般都会定义成静态方法，可以在不用创建对象的情况下直接拿来使用。而静态方法将方法与数据分离，破坏了封装特性，是典型的面向过程风格。</p><p>这些全局变量和全局方法中，最常使用的无非就是 Constants 类和 Utils 类，下面来探讨一下它们的利弊。</p><div class="hint-container info"><p class="hint-container-title">Constants 类</p><p>有些程序员在编写 Constants 类的时候，<strong>会把所有的常量都扔到一个类中</strong>，统称为常量类。这样在常量多起来的情况下，会严重影响代码的 <strong>可维护性</strong>。因为在查找或修改某个常量时，都要到这一个类中进行。</p><p>除此之外，如果要在另一个项目中，复用本项目的某个类，而这个类又依赖于 Constants，即使这个类只依赖了一小部分常量，仍需要将整个 Constants 类一并引入，这就 <strong>引入了很多无关常量到项目中</strong>，导致代码的 <strong>复用性变差</strong>。</p><p>一个解决方法是把 Constants 类 <strong>拆分为功能更单一的多个类</strong>，分开存放常量。或者，如果 <strong>该常量只在某个类中使用</strong>，不会在别处使用，那么可以考虑 <strong>把该常量就定义到该类中</strong>。</p></div><div class="hint-container info"><p class="hint-container-title">Utils 类</p><p>Utils 类的出现是基于这样一个问题背景：</p><p>如果 <strong>有多个类共同使用到了某个相同的功能</strong>，为了避免代码重复，我们不会将该功能重复地实现多次。要解决这个问题，可以用之前讲的 <strong>继承</strong>，把共同的属性或方法抽取出来放到父类中，子类就可以复用了。</p><p>但是，有时候 <strong>这些类之间并没有继承关系</strong>，比如 Crawler 类和 PageAnalyzer 类，一个负责爬取页面，一个负责页面分析，它们都要使用 URL 拼接和分割的功能，但是这两个类并没有什么关系，总不能仅仅为了代码复用，而硬生生地抽象出一个父类来。</p><p>因为拼接和分割 URL 的功能不需要共享任何数据，不需要定义任何属性。所以，可以把它放到一个 <strong>Utils 工具类</strong> 中，其他地方都能使用该工具类中的方法（静态方法）。</p><p>其实这种 <strong>只包含静态方法而不包含任何属性的 Utils 类</strong>，是彻彻底底的 <strong>面向过程的编程风格</strong>，因为它把方法单独分离出来了。</p><p>但是，<strong>并不代表我们就要杜绝使用 Utils 类</strong>，因为它确确实实能解决代码复用的问题，所以不是说只能面向对象编程，而是要合理设计。</p><p>另外，类比 Constants 类的设计，在设计 Utils 类的时候，最好也能针对不同的功能，设计不同的 Utils 类，而不要设计一个过大的 Utils 类。</p></div><h3 id="_1-3-定义数据和方法分离的类" tabindex="-1"><a class="header-anchor" href="#_1-3-定义数据和方法分离的类" aria-hidden="true">#</a> 1.3 定义数据和方法分离的类</h3><p>回想一下，我们在平时的开发中，有出现过数据定义在一个类中、方法定义在另一个类中吗？其实，如果是使用 <strong>MVC 架构</strong> 做程序开发时，这样的代码你天天都在写。</p><p>在 MVC 架构中，Controller 层负责暴露接口给前端调用，Service 层负责处理业务逻辑，Repository 层负责与数据库打交道。同时，我们还会定义一些 VO（View Object）、BO（Business Object）、Entity，<strong>这些类中只会定义数据，而操作这些数据的业务逻辑都在对应的 Controller 类、Service 类、Repository 类中</strong>。所以这就是一种典型的 <strong>面向过程</strong> 的编程风格。</p><p>实际上这种开发模式叫做 <strong>基于贫血模型</strong> 的开发模式，这也是我们平时经常使用的一种 Web 项目的开发模式。那既然这种开发模式明显违背了面向对象的编程风格，为什么还如此常用呢？（后续文章会讲解）</p><h2 id="_2-为什么这么容易写出面向过程的代码" tabindex="-1"><a class="header-anchor" href="#_2-为什么这么容易写出面向过程的代码" aria-hidden="true">#</a> 2. 为什么这么容易写出面向过程的代码？</h2><p>我们在进行面向对象编程时，为什么很容易写出这种面向过程风格的代码呢？</p><p>可以联想一下实际生活中，如果要完成一项任务，我们一般都会思考先做什么、后做什么，如何一步步的顺序执行，最后完成整个任务，也就是讲整体拆解成局部步骤。所以说面向过程编程风格很符合人的这种流程化思维方式。</p><p>而面向对象编程风格恰恰相反，它不是先去按照执行流程来拆解任务，而是将任务抽象成一个个的类，设计类之间怎么进行交互，最后再按照流程将类组装起来，完成整个任务，这样的思考路程是比较复杂的，不是很符合人的思考习惯。而且在设计类、封装方法、设计类之间的关系时，都是比较困难的。</p><p>所以为了简单、快捷，很多人就不由自主的写出了面向过程风格的代码了。</p><h2 id="_3-总结" tabindex="-1"><a class="header-anchor" href="#_3-总结" aria-hidden="true">#</a> 3. 总结</h2><p>在我们实际编码过程中，会不经意的设计出 <strong>违反面向对象编程风格的代码</strong>，例如：</p><ul><li>滥用 getter、setter 方法；</li><li>Constants 类、Utils 类的设计问题；</li><li>基于贫血模式的开发模式（MVC）。</li></ul><p>由于面向过程编程风格的开发更符合我们人类的思考方式，编写起来比较简单、易于理解，学习成本也比较低，所以人们会更加倾向于这样的开发方式。</p><p>所以说，我们在面向对象编程的时候，<strong>不一定非得百分百遵守面向对象</strong>，而是要灵活、合理的与面向过程相结合，写出 <strong>可维护、易扩展、复用性高</strong> 的代码。</p>`,41);function v(m,b){const s=o("router-link");return c(),i("div",null,[n("details",u,[d,n("nav",k,[n("ul",null,[n("li",null,[a(s,{to:"#_1-有哪些代码看似面向对象-实际是面向过程的"},{default:t(()=>[e("1. 有哪些代码看似面向对象，实际是面向过程的？")]),_:1}),n("ul",null,[n("li",null,[a(s,{to:"#_1-1-滥用-getter、setter-方法"},{default:t(()=>[e("1.1 滥用 getter、setter 方法")]),_:1})]),n("li",null,[a(s,{to:"#_1-2-滥用全局变量和全局方法"},{default:t(()=>[e("1.2 滥用全局变量和全局方法")]),_:1})]),n("li",null,[a(s,{to:"#_1-3-定义数据和方法分离的类"},{default:t(()=>[e("1.3 定义数据和方法分离的类")]),_:1})])])]),n("li",null,[a(s,{to:"#_2-为什么这么容易写出面向过程的代码"},{default:t(()=>[e("2. 为什么这么容易写出面向过程的代码？")]),_:1})]),n("li",null,[a(s,{to:"#_3-总结"},{default:t(()=>[e("3. 总结")]),_:1})])])])]),g])}const w=p(r,[["render",v],["__file","你写的真的是面向对象的代码吗.html.vue"]]);export{w as default};
