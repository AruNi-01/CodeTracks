import{_ as g}from"./plugin-vue_export-helper-c27b6911.js";import{r,o as s,c as a,b as o,e as n,w as e,d as t,a as c}from"./app-bb331e56.js";const d={},p={class:"hint-container details"},b=o("summary",null,"本文内容",-1),h={class:"table-of-contents"},_=c('<h2 id="_1-什么是-binlog" tabindex="-1"><a class="header-anchor" href="#_1-什么是-binlog" aria-hidden="true">#</a> 1. 什么是 binlog？</h2><p>之前学习的 redo log，是属于 InnoDB 存储引擎层的，MySQL 的 <strong>Server 层</strong> 也有自己的日志，称为 <strong>binlog</strong>（归档日志）。</p><p>binlog 记录的是 <strong>全量日志</strong>，写完一个文件就会写下一个文件，所以 binlog 里有数据库的所有数据信息，非常适合用来做 <strong>备份和主从复制</strong>。</p><h2 id="_2-binlog-的格式" tabindex="-1"><a class="header-anchor" href="#_2-binlog-的格式" aria-hidden="true">#</a> 2. binlog 的格式</h2><p>binlog 有 3 种格式类型，分别是 statement（默认格式）、row 和 mixed，它们的区别如下：</p><ul><li><strong>statement</strong>：记录的是 <strong>SQL 原文</strong>，相当于逻辑日志，重现时需要执行 SQL 语句；</li><li><strong>row</strong>：<strong>会把具体受影响的行记录下来</strong>，此时不能被称为逻辑日志；</li><li><strong>mixed</strong>：<strong>混合模式</strong>，根据不同的情况自动判断使用 statement 还是 row。</li></ul><p>如果是 statement 格式，SQL 语句中又含有 uuid 或者 now 等函数，那么 <strong>由于执行 SQL 语句的时间不一致，会导致数据不一致</strong>。而 row 格式就不会有这个问题，因为它会直接把当时的具体数据给记录下来。</p><p>但是 row 格式会 <strong>记录每行数据变化的结果</strong>，例如一条 delete 删除 10 万行数据，<strong>删除多少行就会产生多少条记录</strong>，使得 <strong>写 binlog 十分耗时，且占用更大的磁盘空间</strong>。而 statement 格式就只会记录一条 delete 语句。</p><p>基于这两种格式的优缺点，所以就出现了 <strong>mixed 格式</strong>，这是一种折中方案。MySQL 会 <strong>判断这条 SQL 语句是否可能会造成数据不一致</strong>（包括备份和主从复制），如果有可能，则使用 row 格式，否则使用 statement 格式。</p><p>所以，statement 格式的 binlog 是不合理的，因为会造成数据不一致这种严重的错误。至少都应该将 binlog 设置为 mixed 格式。</p><p>但是，还是建议把 binlog 设置为 row 格式，因为可以进行 <strong>数据的恢复</strong>（注意不是崩溃恢复）：</p><ul><li>insert：binglog 会记录插入数据的所有字段，所以恢复时将 insert 转为 delete 即可；</li><li>delete：binglog 会记录被删除行的整行信息，所以恢复时将 delete 转为 insert 即可；</li><li>update：binglog 会记录修改前整行的数据和修改后整行的数据，所以恢复时将两行的信息对调即可。</li></ul><h2 id="_3-为什么需要两份日志" tabindex="-1"><a class="header-anchor" href="#_3-为什么需要两份日志" aria-hidden="true">#</a> 3. 为什么需要两份日志？</h2><p>为什么 MySQL 要同时使用 redo log 和 binlog 两份日志呢？</p><p>因为之前 MySQL 用的是 MyISAM 存储引擎，是没有 redo log 的，也就是没有 crash-safe 的能力。</p><p><strong>binlog 是没有 crash-safe 能力的</strong>，它只能用于归档，所以 InnoDB 才设计出了 redo log。</p><p>下面分析一下这两种日志的 <strong>区别</strong>：</p><ul><li><p>binlog 在 <strong>Server 层</strong>，所有引擎都可使用；</p><p>redo log 是 <strong>InnoDB 特有的</strong>。</p></li><li><p>binlog 有 <strong>不同的日志格式</strong>；</p><p>redo log 是 <strong>物理日志</strong>，记录的是 <code>在某个表空间在某个数据页上做了什么修改</code>。</p></li><li><p>binlog 是 <strong>全量日志</strong>，写完一个文件接着写下一个；</p><p>redo log 是 <strong>循环写</strong>，写完后接着从头开始写。</p></li></ul><p>可以发现：</p><ul><li>由于 redo log 是循环写，因为肯定不能用来备份和主从复制这种需要全量数据的功能；</li><li>而 binlog 为 statement 格式时，记录的是逻辑日志，不知道具体的数据是什么；崩溃恢复时也不知道从哪儿开始恢复，自然也没有 crash-safe 的能力。</li></ul><p>所以 binlog 和 redo log 是互补的，如果你要说，为什么不把 binlog 改造成 redo log 那样，这不是重复造轮子嘛，而且存储引擎层是插件式的置入 MySQL，不改动任何代码就可以使用 redo log，所以现在的 MySQL 默认都是 InnoDB 引擎了。</p><p>而且 binlog 和 redo log 在更新数据时都是配合使用的，从而保证数据一致性。（后续在两阶段提交中会讲到）</p><h2 id="_4-binlog-刷盘时机" tabindex="-1"><a class="header-anchor" href="#_4-binlog-刷盘时机" aria-hidden="true">#</a> 4. binlog 刷盘时机</h2><p>binlog 也有自己的缓冲区 <strong>binlog cache</strong>，这个缓冲区是由 Server 层申请的，不在 InnoDB 的 Buffer Pool 中。</p><p>binlog 的写入逻辑比较简单：</p><ul><li><strong>事务执行时，先把日志写到 binlog cache，事务提交时，再把 binlog cache 写到 binlog 文件中</strong>。</li></ul><div class="hint-container danger"><p class="hint-container-title">注意</p><p><strong>一个事务的 binlog 是不能拆开的</strong>，无论这个事务多大，都要保证一次性写入。</p><p>因为 <strong>binlog 是基于事务来记录的</strong>，一个完整的 binlog 就是一个完整的事务，如果 binlog 被拆开，那这个事务就不完整、不原子了。</p><p>而 redo log 是基于数据页来记录的，只需要保证数据页的完整就可以了，所以 redo log 可以拆开。</p></div><p>MySQL给 binlog cache 申请了一片内存，<strong>每个线程一个 binlog cache</strong>，参数 <code>binlog_cache_size</code> 用于控制单个线程的 binlog cache 大小。<strong>如果超过了这个大小，就要暂存到磁盘</strong>，而不是先进行刷盘。</p><div class="hint-container info"><p class="hint-container-title">为什么 binlog cache 是线程独占，而 redo log buffer 是共享的？</p><p>因为 redo log 是以数据页格式存储的，<strong>数据页本来就是共享的</strong>；而 binlog 是以 statement 或 row 格式存储，不会记录数据页，<strong>执行 binlog 时需要上下文环境，是跟事务有关的</strong>。</p><p>redo log buffer 是所有线程共享，所以 <strong>可能存在被动刷盘</strong>（后台线程），而 binlog cache 不可能存在。</p></div><p><strong>事务提交时</strong>，执行器就会把 binlog cache 里 <strong>完整的事务</strong> 写入 binlog 中，并清空 binlog cache。</p><p><img src="https://run-notes.oss-cn-beijing.aliyuncs.com/notes/202303111320403.png" alt="binlog cach" loading="lazy"></p><p>虽然每个线程有自己的 binlog cache，但是 <strong>共用同一份 binlog 文件</strong>。</p><ul><li>图中的 write 只是把日志写入操作系统的 page cache 中，并没有进行刷盘，所以速度比较快；</li><li>图中的 fsync 才是真正的刷盘操作，涉及磁盘 I/O，速度比较慢。</li></ul><p>write 和 fsync 的时机，即刷盘时机，由参数 <strong><code>sync_binlog</code></strong> 控制：</p><ul><li><code>sync_binlog = 0</code>：每次提交事务，<strong>只 write，不 fsync</strong>；</li><li><code>sync_binlog = 1</code>：每次提交事务 <strong>都会执行 fsync</strong>；</li><li><code>sync_binlog = N</code>（N &gt; 1）：每次提交事务都 write，<strong>累积 N 个事务后才 fsync</strong>。</li></ul><blockquote><p>这里可以和 redo log 在事务提交时的刷盘时机对比起来看。</p></blockquote><p>系统默认的设置是 <code>sync_binlog = 0</code>，这时性能最好，但风险也最高，因为一旦发生宕机，page cache 中还没持久化到磁盘的数据就会丢失。</p><p>当参数设置为 1 时，虽然最安全，但性能也最低。所以 <strong>一般将参数设置为 100~1000 来平衡安全和性能</strong>，这样最多会丢失最近 N 个事务的 binlog 日志。</p><h2 id="_5-总结" tabindex="-1"><a class="header-anchor" href="#_5-总结" aria-hidden="true">#</a> 5. 总结</h2><p><strong>binlog</strong> 属于 Server 层，由于保存的是 <strong>全量日志</strong>，所以常用来做备份或主从复制。而 <strong>redo log</strong> 属于存储引擎层，是 <strong>循环写</strong>，因此不具备所有的数据记录，也就无法进行备份或主从复制了。</p><p><strong>binlog 也没有 redo log 的 crash-safe 能力</strong>，因为它没有像 redo log 那样的机制，例如 statement 格式的物理日志，redo log 可通过 checkpoint 机制方便的知道哪些数据已刷盘，需要恢复哪些数据。</p><p>binlog 提供 <strong>不同的日志格式</strong>：</p><ul><li>statement：记录原始 SQL 语句，逻辑日志；</li><li>row：记录具体受影响的所有行数据；</li><li>mided：混合使用。</li></ul><p>binlog 有自己的缓冲区 binlog cache，每次 <strong>事务提交时</strong>，会将 binlog 刷盘，刷盘时机由参数 <code>sync_binlog</code> 控制：</p><ul><li>参数为 0：每次事务提交时，只 write，不 fsync；</li><li>参数为 1：每次事务提交时都 fsync；</li><li>参数为 N（N &gt; 1）：每次事务提交时都 write，累积 N 个事务后才 fsync。</li></ul><h2 id="_6-参考文章" tabindex="-1"><a class="header-anchor" href="#_6-参考文章" aria-hidden="true">#</a> 6. 参考文章</h2>',46),u=o("li",null,"《MySQL 实战 45 讲》",-1),f={href:"https://xiaolincoding.com",target:"_blank",rel:"noopener noreferrer"};function m(y,S){const l=r("router-link"),i=r("ExternalLinkIcon");return s(),a("div",null,[o("details",p,[b,o("nav",h,[o("ul",null,[o("li",null,[n(l,{to:"#_1-什么是-binlog"},{default:e(()=>[t("1. 什么是 binlog？")]),_:1})]),o("li",null,[n(l,{to:"#_2-binlog-的格式"},{default:e(()=>[t("2. binlog 的格式")]),_:1})]),o("li",null,[n(l,{to:"#_3-为什么需要两份日志"},{default:e(()=>[t("3. 为什么需要两份日志？")]),_:1})]),o("li",null,[n(l,{to:"#_4-binlog-刷盘时机"},{default:e(()=>[t("4. binlog 刷盘时机")]),_:1})]),o("li",null,[n(l,{to:"#_5-总结"},{default:e(()=>[t("5. 总结")]),_:1})]),o("li",null,[n(l,{to:"#_6-参考文章"},{default:e(()=>[t("6. 参考文章")]),_:1})])])])]),_,o("ul",null,[u,o("li",null,[o("a",f,[t("小林 coding"),n(i)])])])])}const L=g(d,[["render",m],["__file","binlog：主从复制和备份.html.vue"]]);export{L as default};
