import{_ as l}from"./plugin-vue_export-helper-c27b6911.js";import{r as o,o as g,c as d,b as s,e as t,w as e,d as n,a}from"./app-be06d90c.js";const p={},c={class:"hint-container details"},u=s("summary",null,"本文内容",-1),_={class:"table-of-contents"},h=a(`<h2 id="_1-为什么需要-rdb-快照" tabindex="-1"><a class="header-anchor" href="#_1-为什么需要-rdb-快照" aria-hidden="true">#</a> 1. 为什么需要 RDB 快照？</h2><p>在上一章中讲解了 Redis 的一种持久化方案 — AOF 日志，它记录了操作的命令，在 AOF 文件过大时会进行 AOF 重写来压缩文件；而且提供了三种刷盘策略，来保证数据丢失和阻塞主线程之间的平衡。那为什么还需要 RDB 快照呢？</p><p>这就要从 AOF 日志的格式说起，AOF 日志中记录的是 <strong>逻辑日志</strong>，而 <strong>不是实际的数据</strong>，所以使用 AOF 进行故障恢复时，<strong>需要把日志命令都执行一遍</strong>，如果日志很多，Redis <strong>恢复的时间就会很长</strong>，影响正常使用。这时候就需要 RDB 快照了。</p><h2 id="_2-什么是-rdb-快照" tabindex="-1"><a class="header-anchor" href="#_2-什么是-rdb-快照" aria-hidden="true">#</a> 2. 什么是 RDB 快照？</h2><p>RDB（Redis DataBase）快照，就是一个 <strong>内存快照</strong>，可以 <strong>把内存中某个时刻的数据记录下来</strong>，当然了，也是记录到磁盘上，这样就算宕机，快照文件也不会丢失。</p><p>与 AOF 不同，RDB 记录的是某个时刻的数据，而不是命令，所以是 <strong>真实的物理数据</strong>。在做数据恢复时，<strong>可以直接把 RDB 文件读入内存</strong>，很快就能完成数据恢复。</p><p>因为 Redis 的数据都在内存，在进行 RDB 快照时是 <strong>全量快照</strong>，也就是会 <strong>把内存中的数据全部记录到磁盘中</strong>。</p><p>由于是全量快照，所以当数据量很大时，执行 RDB 快照是非常耗时的，此时肯定不能阻塞主线程，Redis 也提供了两个命令来生成 RDB 文件：</p><ul><li><strong>save</strong>：主线程执行，<strong>会导致 Redis 阻塞</strong>；</li><li><strong>bgsave</strong>：fork 一个 <strong>子进程</strong> 执行，<strong>不会阻塞主线程</strong>，这也是默认配置。</li></ul><div class="hint-container info"><p class="hint-container-title">疑问：既然全量快照很耗时，那能不能实现增量快照呢？</p><p>要实现增量快照，那在这次 RDB 快照生成后，<strong>后续就需要记录哪些数据被修改了</strong>，而这 <strong>需要额外增加元数据信息去记录</strong>，会带来不小的开销。而且如果一个键值对本身很小，为了记录修改而需要的额外元数据就会显得占比很大，<strong>内存对于 Redis 是非常宝贵的，所以有些得不偿失了</strong>，因此 Redis 也并没有实现增量快照的功能。</p></div><p>既然 RDB 快照不是一条条命令，这就意为着不会随每条命令执行时写入文件，那什么时候进行 RDB 快照呢？执行快照时 Redis 还能否处理请求？这些问题都是 RDB 快照需要解决的。</p><h2 id="_3-什么时候进行-rdb-快照" tabindex="-1"><a class="header-anchor" href="#_3-什么时候进行-rdb-快照" aria-hidden="true">#</a> 3. 什么时候进行 RDB 快照？</h2><p>RDB 记录的是某一时刻的数据，所以进行 RDB 快照的时机就非常重要了，生成 RDB 的间隔越小，比如 1 秒生成一次，那数据丢失的就越少。</p><p>bgsave 生成 RDB 快照时不会阻塞主线程，这意味着我们可以让 RDB 快照生成的时间间隔越小越好吗？</p><p>其实也并不是，虽然 bgsave 不会阻塞主线程，但频繁执行全量快照，会带来下面的问题：</p><ul><li><strong>频繁将全量数据写入磁盘，会给磁盘带来很大压力</strong>，可能前一个还没做完，后一个又开始了，导致恶性循环；</li><li>bgsave 需要由主线程 fork 出子进程，与 AOF 重写类似，<strong>fork 这个过程会阻塞主线程</strong>，数据越多，fork 过程越长。所以 <strong>频繁执行 bgsave 会导致频繁 fork 子进程，导致频繁阻塞主线程</strong>（所以 Redis 中只能有一个 bgsave 在运行）。</li></ul><p>其实，Redis 提供了配置来规定多久执行一次 bgsave，默认提供的配置如下：</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code>save <span class="token number">900</span> <span class="token number">1</span>
save <span class="token number">300</span> <span class="token number">10</span>
save <span class="token number">60</span> <span class="token number">10000</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>注：虽然配置项叫 save，但之际执行的是 bgsave，并不会阻塞主线程。</p></blockquote><p>这三个配置的含义分别如下：</p><ul><li>900 秒内，至少进行了 1 次修改操作；</li><li>300 秒内，至少进行了 10 次修改操作；</li><li>60 秒内，至少进行了 10000 次修改操作。</li></ul><p><strong>只要满足上面条件的任意一个，就会执行 bgsave</strong>，对 Redis 进行全量快照。</p><p>所以我们可以根据自己业务能接受数据丢失的实际情况，来进行配置。</p><h2 id="_4-进行快照时能修改数据吗" tabindex="-1"><a class="header-anchor" href="#_4-进行快照时能修改数据吗" aria-hidden="true">#</a> 4. 进行快照时能修改数据吗？</h2><p><strong>在执行 RDB 快照时，如果数据还在频繁的变动，那肯定会影响快照的完整性</strong>，毕竟快照需要消耗挺长时间。</p><p>例如，在 t1 时刻执行内存快照，需要 10s 才能做完，在这 10s 内陆陆续续有数据刷入磁盘，而此过程中，比如 t1 + 3s 时刻某些数据发生了修改，即 <strong>t1 + 3s 相比与快照开始时刻 t1 来说，数据不同了</strong>，就会导致数据的不完整，因为 <strong>这些被修改的数据已经不是 t1 时刻的状态了</strong>。</p><p>所以，<strong>在执行快照期间，自快照开始时刻起，内存中的数据就不能被修改了</strong>。那这就意味着快照期间 Redis 不能处理写请求了吗？</p><p>很显然 Redis 不会这么做，因为 RDB 快照还是挺耗时的，如果不允许执行写请求，那将大大降低 Redis 的性能。</p>`,28),R={href:"https://code.0x3f4.run/backend/database/redis/durability/aof%E6%97%A5%E5%BF%97.html#_4-aof-%E5%90%8E%E5%8F%B0%E9%87%8D%E5%86%99",target:"_blank",rel:"noopener noreferrer"},b=a('<p>其实，这里采用的技术与 AOF 重写相同，都是 <strong>写时复制（Copy-On-Write，COW）技术</strong>。</p><p>具体来说，bgsave 执行时，主线程会 fork 出一个子进程，这个过程也是只会复制页表，通过页表达到共享内存的效果，bgsave 子进程此时就可以读取内存中的数据，写入 RDB 文件。<strong>当主线程发生写操作时，就发生了 COW，此时主线程会真正拷贝出一块物理内存，在这块新的物理内存上进行修改操作，而 bgsave 子进程读取的还是原来的内存，不会影响 RDB 的生成</strong>。</p><p>图示如下所示：</p><p><img src="https://run-notes.oss-cn-beijing.aliyuncs.com/notes/https%2Fstatic001.geekbang.org%2Fresource%2Fimage%2Fa2%2F58-2024_01_02-1704196568.jpeg" alt="img" loading="lazy"></p><p><strong>通过 COW，既保证了快照的完整性，也允许主线程对数据进行修改</strong>。</p><p>当然了，<strong>在快照过程中修改后的数据，是不在 RDB 文件中的</strong>，也就是说 <strong>会丢失最新数据</strong>。</p><h2 id="_5-rdb-和-aof-的优劣" tabindex="-1"><a class="header-anchor" href="#_5-rdb-和-aof-的优劣" aria-hidden="true">#</a> 5. RDB 和 AOF 的优劣</h2><p>学习完 RDB 后，可以发现 RDB 有自己的优势，当然也有劣势，下面就来看看 RDB 和 AOF 的优劣对比。</p><p>从 <strong>数据恢复的速度</strong> 上看：</p><ul><li><strong>RDB 快照</strong> 记录的是实际真实的 <strong>物理数据</strong>，恢复时可以直接读取到内存，速度速度 <strong>很快</strong>；</li><li><strong>AOF 日志</strong> 记录的是<strong>命令、逻辑日志</strong>，恢复时还需要执行命令，恢复速度 <strong>较慢</strong>。</li></ul><p>从 <strong>数据丢失情况</strong> 上看：</p><ul><li>RDB 快照丢失数据的情况 <strong>和快照的频率有关</strong>，执行快照的频率越快，丢失的数据就越少，但是频率并不好控制，频率太快也会导致写磁盘、fork 子进程带来的性能消耗；</li><li>AOF 日志提供了 <strong>三个刷盘时机参数</strong> 来平衡数据丢失和性能的平衡，当刷盘时机为 Always 时，基本不会出现丢失数据的情况。</li></ul><p>可以看出，<strong>RDB 快照的最大优势是恢复速度快，但快照的频率不好控制；AOF 快照的最大优势是丢失数据少，但恢复速度较慢</strong>。</p><p>那有什么方法既能利用 RDB 的快速恢复优势，又能以较小的开销做到尽量少丢数据呢？答案是 Yes，Redis 4.0 中提出的 <strong>混合持久化</strong> 就可以实现，我们下篇文章见。</p><h2 id="_6-参考文章" tabindex="-1"><a class="header-anchor" href="#_6-参考文章" aria-hidden="true">#</a> 6. 参考文章</h2><ul><li>《Redis 核心技术与实战》</li></ul>',16);function B(D,f){const r=o("router-link"),i=o("ExternalLinkIcon");return g(),d("div",null,[s("details",c,[u,s("nav",_,[s("ul",null,[s("li",null,[t(r,{to:"#_1-为什么需要-rdb-快照"},{default:e(()=>[n("1. 为什么需要 RDB 快照？")]),_:1})]),s("li",null,[t(r,{to:"#_2-什么是-rdb-快照"},{default:e(()=>[n("2. 什么是 RDB 快照？")]),_:1})]),s("li",null,[t(r,{to:"#_3-什么时候进行-rdb-快照"},{default:e(()=>[n("3. 什么时候进行 RDB 快照？")]),_:1})]),s("li",null,[t(r,{to:"#_4-进行快照时能修改数据吗"},{default:e(()=>[n("4. 进行快照时能修改数据吗？")]),_:1})]),s("li",null,[t(r,{to:"#_5-rdb-和-aof-的优劣"},{default:e(()=>[n("5. RDB 和 AOF 的优劣")]),_:1})]),s("li",null,[t(r,{to:"#_6-参考文章"},{default:e(()=>[n("6. 参考文章")]),_:1})])])])]),h,s("p",null,[n("看到这里，有没有觉得这个场景和 "),s("a",R,[n("AOF 重写"),t(i)]),n(" 时很像？AOF 重写也是需要根据当前时刻的数据，进行全量重写。那 AOF 重写时能进行写操作，执行 RDB 快照时为什么就不行？")]),b])}const F=l(p,[["render",B],["__file","rdb快照.html.vue"]]);export{F as default};
