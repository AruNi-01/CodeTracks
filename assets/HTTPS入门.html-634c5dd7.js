import{_ as i}from"./plugin-vue_export-helper-c27b6911.js";import{r as g,o as e,c as p,a as t,d as n,w as r,b as o,e as a}from"./app-8a94eb38.js";const c={},h={class:"hint-container details"},d=t("summary",null,"本文内容",-1),u={class:"table-of-contents"},T=a('<h2 id="_1-什么是-https" tabindex="-1"><a class="header-anchor" href="#_1-什么是-https" aria-hidden="true">#</a> <strong>1. 什么是 HTTPS</strong></h2><p>HTTPS 全称是 HTTP over SSL/TLS，也就是运行在 SSL/TLS 协议上的 HTTP。</p><p>HTTPS 在通信之前会先通过 SSL/TLS 加密，所以它是一个 <strong>安全协议</strong>。同时，它也是建立在 TCP/IP 只上的，所以也是一个 <strong>可靠传输协议</strong>。</p><p>所以 HTTPS 可以看成是 HTTP + SSL/TLS + TCP/IP。</p><p><img src="https://run-notes.oss-cn-beijing.aliyuncs.com/notes/202302212043697.png" alt="image-20230221204317677" loading="lazy"></p><h2 id="_2-http-有什么安全隐患" tabindex="-1"><a class="header-anchor" href="#_2-http-有什么安全隐患" aria-hidden="true">#</a> <strong>2. HTTP 有什么安全隐患</strong></h2><p><strong>HTTP</strong> 一个最大的缺陷，就是使用 <strong>明文传输</strong>，也就是你传输的消息能被中间人一五一十的看见。所以 HTTPS 为了解决 HTTP 不安全的缺陷，引入了 <strong>SSL/TLS 协议</strong>，使得消息能够 <strong>加密传输</strong>。</p><p>那么，HTTP 使用明文传输会有哪些安全隐患呢？只有知道了这些隐患，HTTPS 才能 “对症下药”。</p><p>HTTP 由于是明文传输，所以会存在下面几个问题：</p><ul><li>数据被 <strong>窃听</strong>，即不具有 <strong>机密性</strong>；</li><li>数据被 <strong>篡改</strong>，即不具有 <strong>完整性</strong>；</li><li>数据被 <strong>冒充</strong>，即不具有 <strong>身份认证</strong>；</li></ul><p>下面就来看看，HTTPS 是如何 “对症下药” 的。</p><h2 id="插曲-加密小知识" tabindex="-1"><a class="header-anchor" href="#插曲-加密小知识" aria-hidden="true">#</a> <strong>&gt; 插曲：加密小知识</strong></h2><p>在真正讲解 HTTPS 之前，要先知道一些加密的小知识。</p><p><strong>加密</strong> 分为 <strong>对称加密</strong> 和 <strong>非对称加密</strong>，它们的区别如下：</p><ul><li>对称加密：加密解密都使用 <strong>一个密钥</strong>；</li><li>非对称加密：有 <strong>两个密钥</strong>（公钥和私钥），<strong>公钥可以随意发放，私钥必须由本人保管</strong>。而且 <strong>这两个密钥可以双向加解密</strong>。</li></ul><p>对称加密和非对称加密各自的优缺点：</p><ul><li><strong>对称加密</strong> 只使用一个密钥，所以 <strong>运算速度快</strong>，密钥必须保密，但是又 <strong>无法做到安全的交换密钥</strong>；</li><li><strong>非对称加密</strong> 使用两个密钥，所以 <strong>运算速度慢</strong>，公钥可以随意发放而私钥必须保密，所以 <strong>避免了密钥交换问题</strong>。</li></ul><p>对称加密没什么好说的，就是普通的加密，比如，你和你女朋友面对面建群，你发起群聊时需要创建一个密码，然后你把这个密码告诉你女朋友，这样你们就可以进入同一个群聊暧昧了。</p><p>非对称加密就有意思了，它有两个密钥，而且这两个密钥是可以双向加解密的。因此根据加解密流程的不同，其目的也不一样：</p><ul><li><strong>公钥加密，私钥解密</strong>：目的是为了 <strong>保证数据传输的机密性</strong>。因为被公钥加密的数据，其他人是无法解开的，只有持有私钥的人，才能解密得出实际的数据；</li><li><strong>私钥加密，公钥解密</strong>：目的是为了 <strong>防止数据是被冒充的</strong>。因为私钥是不可泄漏的，如果公钥能解密出私钥加密后的数据，就说明该数据是来自持有私钥的人发送的。</li></ul><p>其实，还有一种加密方式，叫做 <strong>混合加密</strong>，只不过是 <strong>将对称加密和非对称加密结合起来使用</strong>。</p><p>至于为什么要出现混合加密方式，因为对称加密和非对称加密都有缺点，而混合加密就是为了避免这些缺点的。具体的使用场景后面会讲到。</p><h2 id="_3-https-如何解决安全隐患" tabindex="-1"><a class="header-anchor" href="#_3-https-如何解决安全隐患" aria-hidden="true">#</a> <strong>3. HTTPS 如何解决安全隐患</strong></h2><h3 id="_3-1-摘要算法—仿篡改-完整性" tabindex="-1"><a class="header-anchor" href="#_3-1-摘要算法—仿篡改-完整性" aria-hidden="true">#</a> <strong>3.1 摘要算法—仿篡改 (完整性)</strong></h3><blockquote><p>我们先不讲解如何仿窃听，因为当解决了篡改和冒充风险时，窃听自然而然就解决了。</p></blockquote><p>SSL/TLS 通过 <strong>摘要算法</strong> 来实现 <strong>完整性</strong>，它能为数据生成独一无二的 “摘要” 字符串，我们通常称之为「<strong>指纹</strong>」。</p><p>为了保证数据不被篡改，摘要算法的实现如下：</p><ul><li><p>发送时先对数据计算出一个「指纹」，然后将这个「指纹」和数据一起传输给对方。</p><blockquote><p>注：<strong>对数据计算出来的「指纹」是无法反推出数据的</strong>。</p></blockquote></li><li><p>对方收到数据和「指纹」后，会先对数据进行同样的计算，得出另一个「指纹」，然后将这两个「指纹」进行对比，如果相同，则说明数据没有被篡改，否则数据就被篡改过了。</p></li></ul><p>上面的过程如下图所示：</p><p><img src="https://run-notes.oss-cn-beijing.aliyuncs.com/notes/202302212115998.png" alt="image-20230221211516134" loading="lazy"></p><p>实际上，<strong>摘要算法就是一个哈希函数</strong>，所以上面的「<strong>计算</strong>」是「<strong>哈希运算</strong>」，「<strong>指纹</strong>」是「<strong>哈希值</strong>」。所以实际上的过程图如下：</p><p><img src="https://run-notes.oss-cn-beijing.aliyuncs.com/notes/202302212228249.png" alt="image-20230221222758287" loading="lazy"></p><blockquote><p>注：<strong>哈希函数是通信双方提前协商好的</strong>。</p></blockquote><p>所以，<strong>用哈希函数对数据进行哈希运算（摘要算法）得到一个哈希值，然后将这个哈希值和数据一起发送，就能保证数据的完整性，也就是没有被篡改过</strong>。如果被篡改，那么第三步计算出来的哈希值就与原来的哈希值不匹配。</p><div class="hint-container danger"><p class="hint-container-title">两个问题：</p><p>通过摘要算法可以保证数据不被篡改，但是并不能保证「数据 + 哈希值」不会被中间人替换（冒充发送一个假的），因为 <strong>缺少了对数据发送方的证伪</strong>。</p><p>而且 <strong>哈希函数在协商的时候，怎么保证不会被中间人窃听到呢</strong>？</p><p>请带着这两个问题，继续往下看。</p></div><h3 id="_3-2-数字签名—仿冒充-身份认证" tabindex="-1"><a class="header-anchor" href="#_3-2-数字签名—仿冒充-身份认证" aria-hidden="true">#</a> <strong>3.2 数字签名—仿冒充 (身份认证)</strong></h3><p>上面通过摘要算法，解决了数据被篡改的问题，但是没有解决数据被冒充的的问题，因为缺少对数据来源的证伪。</p><p>提到这个冒充问题，不知道你有没有想起上面的小插曲，在 <strong>非对称加密</strong> 中，如果加解密流程是「<strong>私钥加密，公钥解密</strong>」，那么就能 <strong>保证数据的来源是可靠的</strong>。</p><p>私钥一般是服务端持有的，所以下面假设发送数据的一方是服务端，接受数据的一方是客户端。我们尝试对上面的摘要算法进行改进：</p><ul><li><p>服务端发送的数据在通过哈希运算得出哈希值 A 时，不直接把这个哈希值 A 发送出去，而是 <strong>先对它进行私钥加密</strong>，加密后的密文就称为「<strong>数字签名</strong>」，然后将「<strong>数字签名 + 数据</strong>」一起发送出去。</p><blockquote><p><strong>因为非对称加密效率太低，所以只对数据的哈希值加密的话，运算量小很多，得到的数字签名也很小，方便保管和传输</strong>。</p></blockquote></li><li><p>客户端收到「<strong>数字签名 + 数据</strong>」后，会对数据做哈希运算得出哈希值 B，然后 <strong>使用公钥（公钥会提前发放）对数字签名解密</strong>，得到哈希值 A，最后将两个哈希值进行对比。</p></li></ul><p>过程如下：</p><p><img src="https://run-notes.oss-cn-beijing.aliyuncs.com/notes/202302212304160.png" alt="image-20230221230404031" loading="lazy"></p><p>由于 <strong>私钥是服务端独有的</strong>，所以如果客户端使用公钥解密出来的哈希值 A 与哈希函数计算出来的哈希值 B 相同，则可以保证「数据 + 数字签名」是服务端发送的。</p><p>所以，通过「数字签名」，也就是非对称加密，解决了「数据 + 哈希值」被冒充的问题。</p><h3 id="_3-3-ca-数字证书—仿冒充-身份认证" tabindex="-1"><a class="header-anchor" href="#_3-3-ca-数字证书—仿冒充-身份认证" aria-hidden="true">#</a> <strong>3.3 CA + 数字证书—仿冒充 (身份认证)</strong></h3><p>但是，冒充的问题真的全都解决了吗？</p><p>我们确实可以保证「数据 + 数字签名」不会被冒充，不过这个公钥能保证是来自 <strong>正确的发送方</strong> 吗？</p><p>可能你会说，我能用公钥解密得到正确的哈希值啊，怎么不能保证这个公钥是发送方的？？</p><p>是，确实能保证公钥是发送方的，但是这个发送方如果是其他人呢？因为我们并 <strong>没有验证公钥的真伪</strong>。</p><p>所以还可能存在这样一种场景，有一个中间人，他也有自己的一对公私钥，通信过程是下面这样的：</p><ul><li>中间人将服务端的真公钥和哈希函数拦截，然后替换成假公钥和假哈希函数发送给客户端；</li><li>接着中间人使用自己的私钥做数字签名，发送给客户端；</li><li>客户端收到后，用自己的假公钥（中间人的）进行解密，得到假的数据。</li></ul><p>正是因为没有对收到的公钥和哈希函数做身份校验，所以导致上面的情况发生。</p><p>为了解决上面的问题，就需要引入一个 <strong>权威的机构 CA</strong>（数字证书认证机构）。</p><p><strong>服务端可以先将公钥注册到 CA，CA 会用他的私钥对此公钥做个「数字签名」，然后将服务端的「个人信息 + 公钥 + 数字签名」打包成一个数字证书，返回给服务端</strong>。</p><p><strong>那么当客户端发起请求时，服务端会先把这个数字证书返回给客户端，客户端再使用 CA 的公钥校验数字证书的真伪（数字证书中的数字签名是用 CA 的私钥做的，所以 CA 的公钥能解密），如果是真的，就说明此数字证书是在 CA 注册过的，即合法的，那么就可以保证数字证书里的公钥是来自服务端的</strong>。</p><blockquote><p>注：<strong>CA 的公钥是提前置入到客户端的浏览器或操作系统里</strong>。</p></blockquote><p>提前工作如下图：</p><p><img src="https://run-notes.oss-cn-beijing.aliyuncs.com/notes/202302221107883.png" alt="image-20230222091419334" loading="lazy"></p><p>公钥验证流程如下：</p><p><img src="https://run-notes.oss-cn-beijing.aliyuncs.com/notes/202302221109836.png" alt="image-20230222092931139" loading="lazy"></p><p>所以，这个权威机构 CA 会先对服务器的公钥进行加密，放入数字证书中，那么只要数字证书是可信的，里面的公钥就是可信的。通过 CA 可以保证服务端的身份，解决了冒充问题。</p><p>既然公钥冒充的问题解决了，那么后面就可以 <strong>通过服务端的这对公私钥进行加密通信</strong>，自然而然就解决了数据被窃听的风险（机密性），那么哈希函数自然也能加密协商。</p><p>所以通过 <strong>CA</strong> 和 <strong>数字证书</strong>，解决了上面的所提出的两个问题。同时，利用非对称加密（服务端的公私钥）来进行通信，解决了窃听风险。所以当解决了篡改和冒充风险时，窃听自然而然就解决了。</p><h2 id="_4-https-连接的建立" tabindex="-1"><a class="header-anchor" href="#_4-https-连接的建立" aria-hidden="true">#</a> <strong>4. HTTPS 连接的建立</strong></h2><p>通过上面的「摘要算法 + 数字签名 + CA 的数字证书」解决了 HTTP 的三大安全问题，但是，后面的 <strong>数据传输过程需要使用非对称加密来进行</strong>。</p><p>通过前面的小插曲可以知道，<strong>非对称加密算法非常慢</strong>，因为它涉及到两个钥匙的加解密，是十分复杂的。<strong>如果每次传输数据都要进行这么复杂的加解密，那传输效率也太低了</strong>。</p><p>那 HTTPS 是怎么做的呢？我们可以通过「摘要算法 + 数字签名 + CA 的数字证书」来进行加密通信，那么可不可以 <strong>利用这个加密通信来生成一个</strong>「<strong>会话密钥</strong>」呢？因为 <strong>加密通信能保证「会话密钥」是只有通信双方才知道的</strong>。生成之后，<strong>后面的数据传输就不用非对称加密来进行了，而是使用这个「会话密钥」，会话密钥双方是一样的，也就是对称加密，效率是比较高的</strong>。</p><p>其实，HTTPS 就采用了上面的思路，<strong>先通过非对称加密协商出一个「会话密钥」，之后的数据传输就使用这个「会话密钥」对称加密传输</strong>。</p><p>这也就是我们上面讲到的 <strong>混合加密</strong>，使用到了 HTTPS 通信的场景中。</p><p>下面，我们就来看看 HTTPS 从连接的建立到数据的传输流程是怎样的。</p><p>连接的建立主要是通过 SSL/TLS 协议完成的，主要的流程如下：</p><ol><li>客户端向服务器索要数字证书，并验证其真伪，取出服务器的公钥；</li><li>双方协商出「会话密钥」；</li><li>双方采用「会话密钥」进行加密通信。</li></ol><p>先来看看比较简单的基于 RSA 算法的 TLS 握手，握手分为四次，如下所示：</p><p><img src="https://run-notes.oss-cn-beijing.aliyuncs.com/notes/202302221109091.jpeg" alt="HTTPS 连接建立过程" loading="lazy">详细流程如下：</p><div class="hint-container info"><p class="hint-container-title">1. ClientHello</p><p>首先，客户端向服务端发起加密通信请求 ClientHello，请求中主要有：</p><ul><li>客户端支持的 TLS 版本号；</li><li><strong>客户端产生的随机数（Client Random），后面用于生成「会话密钥」的条件之一</strong>；</li><li>客户端支持的密码套件列表，如 RAS 加密算法。</li></ul></div><div class="hint-container info"><p class="hint-container-title">2. ServerHello</p><p>服务端收到请求后，会向客户端发起响应 ServerHello，响应中主要有：</p><ul><li>确认 TLS 版本号，如果流程器不支持，则关闭加密通信；</li><li><strong>服务器产生的随机数（Server Random），后面用于生成「会话密钥」的条件之一</strong>；</li><li>确认使用的密码套件列表；</li><li><strong>服务端的数字证书</strong>。</li></ul></div><div class="hint-container info"><p class="hint-container-title">3. 客户端回应</p><p>客户端收到服务端的响应后，<strong>会先通过浏览器或操作系统中的 CA 公钥，对服务端的数字证书进行校验</strong>。</p><p>如果数字证书没问题，客户端就会取出里面的公钥（服务端的），使用此公钥对报文进行加密，报文中的内容如下：</p><ul><li><p>一<strong>个随机数（pre-master key），这个随机数会使用服务端的公钥加密，这个随机数是生成「会话密钥」的条件指一</strong>；</p><blockquote><p>此时客户端就拥有了 <strong>三个随机数</strong>：Client Ranom + Server Random + pre-master key。然后计算出「<strong>会话密钥</strong>」。</p></blockquote></li><li><p>通知服务端，<strong>之后使用这个「会话密钥」进行通信</strong>；</p></li><li><p>所有握手数据的一个摘要，供服务端校验。</p></li></ul></div><div class="hint-container info"><p class="hint-container-title">4. 服务端最后的回应</p><p><strong>服务端收到客户端的报文后，会用自己的私钥解密，获取第三个随机数 pre-master key，然后同样计算出「会话密钥」，至此，服务端的密钥也生成了</strong>。</p><p>接着服务端会发送最后的消息：</p><ul><li>通知客户端，<strong>之后也使用这个「会话密钥」进行通信</strong>；</li><li>同样把所有的握手数据做个摘要，供客户端校验。</li></ul></div><p>自此，基于 RSA 算法的 TLS 握手过程就结束了，<strong>双方都拥有了同样的「会话密钥」，之后的数据通信都是使用这个对称的「会话密钥」进行加解密</strong>，也就是完全使用普通的 HTTP 协议。</p><div class="hint-container danger"><p class="hint-container-title">基于 RSA 算法的 TLS 握手的缺陷：</p><p><strong>RSA 算法是不支持前向保密的</strong>。</p><p>因为最后一个随机数是使用公钥加密，然后服务端使用私钥解密。<strong>如果服务端的私钥一旦泄漏，那么之前被第三方所截获的所有秘密报文都会被破解</strong>。</p><p>因为第三方可以根据服务端的私钥获取到最后一个随机数，进而生成这个「会话密钥」。</p><p>为了解决这个问题，后面出现了 ECDHE 算法，现在的 TLS 握手基本上都是使用的 ECDHE 算法。由于文章篇幅原因，ECDHE 算法的 TLS 握手后续再讲解。</p></div><h2 id="_5-参考文章" tabindex="-1"><a class="header-anchor" href="#_5-参考文章" aria-hidden="true">#</a> <strong>5. 参考文章</strong></h2>',81),_={href:"https://xiaolincoding.com",target:"_blank",rel:"noopener noreferrer"},S={href:"https://mp.weixin.qq.com/s/JVQPy8hAVoq1pRq63HKBOw",target:"_blank",rel:"noopener noreferrer"};function m(H,P){const s=g("router-link"),l=g("ExternalLinkIcon");return e(),p("div",null,[t("details",h,[d,t("nav",u,[t("ul",null,[t("li",null,[n(s,{to:"#_1-什么是-https"},{default:r(()=>[o("1. 什么是 HTTPS")]),_:1})]),t("li",null,[n(s,{to:"#_2-http-有什么安全隐患"},{default:r(()=>[o("2. HTTP 有什么安全隐患")]),_:1})]),t("li",null,[n(s,{to:"#插曲-加密小知识"},{default:r(()=>[o("> 插曲：加密小知识")]),_:1})]),t("li",null,[n(s,{to:"#_3-https-如何解决安全隐患"},{default:r(()=>[o("3. HTTPS 如何解决安全隐患")]),_:1}),t("ul",null,[t("li",null,[n(s,{to:"#_3-1-摘要算法—仿篡改-完整性"},{default:r(()=>[o("3.1 摘要算法—仿篡改 (完整性)")]),_:1})]),t("li",null,[n(s,{to:"#_3-2-数字签名—仿冒充-身份认证"},{default:r(()=>[o("3.2 数字签名—仿冒充 (身份认证)")]),_:1})]),t("li",null,[n(s,{to:"#_3-3-ca-数字证书—仿冒充-身份认证"},{default:r(()=>[o("3.3 CA + 数字证书—仿冒充 (身份认证)")]),_:1})])])]),t("li",null,[n(s,{to:"#_4-https-连接的建立"},{default:r(()=>[o("4. HTTPS 连接的建立")]),_:1})]),t("li",null,[n(s,{to:"#_5-参考文章"},{default:r(()=>[o("5. 参考文章")]),_:1})])])])]),T,t("ul",null,[t("li",null,[t("a",_,[o("小林 coding"),n(l)])]),t("li",null,[t("a",S,[o("腾讯技术工程：了解 HTTP 看这一篇就够"),n(l)])])])])}const C=i(c,[["render",m],["__file","HTTPS入门.html.vue"]]);export{C as default};
