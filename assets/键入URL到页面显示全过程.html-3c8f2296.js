import{_ as l}from"./plugin-vue_export-helper-c27b6911.js";import{r,o as c,c as p,a as o,d as t,w as s,b as n,e as a}from"./app-80dc18e4.js";const d={},g={class:"hint-container details"},h=o("summary",null,"本文内容",-1),u={class:"table-of-contents"},_=a('<div class="hint-container info"><p class="hint-container-title">前言</p><p>我们经常在浏览器的地址栏输入某个网站的网址，然后按下回车键，对应的页面就会呈现出来。那么你知道这中间都经历了什么吗？</p><p>先看一个简单的请求过程，过程中只涉及数据包在各个层级上的格式：</p><p><img src="https://run-notes.oss-cn-beijing.aliyuncs.com/notes/202203251802249.png" alt="" loading="lazy"></p><p>请求报文在经过各层时都会由不同的协议进行处理，下面就基于这些协议（和设备），来探究一个数据包的发送会经历些什么。</p></div><h2 id="_1-http" tabindex="-1"><a class="header-anchor" href="#_1-http" aria-hidden="true">#</a> 1. HTTP</h2><p>首先，浏览器会 <strong>解析 URL</strong>，从中获取我们要请求的目标服务器和需要请求的资源文件，然后 <strong>构建 HTTP 请求</strong>。</p><p>HTTP 请求报文由三部分组成，分别是 <strong>请求行、请求头和请求体</strong>：</p><ul><li>请求行：包含请求方法、请求资源文件的 URL 地址（不含域名）、使用的协议和版本号；</li><li>请求头：包含若干属性，格式为 <code>属性名：属性值</code>，常见的属性包括接收的数据格式/编码/语言、目标服务器的域名、缓存控制、Cookie 等。</li><li>请求体：请求的内容。</li></ul>',5),P={href:"https://aruni.me/studynotes/cs/network/http/HTTP%E5%85%A5%E9%97%A8.html#_4-http-%E6%8A%A5%E6%96%87%E6%A0%BC%E5%BC%8F",target:"_blank",rel:"noopener noreferrer"},m=a('<p><img src="https://run-notes.oss-cn-beijing.aliyuncs.com/notes/202303041412642.png" alt="image-20230304141204392" loading="lazy"></p><h2 id="_2-dns" tabindex="-1"><a class="header-anchor" href="#_2-dns" aria-hidden="true">#</a> 2. DNS</h2><p>浏览器解析 URL 生成 HTTP 请求报文后，报文中只有目标服务器的域名，所以接下来需要 <strong>对域名进行解析，得到 IP 地址</strong>。</p><p>而域名解析的工作，就是由 <strong>DNS 服务器</strong> 完成的，它保存了服务器域名与 IP 地址的对应关系。</p><h3 id="_2-1-域名的层级关系" tabindex="-1"><a class="header-anchor" href="#_2-1-域名的层级关系" aria-hidden="true">#</a> 2.1 域名的层级关系</h3><p>DNS 中的域名使用点 <code>.</code> 来分割，比如 <code>www.server.com</code>。<strong>越靠右</strong> 域名的 <strong>层级越高</strong>。</p><p>实际上域名最后还有个点，这个最后的点标识根域名，像这样 <code>www.server.com.</code>。</p><p>所以上面的最高层级是根域 <code>.</code>，下一层是顶级域名 <code>.com</code>，再下一层是二级域名 <code>server.com</code>。类似与下面这样的树形结构：</p><p><img src="https://run-notes.oss-cn-beijing.aliyuncs.com/notes/202303041418718.png" alt="image-20230304141833571" loading="lazy"></p><p>可以发现，通过根域的 DNS 服务器就可以把所有互联网中所有的 DNS 服务器串联起来了。</p><p>所以客户端只需要从任意一台 DNS 服务器开始向上寻找到根 DNS 服务器，再向下就可以寻找到任意一台 DNS 服务器。</p><h3 id="_2-2-域名解析流程" tabindex="-1"><a class="header-anchor" href="#_2-2-域名解析流程" aria-hidden="true">#</a> 2.2 域名解析流程</h3><p>其实，客户端在查询一个域名对应的 IP 地址时，不一定非要先从上寻找到根 DNS 服务器，再往下寻找目标 DNS 服务器进行域名解析，因为域名对应 IP 地址的信息会有 <strong>缓存</strong>。</p><p>假设客户端要查询 <code>www.baidu.com</code> 的 IP 地址，查询过程如下：</p><ol><li><p>在 <strong>浏览器缓存</strong> 中查询；</p></li><li><p>在 <strong>操作系统缓存（hosts 文件）中查询</strong>；</p><blockquote><p>Linux 在 <code>/etc/hosts</code> 文件，Windows 在 <code>C:\\Windows\\System32\\drivers\\etc\\hosts</code> 文件。</p></blockquote></li><li><p>客户端向 <strong>本地 DNS 服务器</strong> 发起 DNS 解析请求。如果本地 DNS 服务器没有，则会向根 DNS 服务器发起请求，询问 <code>www.baidu.com</code> 的 IP 地址是什么；</p></li><li><p><strong>根 DNS 服务器</strong> 收到请求后，发现顶级域名是 <code>.com</code>，则会告诉本地 DNS 服务器，你要查找的域名在 <code>.com</code> 域名服务器上，返回 <code>.com</code> 域名服务器的地址；</p></li><li><p>本地 DNS 服务器收到 <code>.com</code> 域名服务器的地址后，就去问 <code>.com</code> 服务器；</p></li><li><p><strong><code>.com</code></strong> 域名服务器收到请求后，就会返回 <code>baidu.com</code> 域名服务器的地址；</p><blockquote><p><code>baidu.com</code> 所属的域名服务器也称作权威 DNS 服务器，因为这个域名属于该服务器。</p></blockquote></li><li><p>本地 DNS 服务器收到后，就去 <strong><code>baidu.com</code> 权威域名服务器</strong> 询问；</p></li><li><p>权威域名服务器查询后，就会将对应的 IP 地址 <strong>返回给本地 DNS 服务器</strong>；</p></li><li><p>本地 DNS 服务器将最后的结果 <strong>返回给客户端</strong>。</p></li></ol><p>整体的解析过程如下：</p><p><img src="https://run-notes.oss-cn-beijing.aliyuncs.com/notes/202303041602648.png" alt="image-20230304160223341" loading="lazy"></p><p>可以发现，在本地 DNS 服务器去查找时，其他域名服务器不会告诉它具体的结果，只会告诉它应该去哪儿找。</p><blockquote><p>DNS 请求过程一般使用 UDP 协议，因为 DNS 请求过程就是一问一答，符合 UDP 的请求方式，而且开销也小（使用 TCP 只为了请求一条信息，太浪费了）。</p></blockquote><h2 id="_3-tcp" tabindex="-1"><a class="header-anchor" href="#_3-tcp" aria-hidden="true">#</a> 3. TCP</h2><p>HTTP 是基于 TCP 协议传输的，所以通信之前需要先 <strong>通过三次握手建立 TCP 连接</strong>。</p><p>HTTP 报文可能会非常大，为了合理控制传输效率，当数据包大小 <strong>超过 MSS</strong>（Maximum Segment Size，最大报文段长度）时，就需要将数据包 <strong>分块传输</strong>。这样即使传输过程有一个分块丢失了，也只需要重传这一个，大大提高了传输效率。</p><p>拆分完成后，<strong>在每块数据块的首部添加 TCP 头部</strong>，形成 <strong>TCP 报文</strong>，然后交给 IP 模块来发送数据。</p><div class="hint-container info"><p class="hint-container-title">TCP 报文的内容</p><p>TCP 头部会存放 <strong>源端口号，目的端口号</strong> 以及 TCP 相关的字段，TCP 报文的数据部分存放的就是 HTTP 报文。如下图所示：</p><p><img src="https://run-notes.oss-cn-beijing.aliyuncs.com/notes/202303041624530.png" alt="image-20230304162406226" loading="lazy"></p></div><h2 id="_4-ip" tabindex="-1"><a class="header-anchor" href="#_4-ip" aria-hidden="true">#</a> 4. IP</h2><p>IP 模块会将数据块封装成网络包，IP 协议会将 TCP报文作为数据，再加上 IP 头部，封装成 <strong>IP 报文</strong>。如果 IP 报文大小 <strong>超过 MTU</strong>（Maximum Transmission Unit，最大传输单元），就会再次进行 <strong>分片</strong>。</p><div class="hint-container info"><p class="hint-container-title">IP 报文的主要内容</p><p>IP 头部会存放 <strong>源 IP 地址，目的 IP 地址</strong> 以及 IP 相关的字段，IP 报文的数据部分存放的就是 TCP 报文。如下图所示：</p><p><img src="https://run-notes.oss-cn-beijing.aliyuncs.com/notes/202303041629036.jpeg" alt="" loading="lazy"></p></div><h2 id="_5-mac" tabindex="-1"><a class="header-anchor" href="#_5-mac" aria-hidden="true">#</a> 5. MAC</h2><p>接下来，需要在 IP 报文头部加上 MAC 头部，生成 <strong>MAC 报文</strong>。MAC 头部含有源 MAC 地址和目的 MAC 地址。</p><p>发送方的 MAC 地址就在网卡里，读出来就行了，<strong>接收方的 MAC 地址需要使用 ARP 协议获取</strong><br> （ARP 也有缓存，缓存中查不到就会以广播的形式询问某个 IP 地址的 MAC 地址）。</p><p>至此，一个完整的请求报文就生成完毕了，要开始在网络中传输了。</p><p><img src="https://run-notes.oss-cn-beijing.aliyuncs.com/notes/202303041637200.jpeg" alt="" loading="lazy"></p><div class="hint-container tip"><p class="hint-container-title">为什么需要 MAC 地址？</p></div><p>在 IP 头部中有目的地的 IP 地址，通过 IP 地址可以判断数据包要发往哪儿，但是 <strong>在以太网中，这个思路是行不通的</strong>。</p><div class="hint-container info"><p class="hint-container-title">以太网</p><p>以太网就是一种在「局域网」内，把附近的设备连接起来，使它们之间可以进行通讯的技术。</p><p>例如，电脑上的以太网接口、以太网交换机、路由器的以太网口，网线等，都是以太网的组成部分。</p></div><p><strong>以太网在判断数据包的目的地时，和 IP 的方式不同</strong>，因此必须采用相匹配的方式才能在以太网中将数据包发往目的地，而这个方式，就是 <strong>MAC 地址</strong>。</p><p>MAC 头部是以太网使用的头部，它包含了接收方和发送方的 MAC 地址等信息，可以通过 <strong>ARP 协议 获取对方的 MAC 地址</strong>。</p><p>也就是说，需要使用 MAC 地址才能标识网络上的设备，才知道具体发往哪个地方。<strong>每台设备的 MAC 地址是唯一的，而 IP 地址不唯一</strong>（每个局域网内的 IP 地址才唯一）。</p><blockquote><p>举个公司的例子，把 IP 地址比喻成工号，公司可以回收或者给别人用，或者在不不同的子公司也可以存在完全一样的工号。</p><p>有的公司员工离职后再回来，工号重新编。有的公司工号是永久编号，你离职了这个工号就空着，你回来了这个工号还是你的。所以完全看分配的策略，规则比较灵活。</p><p>而 Mac 就是一个设备一个编号号，规则不灵活，类似你的身份证号，你出生就有了，一生不变。</p></blockquote><h2 id="_6-网卡" tabindex="-1"><a class="header-anchor" href="#_6-网卡" aria-hidden="true">#</a> 6. 网卡</h2><p><strong>网卡会在报文前面加上报头和起始帧分界符，使报文成为帧，能够在网络中传输</strong>。</p><p><img src="https://run-notes.oss-cn-beijing.aliyuncs.com/notes/202303041637139.png" alt="" loading="lazy"></p><p>最后网卡会将包转为电信号，通过网线发送出去。</p><h2 id="_7-交换机" tabindex="-1"><a class="header-anchor" href="#_7-交换机" aria-hidden="true">#</a> 7. 交换机</h2><p>交换机工作在 MAC 层，它将网络包 <strong>原样</strong> 转发到目的地。</p><p><strong>交换机会根据 MAC 地址表查找目的 MAC 地址，然后将报文发送到相应的端口</strong>。</p><p><img src="https://run-notes.oss-cn-beijing.aliyuncs.com/notes/202303041642396.jpeg" alt="" loading="lazy"></p><p>举个例子，如果收到的包的目的 MAC 地址为 <code>00-02-B3-1C-9C-F9</code>，则与图中表中的第 3 行匹配，根据端口列的信息，可知这个地址位于 <code>3</code> 号端口上，然后就可以通过交换电路将包发送到相应的端口了。</p><h2 id="_8-路由器" tabindex="-1"><a class="header-anchor" href="#_8-路由器" aria-hidden="true">#</a> 8. 路由器</h2><p>网络包经过交换机后，会到达路由器，然后会将网络包转发到下一个路由器或者目标设备。</p><p>路由器的转发和交换机类似，也是通过查表判断包转发的目的地。</p><p>不过在具体的操作过程上，路由器和交换机是有区别的。</p><ul><li>因为 <strong>路由器</strong> 是基于 IP 设计的，俗称 <strong>三层</strong> 网络设备，路由器的各个 <strong>端口</strong> 都具有 MAC 和 IP 地址；</li><li>而 <strong>交换机</strong> 是基于以太网设计的，俗称 <strong>二层</strong> 网络设备，交换机的 <strong>端口</strong> 不具有 MAC 和 IP 地址。</li></ul><div class="hint-container info"><p class="hint-container-title">路由器的收、转、发：</p><ul><li><p><strong>收</strong>：路由器收到网络包后，会 <strong>检查目的 MAC 地址是否与自己端口的对应</strong>（路由器的端口具有 MAC 地址），是则接收；</p></li><li><p><strong>转</strong>：接收完后，路由器就会 <strong>去掉 MAC 头部</strong>，然后 <strong>根据 IP 地址和路由表进行包的转发</strong>；</p></li><li><p><strong>发</strong>：经过查表后，知道了目标的 IP 地址，然后使用 <strong>ARP 协议</strong>（路由器也有 ARP 缓存）查询对应的 MAC 地址，然后将网络包 <strong>再封装成 MAC 报文</strong>（添加 MAC 头部），最后通过端口发送出去。</p></li></ul></div><p>发送出去的网络包会通过 <strong>交换机</strong> 到达下一个路由器。由于接收方 MAC 地址就是下一个路由器的地址，所以交换机会根据这一地址将包传输到下一个路由器。</p><p>接下来，下一个路由器会将包转发给再下一个路由器，经过层层转发之后，网络包就到达了最终的目的地。</p><div class="hint-container danger"><p class="hint-container-title">在这个过程中，源 IP 和目标 IP 始终是不会变的，一直变化的是 MAC 地址，因为需要 MAC 地址在以太网内进行 两个设备 之间的包传输。</p></div><h2 id="_9-服务端" tabindex="-1"><a class="header-anchor" href="#_9-服务端" aria-hidden="true">#</a> 9. 服务端</h2><p>数据包到了服务器后，由于发送时经过了层层封装，此时的数据包已经裹得很严实了，所以服务器会将这些头部信息依次扒开，最后取得真正的数据包。整体过程如下：</p><p><img src="https://run-notes.oss-cn-beijing.aliyuncs.com/notes/202203251802249.png" alt="" loading="lazy"></p><p>服务器在扒数据包的时候，会边扒边判断：</p><ul><li>先扒开 MAC 头部，判断目的 MAC 地址是否和服务器的相对于；</li><li>接着扒开 IP 头部，判断 IP 地址是否对应，同时 IP 头部还有协议项，指示使用了 TCP 协议；</li><li>再扒开 TCP 头部，判断端口号属于哪个进程，同时还要看序列号是否是自己期望的，是则回复一个 ACK 应答信息；</li></ul><p>服务器判断出该端口号属于 HTTP 进程，然后就把这个数据包发送给 HTTP 进程；</p><p>HTTP 进程发现是要要求一个页面，则会把这个页面也封装成一个 HTTP 响应报文。</p><p>这个响应报文也会经历之前的步骤，最终到达客户端，经过浏览器的渲染，最终页面就被显示了出来。</p><p>最后客户端要离开的时候，会向服务器发起 TCP 四次挥手，以断开连接。</p><blockquote><p>一个小小的数据包，竟要经历如此坎坷才能到达目的地，不禁感叹我要经历些什么，才能到达我的目的地。。。</p></blockquote><h2 id="_10-参考文章" tabindex="-1"><a class="header-anchor" href="#_10-参考文章" aria-hidden="true">#</a> 10. 参考文章</h2>',68),C={href:"https://xiaolincoding.com",target:"_blank",rel:"noopener noreferrer"},b={href:"https://www.bilibili.com/video/BV1c4411d7jb/?spm_id_from=333.337.search-card.all.click&vd_source=2716833caf2bf21200544dca2cc25e03",target:"_blank",rel:"noopener noreferrer"};function f(T,A){const e=r("router-link"),i=r("ExternalLinkIcon");return c(),p("div",null,[o("details",g,[h,o("nav",u,[o("ul",null,[o("li",null,[t(e,{to:"#_1-http"},{default:s(()=>[n("1. HTTP")]),_:1})]),o("li",null,[t(e,{to:"#_2-dns"},{default:s(()=>[n("2. DNS")]),_:1}),o("ul",null,[o("li",null,[t(e,{to:"#_2-1-域名的层级关系"},{default:s(()=>[n("2.1 域名的层级关系")]),_:1})]),o("li",null,[t(e,{to:"#_2-2-域名解析流程"},{default:s(()=>[n("2.2 域名解析流程")]),_:1})])])]),o("li",null,[t(e,{to:"#_3-tcp"},{default:s(()=>[n("3. TCP")]),_:1})]),o("li",null,[t(e,{to:"#_4-ip"},{default:s(()=>[n("4. IP")]),_:1})]),o("li",null,[t(e,{to:"#_5-mac"},{default:s(()=>[n("5. MAC")]),_:1})]),o("li",null,[t(e,{to:"#_6-网卡"},{default:s(()=>[n("6. 网卡")]),_:1})]),o("li",null,[t(e,{to:"#_7-交换机"},{default:s(()=>[n("7. 交换机")]),_:1})]),o("li",null,[t(e,{to:"#_8-路由器"},{default:s(()=>[n("8. 路由器")]),_:1})]),o("li",null,[t(e,{to:"#_9-服务端"},{default:s(()=>[n("9. 服务端")]),_:1})]),o("li",null,[t(e,{to:"#_10-参考文章"},{default:s(()=>[n("10. 参考文章")]),_:1})])])])]),_,o("p",null,[n("请求报文的示例如下（详细的报文格式可以看 "),o("a",P,[n("HTTP 入门"),t(i)]),n("）：")]),m,o("ul",null,[o("li",null,[o("a",C,[n("小林 coding"),t(i)])]),o("li",null,[o("a",b,[n("计算机网络微课堂"),t(i)])])])])}const S=l(d,[["render",f],["__file","键入URL到页面显示全过程.html.vue"]]);export{S as default};
