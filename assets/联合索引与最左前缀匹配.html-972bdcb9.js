import{_ as l,Z as i,$ as c,a3 as e,a1 as n,a4 as o,a2 as t,a0 as d,E as s}from"./framework-63f054a3.js";const p={},g={class:"hint-container details"},h=e("summary",null,"本文内容",-1),_={class:"table-of-contents"},u=d('<div class="hint-container info"><p class="hint-container-title">前言</p><p>在谈及到索引失效时，往往都会想到查询的条件是否满足最左前缀匹配。同时，面试也经常会问有关最左前缀匹配的 SQL，问你到底有没有走索引。所以把最左前缀匹配弄清楚是十分有必要的。</p></div><h2 id="_1-联合索引是如何存放的" tabindex="-1"><a class="header-anchor" href="#_1-联合索引是如何存放的" aria-hidden="true">#</a> <strong>1. 联合索引是如何存放的</strong></h2><p>因为最左前缀匹配原则主要是与联合索引有关。所以我们先来看看联合索引是如何存放在 B+ 树中的。</p><p>我们知道，InnoDB 中非聚簇索引的叶子节点是不存放完整记录的，它只存放 <strong>索引列 + 主键</strong>。那么如果我有多个索引列（即联合索引），它会怎么样帮我存放这多个列呢？</p><p>假设我们有个表，id 为主键，有一个联合索引（name, age)，那么这颗 B+ 树的叶子节点长这样（非叶子节点就只有索引列）：</p><p><img src="https://run-notes.oss-cn-beijing.aliyuncs.com/notes/202302192026015.png" alt="image-20230219202539043"></p><p>可以发现，联合索引（name, age）的排序规则是 <strong>先按照最左侧的 name 排序，name 相同才按照 age 排序</strong>。</p><h2 id="_2-最左前缀匹配原则是什么" tabindex="-1"><a class="header-anchor" href="#_2-最左前缀匹配原则是什么" aria-hidden="true">#</a> <strong>2. 最左前缀匹配原则是什么</strong></h2><p>正是因为联合索引的排序规则，所以才会存在 <strong>最左前缀匹配原则</strong>，顾名思义，即 <strong>优先按照最左列进行索引的匹配</strong>。</p><p>还是用上面的例子，如果我的查询条件是 <code>where age = 16</code>，就无法使用到索引（不考虑索引覆盖），因为不满足最左前缀匹配原则（只有 name 相等时，age 才有序，而只用 age 查询，age 在全局上是无序的）。</p><p>不过需要注意，<strong>联合索引出现的位置无关紧要</strong>，因为优化器会做优化，例如 <code>where age = 14 and name = 小C</code> 也是可以使用到索引的。</p><p>还有一种情况 <code>where name like &#39;小%&#39;</code>，也称得上是满足最左前缀匹配，也能用上索引，查找到第一个符合 <code>小</code> 开头的记录，然后向后遍历，直到不满足为止。</p><p>可以发现，最左前缀匹配分为两种情况：</p><ul><li><strong>联合索引的最左 N 个字段</strong>；</li><li><strong>字符串索引的最左 M 个字符</strong>。</li></ul><h2 id="_3-如何安排联合索引中列的顺序" tabindex="-1"><a class="header-anchor" href="#_3-如何安排联合索引中列的顺序" aria-hidden="true">#</a> <strong>3. 如何安排联合索引中列的顺序</strong></h2><p>由于最左前缀匹配原则的存在，联合索引中列的顺序就显得尤其重要了，那我们在建立联合索引的时候，该如何决策联合索引中列的顺序呢？</p><div class="hint-container tip"><p class="hint-container-title">一、索引的复用能力</p></div><p>由于可以满足最左前缀匹配，所以当有了 (a, b) 这个联合索引后，一般就无需再单独给 a 建立索引了（单独使用 a 字段查询是可以使用到联合索引的）。</p><p>所以第一原则是：<strong>如果通过调整联合索引的顺序，可以少维护一个索引，那么这个联合索引往往就是需要优先考虑采用的</strong>。</p><div class="hint-container tip"><p class="hint-container-title">二、空间的考虑</p></div><p>如果有时候，我们既需要 (a, b) 这个联合索引，通过又有基于 a、b 各自的查询呢？查询条件里只有 b 是无法使用联合索引的。</p><p>这个时候我们可以有两个方案：</p><ul><li>方案一：联合索引 (a, b)，单列索引 (b)；</li><li>方案二：联合索引 (b, a)，单列索引 (a)。</li></ul><p>这两个方案到底选哪个呢？这时我们就要 <strong>考虑空间</strong> 了。如果 a 字段占用的字节数比 b 大，那么肯定选择方案一嘛，这样单列索引 (b) 占用的空间更小，一页中能存储的记录自然也就更多。</p><div class="hint-container tip"><p class="hint-container-title">三、索引区分度的考虑</p></div><p>索引区分度，即某个字段不同值的数量「÷」表的总行数，公式如下：</p><p><img src="https://run-notes.oss-cn-beijing.aliyuncs.com/notes/202302192116026.png" alt="image-20230219211559913"></p><p>所以，查看某个字段的区分度可以使用如下 SQL：</p><ul><li><p><code>SELECT COUNT(DISTINCE LEFT(column_name, length)) / COUNT(*) FROM table_name;</code></p></li><li><p>其中：<code>LEFT</code> 函数是取 <code>column_name</code> 这个字段的前 length 个字符；</p></li></ul><p>所以，<strong>在建立联合索引的时候，应该尽量把区分度大的字段放在前面</strong>，因为区分度大的字段不重复的数据多，那么每次过滤掉的数据就多，使得查询效率更高。</p><h2 id="_4-什么情况下联合索引会失效" tabindex="-1"><a class="header-anchor" href="#_4-什么情况下联合索引会失效" aria-hidden="true">#</a> <strong>4. 什么情况下联合索引会失效</strong></h2><p>通过对最左前缀匹配的理解，我们可以得出几个简单的索引失效的情况。例如联合索引 (a, b, c)，那么索引失效的情况可能有：</p><ul><li><code>where b = 1</code>；</li><li><code>where c = 2</code>；</li><li><code>where b = 3 and c = 4</code>。</li></ul><p>这是比较容易判断的，那只要使用了联合索引的最左 N 个字段，就一定会全都走索引吗？</p><p>显然不是，例如下面的一种情况：</p><ul><li>SQL 语句：<code>select * from table where a &gt; 1 and b = 3;</code></li><li>联合索引 (a, b)。</li></ul><p>这句 SQL 语句中，字段 a，b 都使用到了联合索引吗？</p><p>首先可以确定一点，<strong>字段 a 是肯定使用到了索引的</strong>，因为它满足最左前缀匹配，能形成有序的扫描区间 (1, +∞)，只需要找到第一条 a &gt; 1 的记录，然后向后查找即可。</p><p>那么 b 有没有使用到索引，就要看看它是否有序。我们知道只有当 a 相等时，b 才有序，<strong>而在 a &gt; 1 的记录中，b 是无序的，所以 b 使用不到索引</strong>。</p><p>那如果 SQL 语句是 <code>select * from table where a &gt;= 1 and b = 3;</code>，此时 b 字段也就能使用到索引了，因为 <strong>当 a = 1 时，b 字段是有序的</strong>。</p><p>所以同理，<code>where a between 1 and 5 and b = 3;</code> 也是能使用到索引的，因为 <strong><code>between</code> 是包含两边的边界值的</strong>。</p><p>所以，<strong>判断某条查询语句是否走了索引，关键就看它是否能形成有序区间，能就可以走索引</strong>。</p><h2 id="_5-参考文章" tabindex="-1"><a class="header-anchor" href="#_5-参考文章" aria-hidden="true">#</a> <strong>5. 参考文章</strong></h2>',43),b=e("li",null,"《MySQL 实战 45 讲》",-1),m={href:"https://xiaolincoding.com",target:"_blank",rel:"noopener noreferrer"};function f(x,v){const a=s("router-link"),r=s("ExternalLinkIcon");return i(),c("div",null,[e("details",g,[h,e("nav",_,[e("ul",null,[e("li",null,[n(a,{to:"#_1-联合索引是如何存放的"},{default:o(()=>[t("1. 联合索引是如何存放的")]),_:1})]),e("li",null,[n(a,{to:"#_2-最左前缀匹配原则是什么"},{default:o(()=>[t("2. 最左前缀匹配原则是什么")]),_:1})]),e("li",null,[n(a,{to:"#_3-如何安排联合索引中列的顺序"},{default:o(()=>[t("3. 如何安排联合索引中列的顺序")]),_:1})]),e("li",null,[n(a,{to:"#_4-什么情况下联合索引会失效"},{default:o(()=>[t("4. 什么情况下联合索引会失效")]),_:1})]),e("li",null,[n(a,{to:"#_5-参考文章"},{default:o(()=>[t("5. 参考文章")]),_:1})])])])]),u,e("ul",null,[b,e("li",null,[e("a",m,[t("小林 coding"),n(r)])])])])}const L=l(p,[["render",f],["__file","联合索引与最左前缀匹配.html.vue"]]);export{L as default};
