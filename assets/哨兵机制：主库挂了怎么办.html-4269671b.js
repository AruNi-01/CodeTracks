import{_ as i}from"./plugin-vue_export-helper-c27b6911.js";import{r as a,o as g,c as _,b as t,e as o,w as r,d as n,a as l}from"./app-61ed31ff.js";const d={},p={class:"hint-container details"},c=t("summary",null,"本文内容",-1),h={class:"table-of-contents"},u=l('<h2 id="_1-主库挂了怎么办" tabindex="-1"><a class="header-anchor" href="#_1-主库挂了怎么办" aria-hidden="true">#</a> 1. 主库挂了怎么办？</h2><p>在主从库集群模式下，如果从库发生故障，客户端还可以向主库和其他从库发送请求，不会影响到可用性。但如果主库发生故障，就会影响从库的数据同步，以及写操作无法进行了，因为主从模式采用的是读写分离。</p><p>而 <strong>从库无法同步数据，写操作无法执行，这两个都是不能接受的，严重影响到了集群的可用性</strong>。</p><p>因此，<strong>当主库挂了后，就需要重新来一个新主库</strong>，比如把一个从库切换为主库。</p><p>不过，重新选择一个主库并不是那么简单的，还需要考虑三个问题：</p><ul><li><strong>主库是真的挂了吗</strong>？</li><li><strong>选择哪个从库作为主库</strong>？</li><li><strong>怎么把新主库通知给客户端和其他从库</strong>？</li></ul><p>Redis 的 <strong>哨兵机制</strong> 就有效的解决了主从模式下故障转移的上面三个问题，下面就来看看哨兵机制到底是怎么一回事。</p><h2 id="_2-哨兵机制是什么" tabindex="-1"><a class="header-anchor" href="#_2-哨兵机制是什么" aria-hidden="true">#</a> 2. 哨兵机制是什么？</h2><p>与主从库实例一样，哨兵也是一个特殊的 Redis 进程，它主要负责三个任务：<strong>监控、选主、通知</strong>。</p><p>这三个任务的主要目标如下图所示：</p><p><img src="https://run-notes.oss-cn-beijing.aliyuncs.com/notes/https%2Fstatic001.geekbang.org%2Fresource%2Fimage%2Fef%2Fa1-2024_01_04-1704370587.jpeg" alt="img" loading="lazy"></p><h3 id="_2-1-监控" tabindex="-1"><a class="header-anchor" href="#_2-1-监控" aria-hidden="true">#</a> 2.1 监控</h3><p><strong>监控</strong> 就是指哨兵进程在运行时，<strong>会周期性地给所有主从库发送 PING 命令</strong>，检查它们是否在线运行，如果它们 <strong>没有在规定时间内响应</strong>，哨兵就会把它们标记为 “<strong>下线状态</strong>”。</p><p>不过，对于 <strong>主库</strong> 来说，判断下线状态没这么简单，涉及到 <strong>主观下线和客观下线</strong>。而对于从库来说，哨兵只需要标记为 “主观下线” 就行了，因为从库下线影响不大，不影响集群的可用性。</p><div class="hint-container info"><p class="hint-container-title">为什么主库需要两个下线状态？</p><p>对于主库来说，如果只是简单的标记为 “主观下线”，就开启主从切换（选一个从库切换成主库），会有一个 <strong>误判情况</strong>，就是其实 <strong>主库并没有故障</strong>，只是 <strong>集群的网络拥塞、哨兵本身网络不好、或者是主库自身压力比较大，响应慢了</strong> 等情况。</p><p>如果出现了上面的误判情况后开启主从切换，<strong>后续的选主和通知操作都会带来额外的开销</strong>，比如花时间选出新主库、重新给从库同步数据。而这些开销实际上是不需要的，因为主库其实并没有挂，只是哨兵自己误判了。</p></div><p>想要减少误判，一个常用的做法就是大家协商，多数人都认为它挂了，才是真的挂了，即客观下线。</p><p>哨兵机制就是这样，<strong>哨兵通常也会部署多个</strong>，它们被称为 <strong>哨兵集群</strong>。在判断主库是否下线时，<strong>只有大多数哨兵实例都判断主库已经 “主观下线” 后，主库才会被标记为 “客观下线”</strong>，判断原则就是 <strong>少数服从多数</strong>。</p><p>简单来说，“客观下线” 的标准就是有 N/2 + 1 个实例都认为主库已经 “主观下线” 了，所以一般将哨兵实例个数设置成基数个，比如 3、5、7。</p><p>引入多个哨兵实例一起判断，就可以 <strong>避免单个哨兵因为自身网络不好导致的误判</strong>，这样就能降低误判率。</p><h3 id="_2-2-选主" tabindex="-1"><a class="header-anchor" href="#_2-2-选主" aria-hidden="true">#</a> 2.2 选主</h3><p>哨兵在选主时需要决定选择哪个从库作为新的主库，选择过程可以分为 <strong>筛选 + 打分</strong>，即从多个从库中先按照 <strong>一定的筛选条件</strong>，把不合符的从库去掉，然后再按照 <strong>一定规则打分</strong>，得分最高的即为新的主库。</p><p>先来看看 <strong>筛选条件</strong>，要确保所选的 <strong>从库任然在线运行</strong>，这个在线状态还需要判断 <strong>其之前的网络连接状态</strong>，<strong>避免从库经常和主库断连</strong> 的情况。</p><p>具体判断需要使用配置项 <strong>down-after-milliseconds</strong>，它表示 <strong>主从库断连的最大超时时间</strong>，如果在 down-after-milliseconds 毫秒内，主从库都还没连接上，则可以认为主从库断连了，<strong>如果发生断连的次数超过了 10 次，就说明该从库的网络状况不好，不适合作为新主库</strong>。</p><p>再来看看如何 <strong>打分</strong>，有三个打分规则对从库依次进行三轮打分，这三个规则分别是 <strong>从库优先级、从库复制进度和从库 ID 号</strong>。这个打分过程中，<strong>只要某一轮中有一个从库得分最高，那它就是新主库，结束了选主过程</strong>。出现了 <strong>平分</strong> 的情况，才会继续进行 <strong>下一轮打分</strong>。</p><div class="hint-container info"><p class="hint-container-title">第一轮：优先级高的从库得分高</p><p>我们可以通过 <strong>slave-priority 配置项给从库设置优先级</strong>，比如可以给内存、性能高的从库设置一个高优先级，在选主时让其得分最高，成为新主库。</p><p>如果从库的优先级都一样，哨兵就会开启第二轮打分。</p></div>',25),f={class:"hint-container info"},E=t("p",{class:"hint-container-title"},"第二轮：和旧主库同步进度最接近的从库得分高",-1),b={href:"https://code.0x3f4.run/backend/database/redis/high_availability/%E4%B8%BB%E4%BB%8E%E6%A8%A1%E5%BC%8F.html#_5-%E4%B8%BB%E4%BB%8E%E5%BA%93%E9%97%B4%E7%9A%84%E7%BD%91%E7%BB%9C%E6%96%AD%E4%BA%86%E6%80%8E%E4%B9%88%E5%8A%9E",target:"_blank",rel:"noopener noreferrer"},B=t("strong",null,"主库和从库都会有一个 repl_backlog_buffer 环形缓冲区",-1),m=t("strong",null,"它们之间的差值就代表了主从库的同步进度",-1),x=t("p",null,[n("也就是说，"),t("strong",null,"哪个从库 repl_backlog_buffer 读到的位置与主库 repl_backlog_buffer 写到的位置越接近，哪个从库的得分就越高"),n("。如果有多个从库的位置都相同，那就要进行第三轮打分了。")],-1),k=t("p",null,[n("其实这里的比较同步进度，"),t("strong",null,"实际上是比较从库之间的读取位置"),n("，因为此时主库已经挂了，是不知道主库写到的位置的。")],-1),v=l('<div class="hint-container info"><p class="hint-container-title">第三轮：IO 号小的从库得分高</p><p>每个 Redis 实例都有一个 ID，类似与从库的编号，<strong>ID 号小的从库得分高，因为 ID 号小就意味着该从库存在的时间更长，也就能代表其更稳定</strong>。</p></div><p>最后再来总结以下选主的过程：首先哨兵会根据 <strong>在线状态、网络状态</strong> 筛选掉一部分从库，然后按照 <strong>从库优先级、复制进度、ID 号大小</strong> 进行 <strong>打分</strong>，<strong>只要有得分最高的从库出现，其就是新主库</strong>。</p><h3 id="_2-3-通知" tabindex="-1"><a class="header-anchor" href="#_2-3-通知" aria-hidden="true">#</a> 2.3 通知</h3><p>通知比较简单，<strong>哨兵只需要把新主库的连接信息发送给其他从库</strong>，让从库们执行 replicaof 命令，重新和新主库建立连接，然后同步数据。</p><p>同时，<strong>哨兵也会把新主库的连接信息通知给客户端</strong>，这样客户端就可以把后续请求发给新主库了。</p><h2 id="_3-哨兵在主从切换过程中-客户端还能正常请求吗" tabindex="-1"><a class="header-anchor" href="#_3-哨兵在主从切换过程中-客户端还能正常请求吗" aria-hidden="true">#</a> 3. 哨兵在主从切换过程中，客户端还能正常请求吗？</h2><p>通过上面的分析可知，哨兵在主从切换过程中涉及选主、通知，可能会消耗比较长的时间，那这个过程客户端还能正常请求吗？</p><p>如果客户端使用了读写分离，那么读请求还是可以在从库上正常执行的，但是 <strong>写请求会失败</strong>，<strong>持续的时间</strong> 为 <strong>哨兵主从切换的时间 + 客户端感知到新主库的时间</strong>。</p><p>想要 <strong>减少写请求失败的持续时间</strong>，可以通过配置 <strong>down-after-milliseconds</strong> 参数来变相实现，上面讲过，该参数表示主从库断连的最大超时时间，对于哨兵来说，表示 <strong>认为主库断连的超时时间</strong>，配置的越短，<strong>哨兵就能越早发现主库断连，从而更早的发起主从切换，以切换的更及时</strong>。但也有可能 <strong>因为网络拥堵主库正常而导致的不必要切换</strong>，所以需要综合考虑。</p><p>另外，要 <strong>让客户端尽快感知到主库发生了变化</strong>，做法如下：</p><ul><li><p>对于哨兵来说，<strong>哨兵选出新主库后，就会把新主库地址写入 topic 为 switch-master 的 pubsub 中</strong>，客户端需要订阅这个 pubsub，以及时感知主库发生了变化，并拿到新主库的地址。这种机制属于哨兵主动通知客户端。</p></li><li><p>对于客户端来说，<strong>需要主动地去获取最新地主从库地址进行访问</strong>，所以 <strong>不能直接写死主从库的地址</strong>，而是要 <strong>从哨兵集群中获取</strong>，可以通过 <strong>sentinel get-master-addr-by-name 命令</strong>。这样当哨兵切换主库或者客户端断开重连后，客户端都可以从哨兵集群中获取最新的主从库地址。</p><blockquote><p>一般 Redis 的 SDK 都提供了通过哨兵拿到实例地址，再访问实例的方式，直接使用即可。在分片集群（后续讲解）模式下，这些逻辑都可以在 proxy 层做，客户端只需要正常请求 proxy 服务器即可。</p></blockquote></li></ul><h2 id="_4-哨兵集群判断主库客观下线后-由哪个哨兵来执行主从切换" tabindex="-1"><a class="header-anchor" href="#_4-哨兵集群判断主库客观下线后-由哪个哨兵来执行主从切换" aria-hidden="true">#</a> 4. 哨兵集群判断主库客观下线后，由哪个哨兵来执行主从切换？</h2><p>哨兵集群在判断出主库 “客观下线” 后，会选出一个 “<strong>哨兵领导者</strong>”，<strong>之后的整个过程都由它来完成主从切换</strong>。</p>',13),A=t("strong",null,"分布式系统中的选举/共识算法了",-1),D={href:"https://code.0x3f4.run/backend/distributed/coord_and_sync/%E5%88%86%E5%B8%83%E5%BC%8F%E9%80%89%E4%B8%BE%EF%BC%9A%E5%9B%BD%E4%B8%8D%E5%8F%AF%E4%B8%80%E6%97%A5%E6%97%A0%E5%90%9B.html",target:"_blank",rel:"noopener noreferrer"},F=t("p",null,[n("简单来说，每个哨兵会设置一个随机超时时间，"),t("strong",null,"超时后每个哨兵会请求其他哨兵为自己投票"),n("，其他哨兵会对收到的第一个请求进行投票，而且每轮只能投一票，投票结束后，"),t("strong",null,"具有多数票（超过哨兵节点数的一半，且达到配置的 quorum 值）的哨兵会成为 “哨兵领导者”"),n("，如果这一轮投票没有达到多数票的哨兵，就会重新选举，直到选出这个领导者。")],-1),y=t("h2",{id:"_5-参考文章",tabindex:"-1"},[t("a",{class:"header-anchor",href:"#_5-参考文章","aria-hidden":"true"},"#"),n(" 5. 参考文章")],-1),I=t("ul",null,[t("li",null,"《Redis 核心技术与实战》")],-1);function R(w,C){const s=a("router-link"),e=a("ExternalLinkIcon");return g(),_("div",null,[t("details",p,[c,t("nav",h,[t("ul",null,[t("li",null,[o(s,{to:"#_1-主库挂了怎么办"},{default:r(()=>[n("1. 主库挂了怎么办？")]),_:1})]),t("li",null,[o(s,{to:"#_2-哨兵机制是什么"},{default:r(()=>[n("2. 哨兵机制是什么？")]),_:1}),t("ul",null,[t("li",null,[o(s,{to:"#_2-1-监控"},{default:r(()=>[n("2.1 监控")]),_:1})]),t("li",null,[o(s,{to:"#_2-2-选主"},{default:r(()=>[n("2.2 选主")]),_:1})]),t("li",null,[o(s,{to:"#_2-3-通知"},{default:r(()=>[n("2.3 通知")]),_:1})])])]),t("li",null,[o(s,{to:"#_3-哨兵在主从切换过程中-客户端还能正常请求吗"},{default:r(()=>[n("3. 哨兵在主从切换过程中，客户端还能正常请求吗？")]),_:1})]),t("li",null,[o(s,{to:"#_4-哨兵集群判断主库客观下线后-由哪个哨兵来执行主从切换"},{default:r(()=>[n("4. 哨兵集群判断主库客观下线后，由哪个哨兵来执行主从切换？")]),_:1})]),t("li",null,[o(s,{to:"#_5-参考文章"},{default:r(()=>[n("5. 参考文章")]),_:1})])])])]),u,t("div",f,[E,t("p",null,[n("这里就涉及到 "),t("a",b,[n("主从模式"),o(e)]),n(" 中讲的，主从库同步增量命令时有个基于长连接命令传播的过程，这时 "),B,n("，用于断连后增量恢复使用。主库会记录自己写到的位置，从库则会记录自己读到的位置，"),m,n("。")]),x,k]),v,t("p",null,[n("至于如何选出这个 “哨兵领导者”，就涉及到 "),A,n("，可以看看分布式选举 Leader 的文章 "),t("a",D,[n("分布式选举"),o(e)]),n("。常见的有 Paxos、Raft 算法，哨兵集群采用的就是类似与 Raft 的共识算法。")]),F,y,I])}const q=i(d,[["render",R],["__file","哨兵机制：主库挂了怎么办.html.vue"]]);export{q as default};
