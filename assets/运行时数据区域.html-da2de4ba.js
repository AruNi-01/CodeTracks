import{_ as g}from"./plugin-vue_export-helper-c27b6911.js";import{r as a,o as l,c as p,a as t,d as o,w as r,b as n,e}from"./app-fff4f215.js";const c={},d={class:"hint-container details"},_=t("summary",null,"本文内容",-1),u={class:"table-of-contents"},h=e('<div class="hint-container info"><p class="hint-container-title">前言</p><p>JVM 的 <strong>自动内存管理机制</strong> 帮助了我们很友好的使用内存，写 Java 代码时，不用为 new 出来的对象进行释放，JVM 会在合适的时机帮我们进行 <strong>垃圾回收</strong>。</p><p>但我们还是有必要去了解一下 Java 的内存区域是怎样的，JVM 是怎样使用内存的，这样在出现内存相关的问题时，比如内存泄漏、内存溢出，才有能力去排查。</p><p>本章先来了解 Java 的 <strong>运行时数据区域</strong> 是如何划分的，每个区域分别有什么作用，保存什么数据？</p></div><h2 id="_1-运行时数据区域有哪些" tabindex="-1"><a class="header-anchor" href="#_1-运行时数据区域有哪些" aria-hidden="true">#</a> 1. 运行时数据区域有哪些？</h2><p>JVM 在执行程序时，会将内存划分为几个不同的数据区域，如下所示：</p><p><img src="https://run-notes.oss-cn-beijing.aliyuncs.com/notes/202306272300232.png" alt="image-20230627230024084" loading="lazy"></p><ul><li><p><strong>程序计数器</strong>：一块比较小的空间，与 OS 的 PC 类似，<strong>JVM 的解释器（在执行引擎中）就是通过改变这个计数器的值来取得下一条字节码指令</strong>；</p><blockquote><p>在多线程场景下，<strong>为了保证线程切换后能恢复到原来的执行位置，因此程序计数器是线程隔离的</strong>，即每个线程都有一份。</p></blockquote></li><li><p><strong>Java 栈</strong>：Java 方法执行时都需要创建一个 <strong>栈帧</strong>，用于存储 <strong>局部变量表（比如一些基本数据类型、对象的引用）、方法出口等信息</strong>。一个方法从调用到退出的过程，就对应 <strong>一个栈帧在 Java 栈中从入栈到出栈的过程</strong>；</p><blockquote><p>由于 <strong>每个方法执行时存储的信息都不同</strong>，所以 <strong>Java 栈也是线程私有的</strong>。</p></blockquote></li><li><p><strong>本地方法栈</strong>：和 Java 栈类似，不过是用来执行 <strong>本地（Native）方法</strong> 的；</p></li><li><p><strong>堆</strong>：一块比较大且是所有 <strong>线程共享</strong> 的内存空间，用于 <strong>保存对象实例</strong>，Java 中几乎所有的对象实例都在这里面（说 “几乎” 是因为逃逸分析技术的存在），这也是 <strong>GC 所管理的区域</strong>；</p></li><li><p><strong>方法区</strong>：与堆一样，也是 <strong>线程共享</strong> 的一块内存，但它主要存储 <strong>已被加载的类型信息、常量、静态变量</strong> 等。</p><blockquote><p>为了降低内存溢出的风险，JDK 1.8 中使用了元空间来代替方法区的实现。</p></blockquote></li></ul><h2 id="_2-程序计数器" tabindex="-1"><a class="header-anchor" href="#_2-程序计数器" aria-hidden="true">#</a> 2. 程序计数器</h2><p><strong>程序计数器</strong>（Program Counter Register）是用来 <strong>记录当前线程执行到的指令地址</strong>，也就是执行到哪个位置了，通过改变该计数器的值就能获取到下一条需要执行的指令。</p><p>由于每个线程执行到的位置都不相同，所以程序计数器肯定是 <strong>线程私有</strong> 的。这样 <strong>在多线程环境下，线程切换后才能恢复到其原来执行的地方</strong>（CPU 一个核心同一时刻只能运行一个线程，因此会涉及到线程的切换）。</p><h2 id="_3-java-栈" tabindex="-1"><a class="header-anchor" href="#_3-java-栈" aria-hidden="true">#</a> 3. Java 栈</h2><p><strong>Java 栈</strong>（Java Stack）也是 <strong>线程私有</strong> 的，在方法调用时，就会 <strong>把用该方法创建的栈帧压入栈顶</strong>。所以每一次方法的调用，就伴随着一个栈帧在 Java 栈中从入栈到出栈的过程。</p><div class="hint-container info"><p class="hint-container-title">栈帧中包含哪些内容？</p><p>在进行方法调用时，每个方法都会创建其自己的栈帧，然后进入 Java 栈中执行。</p><p><img src="https://run-notes.oss-cn-beijing.aliyuncs.com/notes/202308191732462.png" alt="image-20230819173227692" loading="lazy"></p><p>一个栈帧中会包含如下数据：</p><ul><li><p><strong>局部变量表</strong>：存放了一些编译期就能确定的一些数据，比如 <strong>基本数据类型、对象的引用</strong>（只是一个指向对象的引用指针，并不是真的对象），以及 <strong>方法的返回地址</strong> 等；</p></li><li><p><strong>操作数栈</strong>：存放 <strong>计算过程的中间结果</strong>，以及作为这些 <strong>临时变量的存储空间</strong>；</p></li><li><p><strong>动态链接</strong>：一个 <strong>指向该栈帧所属方法的引用</strong>，也就是当要调用方法时，通过这个动态链接，就可以找到这个方法的具体位置；</p><blockquote><p>所以栈帧是不等于方法的，通过栈帧中的动态链接，可以找到该方法。</p></blockquote></li><li><p><strong>方法出口</strong>：记录了在一个方法调用结束后，<strong>应该回到调用该方法的方法中的位置</strong>。</p><blockquote><p>比如 funcA 在第 10 行代码调用了 funcB，那么 funcB 栈帧中的方法出口，就会记录 funcA 的第 10 行这个位置，以便继续执行 funcA 后续的代码。</p></blockquote></li></ul></div><p>对于 Java 栈，JVM 规定了两类异常：</p><ul><li><p>如果线程请求的 <strong>栈帧深度大于虚拟机所允许的最大深度</strong>（比如无限进行递归），那么将会抛出 <strong>StackOverflowError 异常</strong>；</p></li><li><p>对于 Java 栈容量 <strong>可动态扩展</strong> 的虚拟机来说，如果 <strong>栈在扩展时无法申请到足够的内存</strong>，则会抛出 <strong>OutOfMemoryError 异常</strong>。</p><blockquote><p>以前的 Classic 虚拟机就支持 Java 栈容量的动态扩展，不过现在的 <strong>HotSpot 虚拟机是不支持的，但它在申请栈空间时，如果申请失败也要抛出 OOM 异常</strong>。</p></blockquote></li></ul><h2 id="_4-本地方法栈" tabindex="-1"><a class="header-anchor" href="#_4-本地方法栈" aria-hidden="true">#</a> 4. 本地方法栈</h2><p>本地方法栈（Native Method Stack）和 Java 栈类似，只不过 Java 栈是执行 Java 方法，而 <strong>本地方法则是执行 JVM 本身可能需要用到的本地（native）方法</strong>。</p><p>native 方法可以由其他语言编写（常用的就是 C/C++），因为 Java 本身可能不方便与操作系统底层或者硬件进行交互，而且效率也不高，所以提供了一些 native 方法。</p><p>本地方法栈与 Java 栈一样，也会在栈深度溢出或扩展失败时出现 StackOverFlowError 和 OutOfMemoryError 异常。</p><h2 id="_5-堆" tabindex="-1"><a class="header-anchor" href="#_5-堆" aria-hidden="true">#</a> 5. 堆</h2>',18),v=t("strong",null,"Java 堆",-1),J=t("strong",null,"线程共享",-1),f=t("strong",null,"几乎",-1),m=t("strong",null,"对象实例",-1),b={href:"https://aruni.me/studynotes/java/jvm/compile_and_optimize/%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90.html",target:"_blank",rel:"noopener noreferrer"},k=e('<p>由于 Java 堆占据了内存的绝大部分，所以 JVM 有专门的垃圾收集器来对该内存区域进行垃圾回收。</p><h2 id="_6-方法区" tabindex="-1"><a class="header-anchor" href="#_6-方法区" aria-hidden="true">#</a> 6. 方法区</h2><p><strong>方法区</strong>（Method Area）也是 <strong>线程共享</strong> 的一块内存区域，用于存放被虚拟机加载好的 <strong>类信息、常量和静态变量</strong> 等。</p><p>其实方法区是堆的一个逻辑部分，但我们经常称之为非堆，目的就是和堆区分开来。</p><div class="hint-container info"><p class="hint-container-title">永久代、元空间的概念</p><p>其实，<strong>方法区只是一个逻辑上的概念，对应具体的落地实现可以有多种</strong>，而 <strong>永久代和元空间</strong> 就是两种不同的实现方式。</p><p><strong>在 JDK 8 以前，方法区是用永久代来实现的</strong>，这样能 <strong>让垃圾收集器像管理 Java 堆一样管理方法区内存</strong>，就不用为这部分内存专门编写一个内存管理模块了。然而后面在具体使用时发现，这样导致 Java 程序更容易发生内存溢出的问题，因为永久代是有内存上限的。</p><p><strong>JDK 7 时开始将原本放在永久代中的字符串常量池、静态变量等移出，存放在了堆中</strong>。</p><p><strong>到了 JDK 8 时</strong>，JVM 放弃了永久代的概念，改用 <strong>元空间来实现方法区</strong>，元空间在 <strong>本地内存</strong> 上，因此只受机器物理内存的大小限制（当然也可以自己限制）。把 JDK 7 中 <strong>永久代剩下的内容（主要是类信息）全部移到元空间中</strong>。</p><p>变迁对比如下：</p><p><img src="https://run-notes.oss-cn-beijing.aliyuncs.com/notes/202308191704955.png" alt="image-20230819170432663" loading="lazy"></p></div><h2 id="_7-总结" tabindex="-1"><a class="header-anchor" href="#_7-总结" aria-hidden="true">#</a> 7. 总结</h2><p>最后再回过头来看这张 JVM 的内存区域划分图，就更加清晰了：</p><p><img src="https://run-notes.oss-cn-beijing.aliyuncs.com/notes/202306272300232.png" alt="image-20230627230024084" loading="lazy"></p>',8);function M(x,V){const s=a("router-link"),i=a("ExternalLinkIcon");return l(),p("div",null,[t("details",d,[_,t("nav",u,[t("ul",null,[t("li",null,[o(s,{to:"#_1-运行时数据区域有哪些"},{default:r(()=>[n("1. 运行时数据区域有哪些？")]),_:1})]),t("li",null,[o(s,{to:"#_2-程序计数器"},{default:r(()=>[n("2. 程序计数器")]),_:1})]),t("li",null,[o(s,{to:"#_3-java-栈"},{default:r(()=>[n("3. Java 栈")]),_:1})]),t("li",null,[o(s,{to:"#_4-本地方法栈"},{default:r(()=>[n("4. 本地方法栈")]),_:1})]),t("li",null,[o(s,{to:"#_5-堆"},{default:r(()=>[n("5. 堆")]),_:1})]),t("li",null,[o(s,{to:"#_6-方法区"},{default:r(()=>[n("6. 方法区")]),_:1})]),t("li",null,[o(s,{to:"#_7-总结"},{default:r(()=>[n("7. 总结")]),_:1})])])])]),h,t("p",null,[v,n("（Java Heap）是虚拟机所管理的最大的一块内存，可以被所有 "),J,n("，"),f,n(" 所有的 "),m,n(" 都保存在堆中（为什么是几乎，因为可能存在栈上分配、标量替换的优化手段，具体看 "),t("a",b,[n("逃逸分析"),o(i)]),n("）。")]),k])}const E=g(c,[["render",M],["__file","运行时数据区域.html.vue"]]);export{E as default};
