import{_ as d}from"./plugin-vue_export-helper-c27b6911.js";import{r as i,o as g,c as a,b as o,e as n,w as e,d as t,a as l}from"./app-e3089c5a.js";const _={},u={class:"hint-container details"},c=o("summary",null,"本文内容",-1),p={class:"table-of-contents"},h=l('<h2 id="_1-四种隔离级别是如何实现的" tabindex="-1"><a class="header-anchor" href="#_1-四种隔离级别是如何实现的" aria-hidden="true">#</a> 1. 四种隔离级别是如何实现的？</h2><p>在四种隔离级别中，读未提交和串行化的实现是最简单的，基本不需要做过多的事情：</p><ul><li><strong>读未提交</strong>：每次读取数据时，不做任何措施，<strong>直接读取最新数据</strong> 就好了，所以可以读到未提交的数据；</li><li><strong>串行化</strong>：通过加 <strong>读写锁</strong> 来避免并发访问数据，读加读锁、写加写锁，读写锁互斥，所以一个事务在读的时候，另一个事务不可进行写操作，反之亦然。</li></ul><p>而对于读提交和可重复读的实现机制，就要涉及到额外的知识了。其实跟一个视图有关系，对于这两个隔离级别，数据库中会创建一个 <strong>视图</strong>，事务内访问的时候 <strong>以视图的逻辑结果为准</strong>，唯一的区别是视图的创建时机不同：</p><ul><li><strong>读提交</strong>：视图是在 <strong>每条 SQL 语句开始执行时</strong> 创建的，所以只要在执行这条 SQL 前，别的事务做的修改已经提交了，那么创建的视图就包含最新的记录；</li><li><strong>可重复读</strong>：视图是在 <strong>事务启动时</strong> 创建的，整个事务期间都使用这个视图，所以不会受到其他事务的影响。</li></ul><p>由于每个不同时间开启的事务，它们创建的视图是不同的，那视图所读取到的数据也是不同的，那这些数据是怎么组织/保存的呢？这就涉及到 MVCC 了。</p><h2 id="_2-mvcc-如何工作" tabindex="-1"><a class="header-anchor" href="#_2-mvcc-如何工作" aria-hidden="true">#</a> 2. MVCC 如何工作？</h2><p>MVCC 全称是 Multi-Version Concurrency Control，多版本并发控制，指的是在使用 <strong>读提交</strong> 和 <strong>可重复读</strong> 这两种隔离级别的事务下，<strong>执行普通 SELECT 操作时访问记录的版本链的过程</strong>。</p><p>通过这个版本链，既可以 <strong>保障并发事务的隔离性</strong>、又可以 <strong>提高数据库的性能</strong>（可以使得 <strong>读-写、写-读操作并发执行</strong>）。</p><p>这个版本链是由什么构成的呢？与前面讲的视图又有什么关系？</p><p>其实，<strong>版本链是由最新记录和多个 undo log 构成，每一个 undo log 都是一个视图</strong>，当事务中需要访问某个记录时，沿着 undo log 链（版本链）往下找，找到当前事务能看见的视图即可。</p>',11),m={href:"https://code.0x3f4.run/backend/database/mysql/log/undo%20log%EF%BC%9A%E4%B8%96%E4%B8%8A%E7%9C%9F%E6%9C%89%E5%90%8E%E6%82%94%E8%8D%AF.html",target:"_blank",rel:"noopener noreferrer"},V=l('<p>那么又如何判断当前事务能看见的视图是哪个呢？这又要讲讲 Read View 了，它在 MVCC 中起到了至关重要的作用。不过再此之前，我们得先知道版本链长什么样。</p><h3 id="_2-1-版本链长什么样" tabindex="-1"><a class="header-anchor" href="#_2-1-版本链长什么样" aria-hidden="true">#</a> 2.1 版本链长什么样？</h3><p>首先得知道，在 InnoDB 存储引擎中，聚簇索引的记录中都包含着两个 <strong>隐藏字段</strong>，分别是 trx_id 和 roll_pointer：</p><ul><li><strong>trx_id</strong>：<strong>操作该条记录的事务 id</strong>，当某个事务对聚簇索引的记录做了修改操作（CUD 都算）时，就会把该事务的事务 id 值赋给该记录的 trx_id 字段；</li><li><strong>roll_pointer</strong>：当某个事务对聚簇索引的记录做了修改操作（CUD 都算）时，都会把原记录写到 undo log 中，这个 <strong>roll_pointer 就相当于一个指针，指向这个 undo log</strong>，即通过新记录中的 roll_pointer 就可以找到旧纪录。</li></ul><blockquote><p>注意：row_id 不是必要的隐藏字段，当表中没有主键或非空的唯一键时才会包含 row_id。</p></blockquote><p>下面用一个 hero 表做示例，来看看版本链是怎么连接而成的。现在 hero 中只有一条记录：</p><table><thead><tr><th>number</th><th>name</th><th>country</th></tr></thead><tbody><tr><td>1</td><td>刘备</td><td>蜀</td></tr></tbody></table><p>假设在插入上面这条记录时，其事务 id 为 80，那么该记录的示意图如下：</p><p><img src="https://run-notes.oss-cn-beijing.aliyuncs.com/notes/事务%2F隔离级别的实现.assets-2023_12_07-1701945144.png" alt="image-20231207181958726" loading="lazy"></p><blockquote><p>注意：<strong>insert undo 只在事务回滚时起作用</strong>，当事务提交后就没用了，提交后该类型的 undo log 会被清理，但 roll_pointer 不会被清理，还是占用 7 个字节，其值表示的信息有 undo log 的类型等。</p></blockquote><p>现在我们启动两个事务对上面这条记录进行修改操作：</p><p><img src="https://run-notes.oss-cn-beijing.aliyuncs.com/notes/事务%2F隔离级别的实现.assets-2023_12_07-1701945392.png" alt="image-20231207183631231" loading="lazy"></p><p><strong>每次对记录进行改动都会生成一条 undo log，而每条 undo log 也会有一个 roll_pointer 属性</strong>（除了 insert undo，其没有更早的记录了），通过最新记录、undo log、roll_pointer 就可以将这些串联起来，形成一个版本链了，如下图所示：</p><p><img src="https://run-notes.oss-cn-beijing.aliyuncs.com/notes/事务%2F隔离级别的实现.assets-2023_12_07-1701945592.png" alt="image-20231207183949750" loading="lazy"></p><p>在版本链中，<strong>表头就是当前记录的最新值</strong>，其他都是旧记录，被 roll_pointer 串联起来。其中的 trx_id 很重要，在下面的 Read View 中就会使用到。</p><p>需要注意的是，这些 <strong>undo log 并不是一直保存着的</strong>，否则多么消耗空间。当没有事务需要用到这些 undo log 时，即系统中没有比该 undo log 更早的 Read View 时（通过 trx_id 判断），就会被删除。</p><p>因此，尽量 <strong>不要使用长事务</strong>，因为 <strong>长事务会导致系统中存在很老的视图</strong>，所以在其提交之前，这些 <strong>老的 undo log 都必须保留着</strong>，这就会导致 <strong>占用大量的存储空间</strong>。而且 <strong>长事务还可能占用更久的锁资源</strong>，因为锁是需要的时候加上，但要事务结束才释放。</p><p>而且在 <strong>MySQL 5.5 之前</strong>，<strong>undo log 和数据字典是存放在一起的</strong>，都在 <code>.ibd</code> 文件中，所以就算最终长事务提交了，<strong>undo log 被清理，但文件也不会缩小</strong>。因为不能将直接 <code>ibd</code> 文件删除，<strong>只是之前 undo log 的位置可以被重用（覆盖）了，即逻辑上的空闲</strong>。</p><p>不过从 MySQL 5.6、5.7 开始，undo log 和数据字典就是分开文件存储的了，undo log 存储在与事务日志相关的文件中（系统表空间的单独部分），数据字典存储在 <code>ibdata</code> 文件中。</p><h3 id="_2-2-read-view" tabindex="-1"><a class="header-anchor" href="#_2-2-read-view" aria-hidden="true">#</a> 2.2 Read View</h3><p>我们前面说到，判断当前事务能看见的视图是哪个需要使用到 Read View，在 Read View 中，有四个非常重要的字段：</p><ul><li>m_ids：在生成 Read View 时，当前系统中 <strong>活跃的事务 id 列表</strong>，活跃事务即开启但还没提交的事务；</li><li>min_trx_id：在生成 Read View 时，<strong>活跃事务 id 列表中最小的事务 id</strong>，即 m_ids 的最小值；</li><li>max_trx_id：生成 Read View 时，系统应该 <strong>分配给下个事务的事务 id</strong>，注意并不是 m_ids 的最大值，而是下一个事务的 id（事务 id 是递增分配的）；</li><li>creator_trx_id：<strong>生成该 Read View 事务的事务 id</strong>。</li></ul><p>通过 Read View 可以将记录中的 trx_id 划分为下面这三种情况：</p><p><img src="https://run-notes.oss-cn-beijing.aliyuncs.com/notes/事务%2F隔离级别的实现.assets-2023_12_07-1701958775.png" alt="image-20231207221934054" loading="lazy"></p><p>这样就可以根据 Read View 和前面的版本链，判断记录的某个版本是否可见了，具体规则如下：</p><ul><li>若 <strong>被访问版本的 trx_id 等于 Read View 中的 creator_trx_id</strong>，则该版本对当前事务 <strong>可见</strong>，因为这是当前事务 <strong>在访问它自己修改过的记录</strong>；</li><li>若 <strong>被访问版本的 trx_id 小于 Read View 中的 min_trx_id</strong>，表明该版本的事务 <strong>在生成该 Read View 之前就已经提交</strong>， 所以该版本对当前事务 <strong>可见</strong>；</li><li>若 <strong>被访问版本的 trx_id 大于等于 Read View 中的 max_trx_id</strong>，表明该版本的事务 <strong>在当前事务生成 Read View 后才开启</strong>，所以该版本对当前事务 <strong>不可见</strong>；</li><li>若 <strong>被访问版本的 trx_id 在 Read View 的 min_trx_id 和 max_trx_id 之间</strong>，则需要判断 <strong>trx_id 是否在 m_ids 列表中</strong>： <ul><li>若 <strong>在</strong>，表明创建 Read View 时，该版本的事务还是 <strong>活跃着（还没提交）</strong>，所以该版本对当前事务 <strong>不可见</strong>；</li><li>若 <strong>不在</strong>，表明创建 Read View 时，该版本的事务 <strong>已经被提交</strong>，所以该版本对当前事务 <strong>可见</strong>。</li></ul></li></ul><p>如果某个版本的记录对当前事务不可见，就 <strong>顺着版本链依次往下找</strong> 即可，若最后一个版本也不可见，则表明该记录对事务完全不可见，查询结果就不会包含此纪录。</p><h2 id="_3-总结" tabindex="-1"><a class="header-anchor" href="#_3-总结" aria-hidden="true">#</a> 3. 总结</h2><p>知道了版本链和 Read View，再来回顾下 MVCC 的概念就好理解多了，即执行普通 SELECT 操作时 <strong>访问记录的版本链的过程</strong>，MVCC 只有在读提交和可重复读的隔离级别中才会使用到。它们最大的不同就是 <strong>生成 Read View 的时机不同</strong>：</p><ul><li>读提交在每次查询前都会生成一个 Read View；</li><li>而可重复读只有在第一次查询前会生成一个 Read View，之后的查询都复用这个 Read View。所以才能保证整个事务内读取多次某条记录，每次读取到的都是相同的。</li></ul><p>而读未提交和串行化则不需要额外的控制了，分别靠每次查询直接读取最新记录和加读写锁保证。</p><h2 id="_4-参考文章" tabindex="-1"><a class="header-anchor" href="#_4-参考文章" aria-hidden="true">#</a> 4. 参考文章</h2>',32),x=o("li",null,"《MySQL 实战 45 讲》",-1),w=o("li",null,"《MySQL 是怎样运行的》",-1),b={href:"https://xiaolincoding.com",target:"_blank",rel:"noopener noreferrer"};function f(R,C){const r=i("router-link"),s=i("ExternalLinkIcon");return g(),a("div",null,[o("details",u,[c,o("nav",p,[o("ul",null,[o("li",null,[n(r,{to:"#_1-四种隔离级别是如何实现的"},{default:e(()=>[t("1. 四种隔离级别是如何实现的？")]),_:1})]),o("li",null,[n(r,{to:"#_2-mvcc-如何工作"},{default:e(()=>[t("2. MVCC 如何工作？")]),_:1}),o("ul",null,[o("li",null,[n(r,{to:"#_2-1-版本链长什么样"},{default:e(()=>[t("2.1 版本链长什么样？")]),_:1})]),o("li",null,[n(r,{to:"#_2-2-read-view"},{default:e(()=>[t("2.2 Read View")]),_:1})])])]),o("li",null,[n(r,{to:"#_3-总结"},{default:e(()=>[t("3. 总结")]),_:1})]),o("li",null,[n(r,{to:"#_4-参考文章"},{default:e(()=>[t("4. 参考文章")]),_:1})])])])]),h,o("blockquote",null,[o("p",null,[t("不了解 undo log 的可以先看 "),o("a",m,[t("undo log：世上真有后悔药"),n(s)]),t("。")])]),V,o("ul",null,[x,w,o("li",null,[o("a",b,[t("小林 coding"),n(s)])])])])}const k=d(_,[["render",f],["__file","隔离级别的实现原理.html.vue"]]);export{k as default};
