const e=JSON.parse('{"key":"v-6928a62f","path":"/studynotes/design_pattern/pattern/behaviour_type/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%EF%BC%88%E4%B8%8B%EF%BC%89%EF%BC%9A%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AAEventBus%E6%A1%86%E6%9E%B6.html","title":"观察者模式（下）：实现一个 EventBus 框架","lang":"zh-CN","frontmatter":{"title":"观察者模式（下）：实现一个 EventBus 框架","shortTitle":"观察者模式（下）","date":"2023-06-18T00:00:00.000Z","order":2,"category":["设计模式"],"tag":["设计模式与范式"],"sticky":false,"star":false,"article":true,"timeline":true,"description":"本文内容 前言 在上一篇文章中，我们知道了 观察者模式有几种不同的实现方式： 同步阻塞：经典实现方式，主要为了代码解耦； 异步非阻塞：除了解耦外，也能提高执行效率； 进程内：上面两种就属于进程内，在同一个程序中执行的； 进程间：更加彻底的解耦，一般基于 MQ 实现。 那么本篇文章将聚焦于异步非阻塞的方式，实现一个类似 Google Guava EventBus 的通用框架，对观察者模式进行封装，让其在项目中使用更简便。 EventBus 项目地址：https://github.com/AruNi-01/DesignPattern/tree/main/dp/src/observer/eventbus Guava 地址：https://github.com/google/guava ，直接下载 jar 包添加进自定义的目录，然后将该目录 Add as Library 即可使用，或者使用 Maven 亦可。","head":[["meta",{"property":"og:url","content":"https://aruni.me/studynotes/design_pattern/pattern/behaviour_type/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%EF%BC%88%E4%B8%8B%EF%BC%89%EF%BC%9A%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AAEventBus%E6%A1%86%E6%9E%B6.html"}],["meta",{"property":"og:site_name","content":"AruNi"}],["meta",{"property":"og:title","content":"观察者模式（下）：实现一个 EventBus 框架"}],["meta",{"property":"og:description","content":"本文内容 前言 在上一篇文章中，我们知道了 观察者模式有几种不同的实现方式： 同步阻塞：经典实现方式，主要为了代码解耦； 异步非阻塞：除了解耦外，也能提高执行效率； 进程内：上面两种就属于进程内，在同一个程序中执行的； 进程间：更加彻底的解耦，一般基于 MQ 实现。 那么本篇文章将聚焦于异步非阻塞的方式，实现一个类似 Google Guava EventBus 的通用框架，对观察者模式进行封装，让其在项目中使用更简便。 EventBus 项目地址：https://github.com/AruNi-01/DesignPattern/tree/main/dp/src/observer/eventbus Guava 地址：https://github.com/google/guava ，直接下载 jar 包添加进自定义的目录，然后将该目录 Add as Library 即可使用，或者使用 Maven 亦可。"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2023-09-16T10:04:08.000Z"}],["meta",{"property":"article:author","content":"AruNi_Lu"}],["meta",{"property":"article:tag","content":"设计模式与范式"}],["meta",{"property":"article:published_time","content":"2023-06-18T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2023-09-16T10:04:08.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"观察者模式（下）：实现一个 EventBus 框架\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2023-06-18T00:00:00.000Z\\",\\"dateModified\\":\\"2023-09-16T10:04:08.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"AruNi_Lu\\",\\"url\\":\\"https://github.com/AruNi-01\\"}]}"]]},"headers":[{"level":2,"title":"1. 异步非阻塞方式的简易实现","slug":"_1-异步非阻塞方式的简易实现","link":"#_1-异步非阻塞方式的简易实现","children":[]},{"level":2,"title":"2. Guava 的 EventBus","slug":"_2-guava-的-eventbus","link":"#_2-guava-的-eventbus","children":[{"level":3,"title":"2.1 使用 EventBus","slug":"_2-1-使用-eventbus","link":"#_2-1-使用-eventbus","children":[]},{"level":3,"title":"2.2 Guava EventBus 主要组件","slug":"_2-2-guava-eventbus-主要组件","link":"#_2-2-guava-eventbus-主要组件","children":[]}]},{"level":2,"title":"3. 自己实现一个 EventBus 框架","slug":"_3-自己实现一个-eventbus-框架","link":"#_3-自己实现一个-eventbus-框架","children":[{"level":3,"title":"3.1 EventBus 核心点剖析","slug":"_3-1-eventbus-核心点剖析","link":"#_3-1-eventbus-核心点剖析","children":[]},{"level":3,"title":"3.2 EventBus 具体实现","slug":"_3-2-eventbus-具体实现","link":"#_3-2-eventbus-具体实现","children":[]}]}],"git":{"createdTime":1687102117000,"updatedTime":1694858648000,"contributors":[{"name":"aarynlu","email":"aarynlu@tencent.com","commits":5}]},"readingTime":{"minutes":11.86,"words":3558},"filePathRelative":"studynotes/design_pattern/pattern/behaviour_type/观察者模式（下）：实现一个EventBus框架.md","localizedDate":"2023年6月18日","excerpt":"<details class=\\"hint-container details\\"><summary>本文内容</summary>\\n\\n</details>\\n<div class=\\"hint-container info\\">\\n<p class=\\"hint-container-title\\">前言</p>\\n<p>在上一篇文章中，我们知道了 <strong>观察者模式有几种不同的实现方式</strong>：</p>\\n<ul>\\n<li><strong>同步阻塞</strong>：经典实现方式，主要为了代码解耦；</li>\\n<li><strong>异步非阻塞</strong>：除了解耦外，也能提高执行效率；</li>\\n<li><strong>进程内</strong>：上面两种就属于进程内，在同一个程序中执行的；</li>\\n<li><strong>进程间</strong>：更加彻底的解耦，一般基于 MQ 实现。</li>\\n</ul>\\n<p>那么本篇文章将聚焦于异步非阻塞的方式，实现一个类似 Google Guava EventBus 的通用框架，对观察者模式进行封装，让其在项目中使用更简便。</p>\\n<p>EventBus 项目地址：<a href=\\"https://github.com/AruNi-01/DesignPattern/tree/main/dp/src/observer/eventbus\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">https://github.com/AruNi-01/DesignPattern/tree/main/dp/src/observer/eventbus</a></p>\\n<p>Guava 地址：<a href=\\"https://github.com/google/guava\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">https://github.com/google/guava</a> ，直接下载 jar 包添加进自定义的目录，然后将该目录 Add as Library 即可使用，或者使用 Maven 亦可。</p>\\n</div>","autoDesc":true}');export{e as data};
