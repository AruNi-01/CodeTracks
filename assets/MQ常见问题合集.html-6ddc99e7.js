import{_ as i}from"./plugin-vue_export-helper-c27b6911.js";import{r as a,o as g,c as p,e as t,b as r,w as e,d as o,a as l}from"./app-70e0ac83.js";const c={},d={class:"hint-container details"},u=t("summary",null,"本文内容",-1),h={class:"table-of-contents"},f=l('<h2 id="为什么要使用-mq" tabindex="-1"><a class="header-anchor" href="#为什么要使用-mq" aria-hidden="true">#</a> 为什么要使用 MQ？</h2><p>MQ 主要有下面几个作用，这也是为什么要使用 MQ 的原因：</p><ul><li><strong>异步处理</strong>：当业务需要处理的逻辑非常多的时候，可以 <strong>把一些用户不关心的、耗时的逻辑丢到 MQ 中做异步处理</strong>，从而尽快将结果返回给用户；</li><li><strong>业务解耦</strong>：在我的抽奖系统中，可以将抽奖和发奖解耦开来，用户抽奖后，直接返回奖品信息，具体的奖品类型是什么，应该怎么发放，后续由 MQ 去执行，最后将结果持久化到 DB 即可；</li><li><strong>流量削峰</strong>：当并发量过大时，可以利用 MQ 进行缓解。在我的校园社区项目中，发送系统通知就是用 MQ 来削峰的，避免在点赞、评论、私信消息过多时，影响系统性能。</li></ul><h2 id="如何设计一个-mq" tabindex="-1"><a class="header-anchor" href="#如何设计一个-mq" aria-hidden="true">#</a> 如何设计一个 MQ？</h2><p>要设计一个消息队列，可以从一下几个方面来考虑：</p><ul><li><strong>保证消息的可靠</strong>：可以设置 <strong>ACK 机制、消息的超时重传</strong> 等，避免消息丢失；</li><li><strong>消息的持久化机制</strong>：为了防止进程挂掉后消息的丢失，需要做消息的持久化，这个持久化最好是采用 <strong>顺序写</strong>，提高持久化性能；</li><li><strong>保证 MQ 的高可用</strong>：当一个 MQ 崩溃时，要保证整个 MQ 是可用的，所以需要使用 <strong>多副本机制</strong> 来保证；</li><li><strong>支持 MQ 的伸缩</strong>：MQ 需要具备随时扩容的能力，以保证在消息量激增时及时提高吞吐量和容量。所以需要设计一个 <strong>分布式的 MQ</strong>；</li><li><strong>高性能</strong>：要设计一个高性能的 MQ，可以参考 Kafka 的设计架构，一个 broker 下可以设置多个 topic，一个 topic 又有多个 partition，多个 concumer 可以组成一个消费者组，一个分区由一个组内的消费者进行消费。通过这样设计，一个 topic 中的消息可以在多个 partition 中，<strong>由多个消费者并行消费，大大增加了吞吐量</strong>。</li></ul><p>参考 Kafka 的基础架构：</p><p><img src="https://run-notes.oss-cn-beijing.aliyuncs.com/notes/202306171306464.png" alt="image-20230617130658294" loading="lazy"></p><h2 id="消息积压问题" tabindex="-1"><a class="header-anchor" href="#消息积压问题" aria-hidden="true">#</a> 消息积压问题</h2><p>出现 <strong>消息积压问题</strong> 主要是由于 <strong>消费者出现故障、消费者执行了耗时的操作（比如操作 DB 遇到了性能瓶颈）、消费速度跟不上生产速度</strong> 等原因造成的。</p><p>一般消息积压问题是从消费者层面来解决，因为生产者对接的是上游业务，是不能轻易改动的。常见的 <strong>解决方案</strong> 有如下：</p><ul><li><strong>扩容增加消费速度</strong>，增加节点数量或将 Partition 和 Consumer 的数量增加到原来的 X 倍（取决于具体情况），让积压的消息尽快消费完毕，后续在恢复成原来的；</li><li><strong>消息先抛后补</strong>，当积压严重时，MQ 都快打满了，为了保证系统的可用性，需要进行消息抛弃（新建消费者来获取消息丢弃），后续在流量低的时候再补回来；</li><li><strong>合并消费消息</strong>，如果有些消息可以合并消费的，可以丢到一个消息中进行消费，以提高消费速度（减少网络传输、减少 IO 操作等）。</li></ul><h2 id="顺序消费问题" tabindex="-1"><a class="header-anchor" href="#顺序消费问题" aria-hidden="true">#</a> 顺序消费问题</h2><div class="hint-container tip"><p class="hint-container-title">保证局部有序—同 partition 下的消息</p></div><p>对于需要顺序消费的消息，可以指定一个 key，对于相同的 key，Kafka 能保证它们被分发到同一个 partition 中。</p><p><strong>为什么会乱序</strong>：</p><ul><li>对于 Kafka 来说，同 partition 下的消息消费是可以保证顺序消费的，但为了增加吞吐量，<strong>消费者一般都是使用多线程进行消费</strong>，这就会导致乱序。</li></ul><p><strong>解决方案</strong>：</p><ul><li>既然是多线程消费导致乱序，而让一个线程只处理一个消费者吞吐量又太低，那么可以加一个 中间层——内存队列。一个消费者对应多个内存队列，每个线程只消费一个内存队列，将消费者中具有相同 key 的数据放到同一个内存队列进行消费，以此来保证有序。<br> 这样既可以保证并发消费消息，也能保证有序。</li></ul><p><strong>示意图</strong>：</p><p><img src="https://run-notes.oss-cn-beijing.aliyuncs.com/notes/202306192139248.png" alt="image-20230619213906771" loading="lazy"></p><div class="hint-container tip"><p class="hint-container-title">保证全局有序—同 topic 下的消息</p></div><p><strong>为什么会乱序</strong>：</p><ul><li>生产者生产的消息会被分发到不同的 partition，而 <strong>不同的 partition 由不同的消费者进行消费，不同的消费者又有多个线程进行处理</strong>，所以如果在不指定一个 key 的情况下，很容易就会发生乱序。</li></ul><p><strong>解决方案</strong>：</p><ul><li>在这种情况下，就只能 <strong>将 topic-partition-consumer-线程都设置成一比一的对应关系</strong>，才能保证消息的有序性。</li></ul><h2 id="如何解决幂等问题" tabindex="-1"><a class="header-anchor" href="#如何解决幂等问题" aria-hidden="true">#</a> 如何解决幂等问题？</h2>',27),_={href:"https://aruni.me/docs/studynotes/middleware/mq/common_question/%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%B6%88%E6%81%AF%E5%B9%82%E7%AD%89.html",target:"_blank",rel:"noopener noreferrer"},m=l('<h2 id="高可用性—多副本机制" tabindex="-1"><a class="header-anchor" href="#高可用性—多副本机制" aria-hidden="true">#</a> 高可用性—多副本机制</h2><p>拿 Kafka 举例：Kafka 提供的 <strong>多副本机制</strong> 主要用来提高 MQ 集群的 <strong>高可用性</strong>，这也是它能成为一个天然分布式 MQ 的重要原因。</p><p>在 Kafka 中，一个 topic 中的数据可以分发到多个 partition 中，这些 partition 可以分布到不同的 broker 上，<strong>此时还不能保证高可用</strong>，因为 <strong>一个 broker 宕机会导致这个 partition 的消息不可用</strong>。</p><p>为了避免这种情况，Kafka 提出了 <strong>多副本机制</strong>，即 <strong>broker 上的每个 partition 在其他 broker 中会形成多个副本，Kafka 会均匀的将这些副本分散到不同的 broker 中</strong>，以提高容错性。</p><p>既然有了副本，就会涉及到 <strong>数据一致性问题</strong>，Kafka 为了降低复杂度，采用了 <strong>leader-follower 模式</strong>，在实际生产和消费时，都是和 leader 进行交互，然后 leader 会同步消息给 follower。当 leader 不可用时，才会轮到 follower 上场（在其中选出一个 leader）。</p><p><strong>leader 读写细节</strong>：</p><ul><li><p>写数据时，生产者只向 leader 写，leader 会将数据写入磁盘，其他 follower 会主动 pull 数据。follower 完成数据同步后，会发送 ack 给 leader，leader 接收到所有 follower 的 ack 后，才会返回写成功的消息给生产者。</p><blockquote><p>这是 ISR（In-Sync Replicas）模式，可用性更高；如果你想让延迟更低，可以损失一点可用性，那么可以选择非 ISR（Out-of-Sync Replicas）模式，此模式不会等到 follower 都确认后才返回写成功。</p></blockquote></li><li><p>读数据时，消费者也只向 leader 读，同样地，只有当这条消息已经被所有 follower 同步成功后，才会被消费者读到。</p></li></ul><h2 id="未完待续" tabindex="-1"><a class="header-anchor" href="#未完待续" aria-hidden="true">#</a> 未完待续...</h2>',8);function k(M,Q){const n=a("router-link"),s=a("ExternalLinkIcon");return g(),p("div",null,[t("details",d,[u,t("nav",h,[t("ul",null,[t("li",null,[r(n,{to:"#为什么要使用-mq"},{default:e(()=>[o("为什么要使用 MQ？")]),_:1})]),t("li",null,[r(n,{to:"#如何设计一个-mq"},{default:e(()=>[o("如何设计一个 MQ？")]),_:1})]),t("li",null,[r(n,{to:"#消息积压问题"},{default:e(()=>[o("消息积压问题")]),_:1})]),t("li",null,[r(n,{to:"#顺序消费问题"},{default:e(()=>[o("顺序消费问题")]),_:1})]),t("li",null,[r(n,{to:"#如何解决幂等问题"},{default:e(()=>[o("如何解决幂等问题？")]),_:1})]),t("li",null,[r(n,{to:"#高可用性—多副本机制"},{default:e(()=>[o("高可用性—多副本机制")]),_:1})]),t("li",null,[r(n,{to:"#未完待续"},{default:e(()=>[o("未完待续...")]),_:1})])])])]),f,t("p",null,[o("具体看 "),t("a",_,[o("如何保证消息幂等"),r(s)]),o("。")]),m])}const y=i(c,[["render",k],["__file","MQ常见问题合集.html.vue"]]);export{y as default};
