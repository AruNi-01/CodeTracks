import{_ as c}from"./plugin-vue_export-helper-c27b6911.js";import{r as o,o as l,c as r,b as n,e as a,w as t,d as s,a as p}from"./app-dac29861.js";const d={},u={class:"hint-container details"},g=n("summary",null,"本文内容",-1),k={class:"table-of-contents"},_=p('<div class="hint-container info"><p class="hint-container-title">前言</p><p>讲到索引优化的方式时，一般都会有索引覆盖和索引条件下推，那么这两个到底是什么？又是如何提高查询效率的？它们又有什么区别？</p></div><h2 id="_1-索引覆盖" tabindex="-1"><a class="header-anchor" href="#_1-索引覆盖" aria-hidden="true">#</a> <strong>1. 索引覆盖</strong></h2><h3 id="_1-1-什么是索引覆盖" tabindex="-1"><a class="header-anchor" href="#_1-1-什么是索引覆盖" aria-hidden="true">#</a> <strong>1.1 什么是索引覆盖</strong></h3><p>索引覆盖针对的是 <strong>二级索引</strong>（辅助索引），指 <strong>从辅助索引中就可以得到查询所需的字段，而不需要通过回表去聚簇索引中查询</strong>。</p><p>因为 <strong>辅助索引中只包含索引列和主键</strong>，所以其一条记录占用的大小要远远小于聚簇索引，那么 <strong>一页中就可以保存更多条记录</strong>，因此可以 <strong>减少大量的 IO 操作</strong>（磁盘扫描区间小）。</p><p>如果优化器进行了索引覆盖，那么在执行计划中的 Extra 列就会显示 Using index。</p><h3 id="_1-2-案例" tabindex="-1"><a class="header-anchor" href="#_1-2-案例" aria-hidden="true">#</a> <strong>1.2 案例</strong></h3><p>Demo 表的设计很简单，如下：</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> <span class="token identifier"><span class="token punctuation">`</span>idx_demo<span class="token punctuation">`</span></span>  <span class="token punctuation">(</span>\n  <span class="token identifier"><span class="token punctuation">`</span>id<span class="token punctuation">`</span></span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span>\n  <span class="token identifier"><span class="token punctuation">`</span>a<span class="token punctuation">`</span></span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span>\n  <span class="token identifier"><span class="token punctuation">`</span>b<span class="token punctuation">`</span></span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span>\n  <span class="token identifier"><span class="token punctuation">`</span>c<span class="token punctuation">`</span></span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span>\n  <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span><span class="token identifier"><span class="token punctuation">`</span>id<span class="token punctuation">`</span></span><span class="token punctuation">)</span><span class="token punctuation">,</span>\n  <span class="token keyword">INDEX</span> <span class="token identifier"><span class="token punctuation">`</span>idx_a_b<span class="token punctuation">`</span></span><span class="token punctuation">(</span><span class="token identifier"><span class="token punctuation">`</span>a<span class="token punctuation">`</span></span><span class="token punctuation">,</span> <span class="token identifier"><span class="token punctuation">`</span>b<span class="token punctuation">`</span></span><span class="token punctuation">)</span>\n<span class="token punctuation">)</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>主键索引：id；</li><li>联合索引 idx_a_b：a, b；</li></ul>',10),h={href:"https://code.0x3f4.run/backend/database/mysql/index/%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92%E4%B9%8Bexplain.html",target:"_blank",rel:"noopener noreferrer"},b=p(`<div class="hint-container info"><p class="hint-container-title">SQL 语句一：</p><p><code>explain select * from idx_demo;</code></p><p><img src="https://run-notes.oss-cn-beijing.aliyuncs.com/notes/202302161751457.png" alt="image-20230216175151418" loading="lazy"></p><p>毫无疑问，使用了全表扫描。因为我们要查询所有的字段，走联合索引的话没有字段 <code>c</code>，是需要回表的。</p></div><div class="hint-container info"><p class="hint-container-title">SQL 语句二：</p><p><code>explain select id, b from idx_demo;</code></p><p><img src="https://run-notes.oss-cn-beijing.aliyuncs.com/notes/202302161755827.png" alt="image-20230216175504841" loading="lazy"></p><p>可以发现，虽然 possible_keys 为 Null，但是实际上使用到了联合索引 idx_a_b。因为我们要查询的字段 <code>id</code> 和 <code>b</code> 都在联合索引中，扫描辅助索引效率更高，所以使用到了索引覆盖，也可以看见 Extra 列有 Using index。</p></div><div class="hint-container info"><p class="hint-container-title">SQL 语句三：</p><p><code>explain select id, b from idx_demo where a like &#39;%2%&#39;;</code></p><p><img src="https://run-notes.oss-cn-beijing.aliyuncs.com/notes/202302161804097.png" alt="image-20230216180257503" loading="lazy"></p><p>可能乍一看 <code>like &#39;%2%&#39;</code> 会认为索引失效了，需要走全表扫描。但是，我们要查询的字段可以用到索引覆盖，所以还是使用了联合索引 idx_a_b。</p><p>可以看到 type 列为 index，即全索引扫描，虽然此扫描方式效率也较低，但是还是比全表扫描好。</p><blockquote><p>因此我们在判断一条查询语句走没走索引时，不要只顾及索引生不生效，还要多注意索引覆盖的情况。</p></blockquote></div><h2 id="_2-索引条件下推" tabindex="-1"><a class="header-anchor" href="#_2-索引条件下推" aria-hidden="true">#</a> <strong>2. 索引条件下推</strong></h2><h3 id="_2-1-什么是索引条件下推" tabindex="-1"><a class="header-anchor" href="#_2-1-什么是索引条件下推" aria-hidden="true">#</a> <strong>2.1 什么是索引条件下推</strong></h3><p>索引条件下推（ICP：Index Condition Pushdown）是 MySQL 5.6 开始支持的，它也是针对 <strong>二级索引</strong>（辅助索引）的。</p><p>ICP 的提出只是为了 <strong>尽量减少二级索引在查询时回表的次数，从而减少 IO 操作</strong>。而聚簇索引不需要回表，它本身就包含所有的字段，所以 MySQL 规定 ICP 只适用于二级索引。</p><p>如果使用了 ICP，那么在执行计划中的 Extra 列就会显示 Using index condition。</p><p>下面通过例子来说明 ICP 是如何减少回表次数的，看完了下面的例子，你也就明白了什么是 ICP。</p><p>同样使用上面索引覆盖的 Demo 表，该表只有一个主键索引和一个联合索引 idx_a_b (a, b)。</p><p>我们的示例 SQL 如下：</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> idx_demo <span class="token keyword">where</span> a <span class="token operator">&gt;</span> <span class="token number">1</span> <span class="token operator">and</span> b <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><blockquote><p>联合索引遇到范围查询会停止匹配，所以上面的语句中只有 <code>a</code> 可以用到联合索引，<code>b</code> 是无法走联合索引的。</p><p>因为该联合索引是优先根据 <code>a</code> 排序，只有 <code>a</code> 相同时才根据 <code>b</code> 排序，所以当 <code>a</code> 有序时，<code>b</code> 不一定有序。</p></blockquote><p>MySQL 是分为 Server 层和存储引擎层的。在 <strong>没有 ICP</strong> 时，优化器生成执行计划后，Server 层和存储引擎层是这样查询的：</p><ol><li><p>Server 层调用存储引擎的接口，以获取记录；</p></li><li><p>存储引擎定位到满足 <code>a &gt; 1</code> 的第一条二级索引记录后，根据该二级索引记录的主键值进行回表，将完整的记录返回给 Server 层；</p><blockquote><p>注意：定位到记录后，如果没有 ICP，<code>b</code> 字段又无法走索引，所以会直接先进行回表，我们需要查询全部记录。</p></blockquote></li><li><p>Server 层再判断其他搜索条件是否成立（即 <code>b = 2</code>），如果成立则发给客户端，否则跳过该记录，然后向存储引擎层要下一条记录；</p></li><li><p>获取到下一条记录后，又要先执行回表，然后 Server 层再判断搜索条件；</p></li><li><p>如此重复，直到将 <code>a &gt; 1</code> 的记录都读取完；</p></li></ol><p>从上面的步骤可以看出，每次都需要回表后，才能进行搜索条件的判断。但是我们的 <strong>搜索条件 <code>a &gt; 1</code> 和 <code>b = 2</code> 都是包含在联合索引里面的</strong>，所以，MySQL 对上面的执行步骤进行了改进：</p><ol><li><p>Server 层调用存储引擎的接口，以获取记录；</p></li><li><p>存储引擎定位到满足 <code>a &gt; 1</code> 的第一条二级索引记录后，<strong>不着急执行回表</strong>，而是 <strong>先判断关于联合索引 idx_a_b 中包含的列的条件是否满足</strong>，也就是 <code>a &gt; 1 and b = 2</code>（a，b 都是联合索引 idx_a_b 中的列）：</p><ul><li>如果条件 <strong>不成立</strong>，则直接 <strong>跳过该二级索引记录</strong>，然后去寻找下一条记录；</li><li>如果条件 <strong>成立</strong>，<strong>才执行回表</strong>，将完整的记录返回给 Server 层（此时 Server 层就不需要判断联合索引中包含的列的条件了）。</li></ul></li><li><p>Server 层再判断其他搜索条件是否成立（本例中没有其他条件了），如果成立则发给客户端，否则跳过该记录，然后向存储引擎层要下一条记录；</p><blockquote><p>注意：有了 ICP 后，Server 只需要判断除联合索引列之外的列条件。</p></blockquote></li><li><p>如此重复，直到将 <code>a &gt; 1</code> 的记录都读取完；</p></li></ol><p>可以发现，有了 ICP 后，<strong>即使联合索引的 <code>b</code> 列无法使用到联合索引，但是它包含在联合索引里面，所以直接在存储引擎层就先进行判断了，满足后才执行回表操作，否则就直接寻找下一条记录</strong>。所以 <strong>减少了很多回表次数</strong>。</p><p>一句话总结 ICP：<strong>二级索引查询时</strong>，存储引擎层定位到一条记录后，就会顺便判断 <strong>属于该二级索引的列的搜索条件</strong> 是否满足，不满足则直接取下一条记录。</p><p>也就是说，<strong>没有 ICP 时，即使是属于该二级索引的列不满足搜索条件时，也需要进行回表</strong>。不过如果判断条件中还有其他不属于该二级索引的列时，也是需要回表后再在 Server 层进行判断的。</p><h3 id="_2-2-案例" tabindex="-1"><a class="header-anchor" href="#_2-2-案例" aria-hidden="true">#</a> <strong>2.2 案例</strong></h3><p>还是使用上面的 Demo 表，用一个例子来看看你到底掌握 ICP 没有。</p><p>SQL 语句：<code>explain select * from idx_demo where a &gt; 1 and b like &#39;%2%&#39; and c &gt; 2;</code></p><p><img src="https://run-notes.oss-cn-beijing.aliyuncs.com/notes/202302162006311.png" alt="image-20230216194115231" loading="lazy"></p><p>搜索条件 <code>a &gt; 1</code> 用来形成扫描区间 (1, +∞)，<code>b</code> 无法走联合索引，<code>c</code> 字段不在联合索引中，也无法走联合索引。</p><p>存储引擎在定位到一条记录后，会先判断属于联合索引的列的搜索条件是否满足（即 <code>a &gt; 1 and b like &#39;%2%&#39;</code>），满足后才会进行回表，然后将完整记录返回 Server 层，由于本例中还有一个搜索条件 <code>c &gt; 2</code> 不在联合索引中，所以 Server 层还需要判断一下，所以看到 Extra 中还有 Using where（某个搜索条件需要到 Server 层进行判断）。</p><p>虽然上面的例子走联合索引时，在存储引擎判断了搜索条件后，在 Server 层还要判断，但是 <strong>ICP 让很多联合索引列不满足搜索条件的记录无需回表</strong>，大大增加了效率。</p><h2 id="_3-总结" tabindex="-1"><a class="header-anchor" href="#_3-总结" aria-hidden="true">#</a> <strong>3. 总结</strong></h2><p>索引覆盖和 ICP 都是针对 <strong>二级索引</strong> 的，而且都能有效 <strong>减少回表次数</strong>。</p><p>但是它们也有区别：</p><ul><li>索引覆盖主要看 <strong>查询的字段</strong>，即 select 后面的字段。主要通过 <strong>查询字段在联合索引中就存在</strong> 来减少回表；</li><li>而 ICP 主要看 <strong>搜索条件</strong>，即 where 后面的条件。主要通过 <strong>搜索条件在联合索引中就存在</strong> 来减少回表；</li><li>使用了索引覆盖执行计划的 Extra 列会显示 Using index；而 ICP 则是 Using index condition。</li></ul><h2 id="_4-参考文章" tabindex="-1"><a class="header-anchor" href="#_4-参考文章" aria-hidden="true">#</a> <strong>4. 参考文章</strong></h2><ul><li>《MySQL 是怎样运行的》</li><li>《MySQL 技术内幕：InnoDB 存储引擎》</li></ul>`,33);function m(v,x){const e=o("router-link"),i=o("ExternalLinkIcon");return l(),r("div",null,[n("details",u,[g,n("nav",k,[n("ul",null,[n("li",null,[a(e,{to:"#_1-索引覆盖"},{default:t(()=>[s("1. 索引覆盖")]),_:1}),n("ul",null,[n("li",null,[a(e,{to:"#_1-1-什么是索引覆盖"},{default:t(()=>[s("1.1 什么是索引覆盖")]),_:1})]),n("li",null,[a(e,{to:"#_1-2-案例"},{default:t(()=>[s("1.2 案例")]),_:1})])])]),n("li",null,[a(e,{to:"#_2-索引条件下推"},{default:t(()=>[s("2. 索引条件下推")]),_:1}),n("ul",null,[n("li",null,[a(e,{to:"#_2-1-什么是索引条件下推"},{default:t(()=>[s("2.1 什么是索引条件下推")]),_:1})]),n("li",null,[a(e,{to:"#_2-2-案例"},{default:t(()=>[s("2.2 案例")]),_:1})])])]),n("li",null,[a(e,{to:"#_3-总结"},{default:t(()=>[s("3. 总结")]),_:1})]),n("li",null,[a(e,{to:"#_4-参考文章"},{default:t(()=>[s("4. 参考文章")]),_:1})])])])]),_,n("blockquote",null,[n("p",null,[s("下面会使用到 explain 的知识，如果你还不知道什么是 explain，建议先看 "),n("a",h,[s("执行计划之 explain"),a(i)])])]),b])}const S=c(d,[["render",m],["__file","索引覆盖和索引条件下推.html.vue"]]);export{S as default};
