import{_ as l}from"./plugin-vue_export-helper-c27b6911.js";import{r as i,o as c,c as r,a as n,d as e,w as t,b as s,e as o}from"./app-fff4f215.js";const d={},u={class:"hint-container details"},k=n("summary",null,"本文内容",-1),g={class:"table-of-contents"},_=o('<h2 id="_1-介绍" tabindex="-1"><a class="header-anchor" href="#_1-介绍" aria-hidden="true">#</a> <strong>1. 介绍</strong></h2><p>MySQL 在执行查询 SQL 语句时，优化器会基于成本来生成多个执行方案，最后会选择一个成本最低的方案来生成执行计划。</p><p>如果我们想看看这个执行计划，比如用什么方式访问的表、用到了哪个索引等，可以使用 MySQL 提供的 <strong>explain</strong> 命令。</p><p>在实际开发中，如果我们的 SQL 查询效率很低，那么就可以使用 explain 命令看看具体的执行计划，从而分析存在什么问题，是没有建立索引，还是索引失效等等情况。</p><p>explain 命令的使用非常简单，只需要在 SQL 的前面加上 explain 即可，例如：</p><p><img src="https://run-notes.oss-cn-beijing.aliyuncs.com/notes/202302152140345.png" alt="image-20230215214032453" loading="lazy"></p><p>输出的这一大堆东西就是执行计划，接下来就一起来看看它们到底都代表什么。</p><blockquote><p>当然，其余的 insert、delete、update 语句的前面也都可以加上 explain，只不过在查询中使用得比较多。</p></blockquote><h2 id="_2-执行计划的各列" tabindex="-1"><a class="header-anchor" href="#_2-执行计划的各列" aria-hidden="true">#</a> <strong>2. 执行计划的各列</strong></h2><p>先来大致的介绍以下每一列都代表什么意思，然后详细讲解几个比较重要的列。</p><p>在上面输出的执行计划中，各列的含义如下：</p><ul><li><code>id</code>：查询语句对应的唯一 id，每个 select 语句都会有；</li><li><code>select_type</code>：查询的类型；</li><li><code>table</code>：表名，如果两个表进行连表查询，则会输出两个表的执行计划（前面的是驱动表，后面的是被驱动表；</li><li><code>partitions</code>：匹配的区分信息；</li><li><code>type</code>：针对单表的访问方法；</li><li><code>possible_keys</code>：可能会用到的索引；</li><li><code>key</code>：实际用到的索引；</li><li><code>key_len</code>：实际用到的索引的长度；</li><li><code>ref</code>：当使用索引列进行等值查询时，与索引列进行等值匹配的对象信息；</li><li><code>rows</code>：预估的需要读取的记录条数；</li><li><code>filtered</code>：经过搜索条件过滤后，剩余记录条数的百分比；</li><li><code>Extra</code>：一些额外的信息。</li></ul><p>我这里只会挑几个常见且重要的列来讲解，其余的列详情可以查看《MySQL 是怎样运行的》这本书。</p><h3 id="_2-1-type" tabindex="-1"><a class="header-anchor" href="#_2-1-type" aria-hidden="true">#</a> <strong>2.1 type</strong></h3><p><code>type</code> 列代表 MySQL 对某个表执行查询时的 <strong>扫描方式</strong>，常见的扫描方式如下（执行效率从高到底）：</p><ul><li><code>const</code>：执行 <strong>单表查询</strong> 时，<strong>主键或唯一二级索引等值查询</strong>；</li><li><code>eq_ref</code>：执行 <strong>连接查询</strong> 时，<strong>主键或唯一二级索引等值查询</strong>；</li><li><code>ref</code>：<strong>非唯一索引等值查询</strong>；</li><li><code>range</code>：<strong>索引范围扫描</strong>；</li><li><code>index</code>：<strong>全索引扫描</strong>；</li><li><code>ALL</code>：<strong>全表扫描</strong>。</li></ul><p>const 类型和 eq_ref 都属于 <strong>主键或唯一二级索引的等值查询</strong>，但是 <strong>const 是针对单表的，查询效率更快。而 eq_ref 常用在多表联查中</strong>。</p><p>ref 类型表示 <strong>非唯一索引的等值查询</strong>，虽然也是等值查询，但是 <strong>索引列可能会有重复</strong>，所以会在一个小范围（范围大小对应该索引值的重复条数）进行扫描。</p><p>range 表示 <strong>索引范围扫描</strong>，一般就是在 where 后面使用 &gt;、&lt;、in、between 等。<strong>从 range 开始往下，索引的效率会越来越低</strong>，所以尽量不要到达这一级别，更不要到达 range 以下的级别。</p><p>index 虽然也使用了索引，但是 <strong>对索引进行了全扫描</strong>，开销也很大。</p><p>ALL 是最坏情况，采用 <strong>全表扫描</strong>，是性能最差的扫描方式。</p><h3 id="_2-2-possible-keys-和-key" tabindex="-1"><a class="header-anchor" href="#_2-2-possible-keys-和-key" aria-hidden="true">#</a> <strong>2.2 possible_keys 和 key</strong></h3><p><strong>possible_keys</strong> 表示对表执行单表查询时 <strong>可能会用到的索引有哪些</strong>，而 <strong>key</strong> 则表示 <strong>实际上用到的索引是哪个</strong>。</p><p>因为优化器是基于成本来选择执行计划的，使用了哪个索引就说明用此索引进行查询的成本是最低的。</p><p>不过需要注意，<strong>possible_keys 并不是越多越好</strong>，可能会用到的索引越多，那么优化器在计算查询成本时所花费的时间也就越长。所以要尽量删除掉一些不用的索引。</p><h3 id="_2-3-ref" tabindex="-1"><a class="header-anchor" href="#_2-3-ref" aria-hidden="true">#</a> <strong>2.3 ref</strong></h3><blockquote><p>注意与 type 列的 ref 进行区分。</p></blockquote><p>当使用 const、eq_ref、ref 中的一个扫描方式时，<strong>ref 列</strong> 展示的就是 <strong>与索引列进行等值匹配的东西是什么</strong>：</p><ul><li>如果是一个常数，则 ref 列为 <code>const</code>（注意与 type 列的 const 进行区分）；</li><li>如果是某个字段，则 ref 列就为这个字段；</li><li>如果是一个函数，则 ref 列为 <code>func</code>，比如 UPPER、LOWER、CONCAT 等。</li></ul><h3 id="_2-4-rows" tabindex="-1"><a class="header-anchor" href="#_2-4-rows" aria-hidden="true">#</a> <strong>2.4 rows</strong></h3><p>rows 列表示 <strong>预计扫描的记录行数</strong>，注意是 <strong>预计</strong>。</p><p>为什么是预计呢？可以想象一下，如果需要通过扫描所有的记录行数，才能获取扫描的记录行数，那么在优化器选择执行计划的时候，消耗的时间也就太长了。</p><p>所以为了减少扫描时间，<strong>优化器会根据一个规则来估算需要扫描的记录行数</strong>。所以 <strong>explain 的效执行率也是很高的</strong>。</p><p>这个规则如下：</p><ul><li><p>根据第一个记录所在的页和最后一个记录所在的页，再从第一个记录所在页向右连续查找<br> 8 个页，总共 10 个页，获取这 10 个页的总记录数，再除以 10 取平均值，即可得到一个页中记录的平均值，最后乘总的页数目，即可得到一个不精确的总记录数。</p><blockquote><p>页是 InnoDB 管理存储空间的基本单位，一个页默认为 16KB。</p></blockquote></li></ul><h3 id="_2-5-extra" tabindex="-1"><a class="header-anchor" href="#_2-5-extra" aria-hidden="true">#</a> <strong>2.5 Extra</strong></h3><p>Extra 顾名思义，表示一些额外的信息。虽然它叫 Extra，但它一点也不多余，这些额外信息是精准判断执行计划的关键。</p><p>几个常见且重要的 Extra 信息如下：</p>',38),y=o("<li><p><strong>Using index</strong>：<strong>索引覆盖</strong>。表示在二级索引中即可获取到需要查询的记录，不需要再进行回表，增加了效率；</p></li><li><p><strong>Using filesort</strong>：<strong>对结果使用排序算法进行排序，可能会通过文件排序</strong>，效率是很低的。当我们在使用 order by 对结果排序时，如果无法利用索引完成排序操作，就会使用 filesort；</p><blockquote><p>注意：<strong>MySQL 会在 group by 中默认使用 order by</strong>。</p></blockquote></li><li><p><strong>Using temporary</strong>：<strong>使用了临时表保存中间结果</strong>。常见于 distinct 和 order by，如果无法利用索引来去重或者排序，则需要使用临时表；</p></li>",3),h=n("strong",null,"Using index condition",-1),f=n("strong",null,"索引条件下推",-1),b={href:"https://aruni.me/studynotes/database/mysql/%E7%B4%A2%E5%BC%95%E8%A6%86%E7%9B%96%E5%92%8C%E7%B4%A2%E5%BC%95%E6%9D%A1%E4%BB%B6%E4%B8%8B%E6%8E%A8.html",target:"_blank",rel:"noopener noreferrer"},x=n("li",null,[n("p",null,[n("strong",null,"Using where"),s("："),n("strong",null,"某个搜索条件需要到 server 层进行判断"),s("。")])],-1),m=o('<h2 id="_3-实战分析" tabindex="-1"><a class="header-anchor" href="#_3-实战分析" aria-hidden="true">#</a> <strong>3. 实战分析</strong></h2><p>explain 输入列中常见的列都已经过了一遍，现在来几条正真的 SQL 语句，分析下它们的执行计划。</p><p>使用的 Demo 表设计如下：</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> <span class="token identifier"><span class="token punctuation">`</span>explain_example<span class="token punctuation">`</span></span>  <span class="token punctuation">(</span>\n  <span class="token identifier"><span class="token punctuation">`</span>id<span class="token punctuation">`</span></span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span>\n  <span class="token identifier"><span class="token punctuation">`</span>key<span class="token punctuation">`</span></span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span>\n  <span class="token identifier"><span class="token punctuation">`</span>uk_key<span class="token punctuation">`</span></span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span>\n  <span class="token identifier"><span class="token punctuation">`</span>key_part1<span class="token punctuation">`</span></span> <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">255</span><span class="token punctuation">)</span><span class="token punctuation">,</span>\n  <span class="token identifier"><span class="token punctuation">`</span>key_part2<span class="token punctuation">`</span></span> <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">255</span><span class="token punctuation">)</span><span class="token punctuation">,</span>\n  <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span><span class="token identifier"><span class="token punctuation">`</span>id<span class="token punctuation">`</span></span><span class="token punctuation">)</span><span class="token punctuation">,</span>\n  <span class="token keyword">UNIQUE</span> <span class="token keyword">INDEX</span> <span class="token identifier"><span class="token punctuation">`</span>idx_uk_key<span class="token punctuation">`</span></span><span class="token punctuation">(</span><span class="token identifier"><span class="token punctuation">`</span>uk_key<span class="token punctuation">`</span></span><span class="token punctuation">)</span><span class="token punctuation">,</span>\n  <span class="token keyword">INDEX</span> <span class="token identifier"><span class="token punctuation">`</span>idx_key<span class="token punctuation">`</span></span><span class="token punctuation">(</span><span class="token identifier"><span class="token punctuation">`</span>key<span class="token punctuation">`</span></span><span class="token punctuation">)</span><span class="token punctuation">,</span>\n  <span class="token keyword">INDEX</span> <span class="token identifier"><span class="token punctuation">`</span>idx_key_part<span class="token punctuation">`</span></span><span class="token punctuation">(</span><span class="token identifier"><span class="token punctuation">`</span>key_part1<span class="token punctuation">`</span></span><span class="token punctuation">,</span> <span class="token identifier"><span class="token punctuation">`</span>key_part2<span class="token punctuation">`</span></span><span class="token punctuation">)</span>\n<span class="token punctuation">)</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>主键索引：id；</li><li>唯一索引 idx_uk_key：uk_key；</li><li>非唯一索引 idx_key：key；</li><li>联合索引 idx_key_part：key_part1，key_part2；</li></ul><div class="hint-container info"><p class="hint-container-title">SQL 语句一：</p><p><code>explain select * from explain_example where uk_key = 1;</code></p><p><img src="https://run-notes.oss-cn-beijing.aliyuncs.com/notes/202302152343257.png" alt="image-20230215234326642" loading="lazy"></p><ul><li>扫描方式 type 是 const，因为这里是唯一索引的等值扫描；</li><li>等值的条件是一个常数，索引 ref 为 const。</li></ul></div><div class="hint-container info"><p class="hint-container-title">SQL 语句二：</p><p><code>explain select * from explain_example where key_part2 = &#39;b&#39;;</code></p><p><img src="https://run-notes.oss-cn-beijing.aliyuncs.com/notes/202302152354725.png" alt="image-20230215235428280" loading="lazy"></p><ul><li>联合索引为 idx_key_part(key_part1, key_part2)，很明显 <code>where key_part2 = &#39;b&#39;</code> 不满足最左前缀匹配原则，索引失效。所以使用的是全表扫描 ALL，possible_keys 和 key 也都是 Null。</li><li>Extra 为 Using where，因为使用不到 ICP（ICP 只适用于二级索引，这里是全表扫描，用的是聚簇索引），所以查找到一条记录，就要返回 Server 层判断 <code>key_part2</code> 字段是否为 <code>&#39;b&#39;</code>。</li></ul></div><div class="hint-container info"><p class="hint-container-title">SQL 语句三：</p><p><code>explain select * from explain_example where key_part1 &gt; &#39;a&#39; and key_part2 = &#39;2&#39;;</code></p><p><img src="https://run-notes.oss-cn-beijing.aliyuncs.com/notes/202302160000174.png" alt="image-20230216000000235" loading="lazy"></p><blockquote><p><strong>注意</strong>：联合索引遇到范围查询会停止匹配，所以上面的语句中只有 <code>key_part1</code> 可以用到联合索引，<code>key_part2</code> 是无法走联合索引的。</p></blockquote><ul><li><p>扫描方式 type 为 range，因为使用了联合索引 idx_key_part 进行范围扫描；</p></li><li><p>Extra 中为 Using index condition，说明使用到了 ICP。</p><blockquote><p>虽然第二个条件 <code>key_part2 = &#39;2&#39;</code> 使用不到联合索引，但是在查询到 key_part1 时，联合索引中刚好有 key_part2，所以就可以利用 ICP 在存储引擎层进行判断。而不用定位到一条记录后，获取主键，然后进行回表查出 key_part2，再进行判断。</p></blockquote></li></ul></div><div class="hint-container info"><p class="hint-container-title">SQL 语句四：</p><p><code>explain select id from explain_example where uk_key &gt; 2;</code></p><p><img src="https://run-notes.oss-cn-beijing.aliyuncs.com/notes/202302160028938.png" alt="image-20230216002852177" loading="lazy"></p><ul><li>主要看 Extra 中有 Using index，说明使用了索引覆盖。因为 uk_idx_key 索引中有主键 id（二级索引中 B+ 树叶子节点的数据存储的就是主键值），所以就不用去聚簇索引回表查询出 id 了。</li></ul></div><h2 id="_4-参考文章" tabindex="-1"><a class="header-anchor" href="#_4-参考文章" aria-hidden="true">#</a> <strong>4. 参考文章</strong></h2>',10),v=n("li",null,"《MySQL 是怎样运行的》",-1),E={href:"https://xiaolincoding.com/",target:"_blank",rel:"noopener noreferrer"};function w(L,q){const a=i("router-link"),p=i("ExternalLinkIcon");return c(),r("div",null,[n("details",u,[k,n("nav",g,[n("ul",null,[n("li",null,[e(a,{to:"#_1-介绍"},{default:t(()=>[s("1. 介绍")]),_:1})]),n("li",null,[e(a,{to:"#_2-执行计划的各列"},{default:t(()=>[s("2. 执行计划的各列")]),_:1}),n("ul",null,[n("li",null,[e(a,{to:"#_2-1-type"},{default:t(()=>[s("2.1 type")]),_:1})]),n("li",null,[e(a,{to:"#_2-2-possible-keys-和-key"},{default:t(()=>[s("2.2 possible_keys 和 key")]),_:1})]),n("li",null,[e(a,{to:"#_2-3-ref"},{default:t(()=>[s("2.3 ref")]),_:1})]),n("li",null,[e(a,{to:"#_2-4-rows"},{default:t(()=>[s("2.4 rows")]),_:1})]),n("li",null,[e(a,{to:"#_2-5-extra"},{default:t(()=>[s("2.5 Extra")]),_:1})])])]),n("li",null,[e(a,{to:"#_3-实战分析"},{default:t(()=>[s("3. 实战分析")]),_:1})]),n("li",null,[e(a,{to:"#_4-参考文章"},{default:t(()=>[s("4. 参考文章")]),_:1})])])])]),_,n("ul",null,[y,n("li",null,[n("p",null,[h,s("："),f,s("（ICP）。这里就不详细讲解什么是 ICP 了，具体见 "),n("a",b,[s("索引覆盖和索引条件下推"),e(p)]),s("；")])]),x]),m,n("ul",null,[v,n("li",null,[n("a",E,[s("小林 coding"),e(p)])])])])}const Q=l(d,[["render",w],["__file","执行计划之explain.html.vue"]]);export{Q as default};
