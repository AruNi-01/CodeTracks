import{_ as a}from"./plugin-vue_export-helper-c27b6911.js";import{r as e,o as g,c as l,a as t,d as r,w as o,e as i,b as s}from"./app-7b7f9f42.js";const d={},_={class:"hint-container details"},h=t("summary",null,"本文内容",-1),c={class:"table-of-contents"},p=i('<div class="hint-container info"><p class="hint-container-title">前言</p><p>在 Java 中，<strong>几乎所有的对象都分配在堆上</strong>，“几乎” 说明了还是有个别可以不分配到堆上的，那么到底是哪些个别对象呢？这就要涉及到本篇文章要讲的 <strong>逃逸分析</strong> 了。</p></div><h2 id="_1-什么是逃逸分析" tabindex="-1"><a class="header-anchor" href="#_1-什么是逃逸分析" aria-hidden="true">#</a> 1. 什么是逃逸分析？</h2><p><strong>逃逸分析</strong> 其实是 Java 虚拟机中的一种 <strong>优化技术</strong>，也就是说，它只是一种分析技术，<strong>为具体的优化措施提供一种依据</strong>。</p><p>逃逸分析技术的原理是：通过 <strong>分析对象的动态作用域</strong>，来确定一个对象 <strong>在方法中被定义后，是否可能被外部方法所引用</strong>（例如该对象作为参数传递到其他方法中）。</p><p>其实上面这种判断 <strong>是否逃逸到外部方法</strong>，叫 <strong>方法逃逸</strong>，还有一种叫 <strong>线程逃逸</strong>，即一个对象 <strong>可能会被外部线程访问到</strong>（例如将对象赋值给其他线程中可以访问的变量）。</p><p>而如果通过逃逸分析，<strong>能证明一个对象不会逃逸到外部方法，或线程之外（或者说别的方法或线程无法访问到该对象），或者逃逸程度较低（只逃逸出方法，而不逃逸出线程），那么就可以为这个对象采取不同程度的优化</strong>，这些优化包括：</p><ul><li><strong>栈上分配</strong>；</li><li><strong>标量替换</strong>；</li><li><strong>同步消除</strong>。</li></ul><p>下面就来依次看看这三个优化手段。</p><h2 id="_2-栈上分配" tabindex="-1"><a class="header-anchor" href="#_2-栈上分配" aria-hidden="true">#</a> 2. 栈上分配</h2><p>如果通过逃逸分析，能确定一个对象 <strong>不会逃逸出线程之外</strong>，那么就可以让这个对象 <strong>分配在栈上</strong>，这样对象所占用的空间就会 <strong>随着该方法栈帧的出栈而销毁</strong>。</p><p>对象分配在栈上的好处显而易见，可以减少堆中的占用量，从而 <strong>节省 GC 操作所消耗的资源</strong>。因为 GC 会涉及到筛选可回收对象、整理内存等操作。</p><h2 id="_3-标量替换" tabindex="-1"><a class="header-anchor" href="#_3-标量替换" aria-hidden="true">#</a> 3. 标量替换</h2><p><strong>标量指的是无法分解为更小的数据来表示的数据</strong>，例如 int、long。而如果 <strong>一个数据可以继续分解，那么就称为聚合量</strong>，Java 中的 <strong>对象就是典型的聚合量</strong>。</p><p><strong>标量替换指的是把一个对象分解后，将该对象中用到的成员变量恢复为原始类型来访问</strong>。</p><p>如果通过逃逸分析，能确定一个对象 <strong>不会逃逸出方法之外</strong>，并且其 <strong>能被分解</strong>，那么程序执行时就可能 <strong>不去创建该对象</strong>，而是直接 <strong>创建它的若干个被使用的成员变量来代替</strong>。这样就可以让 <strong>该对象的成员变量在栈上分配和读写了</strong>。</p><p>可以看到，标量替换对逃逸程度要求是比较高的，要求不能逃逸出方法之外。</p><h2 id="_4-同步消除" tabindex="-1"><a class="header-anchor" href="#_4-同步消除" aria-hidden="true">#</a> 4. 同步消除</h2><p>学习过并发编程的都知道，<strong>线程同步需要消耗的时间是比较多的</strong>，因为同步涉及到 CAS、或者加锁的开销。</p><p>而如果通过逃逸分析，能确定一个变量 <strong>不会逃逸出线程之外</strong>，也就是 <strong>无法被其他线程访问</strong>，那该变量的读写就不会有竞争，所以就可以 <strong>不对该变量做任何的同步安全措施</strong>，从而大大提高了效率。</p><h2 id="_5-总结" tabindex="-1"><a class="header-anchor" href="#_5-总结" aria-hidden="true">#</a> 5. 总结</h2><p><strong>逃逸分析</strong> 其实是一种分析技术，<strong>为具体的优化措施提供一种依据</strong>。它通过 <strong>分析对象的动态作用域</strong>，来确定一个对象 <strong>在方法中被定义后，是否可能被外部方法所引用</strong>。</p><p>通过逃逸分析，<strong>能证明一个对象不会逃逸到外部方法，或线程之外（或者说别的方法或线程无法访问到该对象），或者逃逸程度较低（只逃逸出方法，而不逃逸出线程），那么就可以为这个对象采取不同程度的优化</strong>，这些优化包括：</p><ul><li><strong>栈上分配</strong>；</li><li><strong>标量替换</strong>；</li><li><strong>同步消除</strong>。</li></ul><p>其中，<strong>栈上分配和标量替换都可以很好的减少对象在堆上的创建</strong>，从而减少了堆中 GC 的资源消耗，而 <strong>同步消除则是确定了变量是线程安全后，消除对该变量的同步措施</strong>，从而提高对该变量的读写效率。</p><h2 id="_6-参考文章" tabindex="-1"><a class="header-anchor" href="#_6-参考文章" aria-hidden="true">#</a> 6. 参考文章</h2><ul><li>《深入理解 Java 虚拟机—第 3 版》</li></ul>',26);function u(f,m){const n=e("router-link");return g(),l("div",null,[t("details",_,[h,t("nav",c,[t("ul",null,[t("li",null,[r(n,{to:"#_1-什么是逃逸分析"},{default:o(()=>[s("1. 什么是逃逸分析？")]),_:1})]),t("li",null,[r(n,{to:"#_2-栈上分配"},{default:o(()=>[s("2. 栈上分配")]),_:1})]),t("li",null,[r(n,{to:"#_3-标量替换"},{default:o(()=>[s("3. 标量替换")]),_:1})]),t("li",null,[r(n,{to:"#_4-同步消除"},{default:o(()=>[s("4. 同步消除")]),_:1})]),t("li",null,[r(n,{to:"#_5-总结"},{default:o(()=>[s("5. 总结")]),_:1})]),t("li",null,[r(n,{to:"#_6-参考文章"},{default:o(()=>[s("6. 参考文章")]),_:1})])])])]),p])}const b=a(d,[["render",u],["__file","逃逸分析.html.vue"]]);export{b as default};
