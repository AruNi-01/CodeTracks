import{_ as l}from"./plugin-vue_export-helper-c27b6911.js";import{r as o,o as c,c as i,b as n,e as a,w as e,d as s,a as u}from"./app-7ee45750.js";const r={},d={class:"hint-container details"},k=n("summary",null,"本文内容",-1),v={class:"table-of-contents"},m=n("h2",{id:"_1-gc-需要回收什么",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#_1-gc-需要回收什么","aria-hidden":"true"},"#"),s(" 1. GC 需要回收什么？")],-1),g={href:"https://code.0x3f4.run/backend/java/jvm/memory_manager/%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%9F%9F.html",target:"_blank",rel:"noopener noreferrer"},b=u(`<ul><li><strong>线程私有</strong>：程序计数器、Java 栈、本地方法栈；</li><li><strong>线程共享</strong>：堆、方法区。</li></ul><p>对于 <strong>线程私有</strong> 的内存区域都是 <strong>随线程而生，随线程而灭</strong>，因此无需过多考虑内存回收的问题。<strong>随着方法或者线程的结束，内存自然就回收掉了</strong>。</p><p>但是对于 <strong>线程共享</strong> 的内存区域，有着很显著的不确定性，<strong>只有在运行时再能确定会创建哪些对象，而且创建出来的对象也不会自己消失</strong>，所以就需要 <strong>垃圾收集器来管理这部分内存</strong>。</p><p>另外，对于方法区来说，由于回收的判定条件非常严苛，垃圾收回的性价比比较低，所以我们重点是看 <strong>Java 堆上的垃圾收回</strong>，尤其是在新生代中，一次垃圾回收通常能清理 70% 到 90% 的内存空间。</p><h2 id="_2-判断对象存活与否" tabindex="-1"><a class="header-anchor" href="#_2-判断对象存活与否" aria-hidden="true">#</a> 2. 判断对象存活与否</h2><p>知道了要回收哪里的垃圾后，接着要搞清楚哪些对象可以被当成垃圾呢？这就涉及到常见的两种 <strong>判断对象是否存活的算法</strong> 了，它们分别是 <strong>引用计数法</strong> 和 <strong>可达性分析算法</strong>。</p><h3 id="_2-1-引用计数法" tabindex="-1"><a class="header-anchor" href="#_2-1-引用计数法" aria-hidden="true">#</a> 2.1 引用计数法</h3><p><strong>引用计数法</strong> 非常简单，只需要 <strong>在对象中添加一个引用计数器</strong>，当 <strong>该对象被引用时，计数器就加一；引用取消时，计数器就减一</strong>。这样在 <strong>计数器为零的时候，该对象就是不会被使用了</strong>。</p><p>引用计数法虽然占用了一些额外的内存空间来存放计数器，但它的原理简单，判定效率也高，所以在大多数情况下表现还不错。</p><p>但是，引用计数法有个很大的 <strong>缺点</strong>，就是会存在 <strong>对象之间循环引用</strong> 的问题，这也是现今的 JVM 都没有选用该方法的原因。</p><p>什么是循环引用呢？下面举一个简单的例子：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyObj</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token class-name">Object</span> instance <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token class-name">MyObj</span> objA <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MyObj</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">MyObj</span> objB <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MyObj</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 让 objA、objB 的 instance 变量互相引用对方</span>
objA<span class="token punctuation">.</span>instance <span class="token operator">=</span> objB<span class="token punctuation">;</span>
objB<span class="token punctuation">.</span>instance <span class="token operator">=</span> objA<span class="token punctuation">;</span>

<span class="token comment">// 此时把 objA、objB 置为空</span>
objA <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
objB <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>通过上面的实例可以发生，虽然最后把 objA、objB 都置为 null 了，但其实它们还被对方的 instance 变量所引用着，也就是各自的引用计数器都为 1，还不能被 GC 回收，但它们又都被直为 null 了，后面不会再使用了，这就造成了内存被白白的占用。</p><h3 id="_2-2-可达性分析算法" tabindex="-1"><a class="header-anchor" href="#_2-2-可达性分析算法" aria-hidden="true">#</a> 2.2 可达性分析算法</h3><p>另一种常用的算法是 <strong>可达性分析算法</strong>，在该算法下，有一个 <strong>GC Root 集合</strong>，里面保存的都是一些 GC Root，这些 <strong>GC Root 会把一系列的引用关系连接起来</strong>，形成一条条的 <strong>引用链</strong>。</p><p>这时 <strong>从 GC Root 的根对象作为起点，沿着引用链向下搜索，如果某个对象从 GC Root 不可达</strong>，也就是 <strong>该对象没有任何一条引用链可以到 GC Root</strong>，那么就能证明 <strong>该对象不会再被使用了</strong>。</p><p>例如下面的 object5、object6 和 object7 都是不可达 GC Root 的，所以会被判定为可回收的对象。</p><p><img src="https://run-notes.oss-cn-beijing.aliyuncs.com/notes/202308202151421.png" alt="image-20230820215119259" loading="lazy"></p><p>在 Java 中，<strong>可以作为 GC Root 的对象</strong> 主要包括以下几种：</p><ul><li><strong>在 Java 栈中引用的对象</strong>；</li><li><strong>在方法区中类静态变量引用的对象</strong>；</li><li><strong>在方法区中常量引用的对象</strong>；</li><li><strong>本地方法栈中 Native 方法引用的对象</strong>；</li><li><strong>被同步锁（synchronized 关键字）持有的对象</strong>。</li></ul><h2 id="_3-finalize-最后的援救" tabindex="-1"><a class="header-anchor" href="#_3-finalize-最后的援救" aria-hidden="true">#</a> 3. finalize - 最后的援救</h2><p>现在常用的 JVM 都是使用的可达性分析算法来判定对象存活与否，那么当一个对象被判定为不可达对象时，它一定会被下一轮 GC 消灭吗？</p><p>其实，它们还有一次被援救的机会，那就是 <code>finalize()</code> 方法，这是 Object 类的一个方法，也就是说，所有的类都会继承这个方法。</p><p><strong>当一个对象被标记为不可达对象后，会进行一轮检查，看该对象是否要执行 <code>finalize()</code> 方法</strong>，检查手段是：</p><ul><li><p><strong>该对象是否重写了父类 Object 的 <code>finalize()</code> 方法</strong>；</p></li><li><p><strong>该 <code>finalize()</code> 方法是否已经被执行过了</strong>。</p><blockquote><p>因为 <strong>任何一个对象的 <code>finalize()</code> 方法都只会被系统自动调用一次</strong>。</p></blockquote></li></ul><p>如果确定了该对象要执行 <code>finalize()</code> 方法，则会把该对象放入一个 F-Queue 队列中，之后会由一个叫做 Finalizer 线程去执行它们的 <code>finalize()</code> 方法。</p><p>当然了，为了避免执行 <code>finalize()</code> 方法的时间过长、或者发生死循环，所以并不会等该方法执行完毕，而是会有个时间限制。</p><p><strong>在执行 <code>finalize()</code> 方法时</strong>，如果对象在该方法中成功拯救了自己，即 <strong>重新与引用链上的任何一个对象建立关联</strong>，那么该对象就会被移出回收集合中，从而 <strong>拯救成功</strong>。</p><p>下面给出一个援救的例子：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">FinalizeEscapeGC</span> <span class="token punctuation">{</span>
  
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">FinalizeEscapeGC</span> <span class="token constant">SAVE_HOOK</span> <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
  
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">finalize</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Throwable</span> <span class="token punctuation">{</span>
        <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">finalize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;finalize method executed!&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">FinalizeEscapeGC</span><span class="token punctuation">.</span><span class="token constant">SAVE_HOOK</span> <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>	<span class="token comment">// 自救</span>
    <span class="token punctuation">}</span>
  
	<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Throwable</span> <span class="token punctuation">{</span>
        <span class="token constant">SAVE_HOOK</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FinalizeEscapeGC</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    
        <span class="token comment">// 对象第一次成功拯救自己</span>
        <span class="token constant">SAVE_HOOK</span> <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">gc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 因为 Finalizer 优先级较低，暂停 0.5 秒，等待它</span>
        <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">500</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token constant">SAVE_HOOK</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        	<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;yes, i am still alive :)&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        	<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;no, i am dead :(&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token comment">// 这次自救却失败了，因为系统只会自动执行一个 finalize 方法</span>
        <span class="token constant">SAVE_HOOK</span> <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">gc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">500</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token constant">SAVE_HOOK</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        	<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;yes, i am still alive :)&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        	<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;no, i am dead :(&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>finalize method executed!
yes, i am still alive :)
no, i am dead :(
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>不过并 <strong>不推荐使用 <code>finalize()</code> 方法来拯救对象</strong>，因为该方法的 <strong>运行代价高、不一定会被执行完毕、无法确定各对象的调用顺序</strong>，官方也不推荐使用该方法。</p><h2 id="_4-总结" tabindex="-1"><a class="header-anchor" href="#_4-总结" aria-hidden="true">#</a> 4. 总结</h2><p>垃圾收集器主要是回收 Java 堆中一些不使用的对象，要知道哪些对象是不会使用的，就涉及到两种对象判活算法：</p><ul><li>引用计数法；</li><li>可达性分析算法。</li></ul><p>由于 <strong>引用计数法存在循环引用的问题</strong>，会导致不使用对象占用的内存空间无法被回收，因此通常都是使用可达性分析算法。</p><p>在 <strong>可达性分析算法</strong> 中，存在着一些 GC Root，要判断该对象是否可被回收，只需看 <strong>该对象是否存在一条可达 GC Root 的引用链</strong> 即可。</p><p>最后提到了 <strong>finalize 方法</strong>，它虽然 <strong>可以拯救不可达 GC Root 的对象</strong>，但由于它的 <strong>执行代价高、不确定性大</strong>，所以也不推荐使用了。</p>`,39);function _(h,f){const t=o("router-link"),p=o("ExternalLinkIcon");return c(),i("div",null,[n("details",d,[k,n("nav",v,[n("ul",null,[n("li",null,[a(t,{to:"#_1-gc-需要回收什么"},{default:e(()=>[s("1. GC 需要回收什么？")]),_:1})]),n("li",null,[a(t,{to:"#_2-判断对象存活与否"},{default:e(()=>[s("2. 判断对象存活与否")]),_:1}),n("ul",null,[n("li",null,[a(t,{to:"#_2-1-引用计数法"},{default:e(()=>[s("2.1 引用计数法")]),_:1})]),n("li",null,[a(t,{to:"#_2-2-可达性分析算法"},{default:e(()=>[s("2.2 可达性分析算法")]),_:1})])])]),n("li",null,[a(t,{to:"#_3-finalize-最后的援救"},{default:e(()=>[s("3. finalize - 最后的援救")]),_:1})]),n("li",null,[a(t,{to:"#_4-总结"},{default:e(()=>[s("4. 总结")]),_:1})])])])]),m,n("p",null,[s("我们知道，"),n("a",g,[s("Java 内存运行时区域"),a(p)]),s(" 分为线程私有和线程共享两部分：")]),b])}const j=l(r,[["render",_],["__file","GC｜对象存活与否.html.vue"]]);export{j as default};
