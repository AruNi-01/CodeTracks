import{_ as p}from"./plugin-vue_export-helper-c27b6911.js";import{r as o,o as l,c,b as n,e as a,w as t,a as i,d as e}from"./app-8955315f.js";const u={},r={class:"hint-container details"},d=n("summary",null,"本文内容",-1),k={class:"table-of-contents"},g=i(`<div class="hint-container info"><p class="hint-container-title">前言</p><p>在前面两篇文章中，讲解了什么是微服务，何时进行服务拆分，拆分后会到来什么问题等。</p><p>这篇文章将带你走进微服务架构，看看它的各个组成部分，主要的几个基本组件如下：</p><ul><li>服务描述；</li><li>注册中心；</li><li>服务框架；</li><li>服务监控；</li><li>服务追踪；</li><li>服务治理。</li></ul><p>一次微服务之间的调用流程如下：</p><ol><li><strong>服务提供者</strong> 按照一定格式的服务描述，<strong>向注册中心注册服务</strong>，声明自己能提供哪儿服务以及服务所在的地址是什么，完成服务发布；</li><li><strong>服务消费者向注册中心发起请求，查询要调用服务的地址</strong>，然后 <strong>按照约定好的通信协议发起请求</strong> 即可得到结果；</li></ol><p>在服务调用过程中：</p><ul><li>服务的请求耗时、调用次数等指标会被服务追踪组件记录下来，用于故障问题的定位；</li><li>如果发现请求量过大、出现调用失败等情况，则将通过服务降级、熔断、重试等服务治理手段保证系统的可用性。</li></ul><p>微服务架构的模块图：</p><p><img src="https://run-notes.oss-cn-beijing.aliyuncs.com/notes/202306152238598.png" alt="img" loading="lazy"></p></div><h2 id="_1-服务描述" tabindex="-1"><a class="header-anchor" href="#_1-服务描述" aria-hidden="true">#</a> 1. 服务描述</h2><p>要调用服务，首先要解决的就是 <strong>如何对外描述该服务</strong>，描述信息包括 <strong>服务名、调用所需的参数、调用使用什么传输方式、如何解析结果</strong> 等等。</p><p>常用的服务描述方式有 <strong>RESTful API、XML 配置和 IDL 文件</strong>（Interface Definition Language）三种。</p><h3 id="_1-1-restful-api" tabindex="-1"><a class="header-anchor" href="#_1-1-restful-api" aria-hidden="true">#</a> 1.1 RESTful API</h3><p><strong>RESTful API 通常用于 HTTP/HTTPS 协议的服务描述，常用 Wiki 或 Swagger 进行管理</strong>。</p><p>比如下面这个用 Swagger 进行管理的 RESTful API：</p><p><img src="https://run-notes.oss-cn-beijing.aliyuncs.com/notes/202306152251861.png" alt="img" loading="lazy"></p><p>因为 HTTP 是一个常用、公开的协议，对于服务消费者来说没有任何学习成本，所以可以非常方便的供他人使用，适用于 <strong>跨业务平台之间的服务</strong>，比如 <strong>不同业务部门之间的服务调用，或提供给外网的服务</strong>。</p><h3 id="_1-2-xml-配置" tabindex="-1"><a class="header-anchor" href="#_1-2-xml-配置" aria-hidden="true">#</a> 1.2 XML 配置</h3><p><strong>XML 配置多用在 RPC 协议的服务描述</strong>，通过 <code>*.xml</code> 文件来定义服务的接口名、参数等信息。</p><p>比如下面这个 XML 配置方式的服务描述：</p><p><img src="https://static001.geekbang.org/resource/image/fd/3f/fd877669241102a7b772611b98d4363f.png?wh=550*328" alt="img" loading="lazy"></p><p><strong>服务消费者</strong> 想要引用服务，<strong>也需要维持一份对等的 XML 配置文件</strong>，因此这种方式 <strong>对代码入侵比较高，XML 配置有变更时，服务提供者和消费者都需要更新</strong>，适合公司 <strong>内部联系比较紧密的业务之间采用</strong>。</p><h3 id="_1-3-idl-文件" tabindex="-1"><a class="header-anchor" href="#_1-3-idl-文件" aria-hidden="true">#</a> 1.3 IDL 文件</h3><p><strong>IDL（Inteface Definition Language）文件通常用作 Thrift、gRPC 这类跨语言的服务调用</strong>，gRPC 就是通过 Protobuf 文件来定义服务的接口名、参数等信息。</p><p>下面是一个 Protobuf 文件的示例，<code>helloword.proto</code> 定义了一个接口 SayHello 方法，它的请求参数是 HelloRequest，它的返回值是 HelloReply：</p><div class="language-protobuf line-numbers-mode" data-ext="protobuf"><pre class="language-protobuf"><code><span class="token comment">// The greeter service definition.</span>
<span class="token keyword">service</span> <span class="token class-name">Greeter</span> <span class="token punctuation">{</span>
  <span class="token comment">// Sends a greeting</span>
  <span class="token keyword">rpc</span> <span class="token function">SayHello</span> <span class="token punctuation">(</span><span class="token class-name">HelloRequest</span><span class="token punctuation">)</span> <span class="token keyword">returns</span> <span class="token punctuation">(</span><span class="token class-name">HelloReply</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
  <span class="token keyword">rpc</span> <span class="token function">SayHelloAgain</span> <span class="token punctuation">(</span><span class="token class-name">HelloRequest</span><span class="token punctuation">)</span> <span class="token keyword">returns</span> <span class="token punctuation">(</span><span class="token class-name">HelloReply</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// The request message containing the user&#39;s name.</span>
<span class="token keyword">message</span> <span class="token class-name">HelloRequest</span> <span class="token punctuation">{</span>
  <span class="token builtin">string</span> name <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// The response message containing the greetings</span>
<span class="token keyword">message</span> <span class="token class-name">HelloReply</span> <span class="token punctuation">{</span>
  <span class="token builtin">string</span> message <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>利用 protoc 插件可以自动生成服务端的代码，支持多种语言，下面是生成的 Java 示例代码：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">private</span> <span class="token keyword">class</span> <span class="token class-name">GreeterImpl</span> <span class="token keyword">extends</span> <span class="token class-name">GreeterGrpc<span class="token punctuation">.</span>GreeterImplBase</span> <span class="token punctuation">{</span>

  <span class="token annotation punctuation">@Override</span>
  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token class-name">HelloRequest</span> req<span class="token punctuation">,</span> <span class="token class-name">StreamObserver</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">HelloReply</span><span class="token punctuation">&gt;</span></span> responseObserver<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">HelloReply</span> reply <span class="token operator">=</span> <span class="token class-name">HelloReply</span><span class="token punctuation">.</span><span class="token function">newBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">setMessage</span><span class="token punctuation">(</span><span class="token string">&quot;Hello &quot;</span> <span class="token operator">+</span> req<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    responseObserver<span class="token punctuation">.</span><span class="token function">onNext</span><span class="token punctuation">(</span>reply<span class="token punctuation">)</span><span class="token punctuation">;</span>
    responseObserver<span class="token punctuation">.</span><span class="token function">onCompleted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token annotation punctuation">@Override</span>
  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">sayHelloAgain</span><span class="token punctuation">(</span><span class="token class-name">HelloRequest</span> req<span class="token punctuation">,</span> <span class="token class-name">StreamObserver</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">HelloReply</span><span class="token punctuation">&gt;</span></span> responseObserver<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">HelloReply</span> reply <span class="token operator">=</span> <span class="token class-name">HelloReply</span><span class="token punctuation">.</span><span class="token function">newBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">setMessage</span><span class="token punctuation">(</span><span class="token string">&quot;Hello again &quot;</span> <span class="token operator">+</span> req<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    responseObserver<span class="token punctuation">.</span><span class="token function">onNext</span><span class="token punctuation">(</span>reply<span class="token punctuation">)</span><span class="token punctuation">;</span>
    responseObserver<span class="token punctuation">.</span><span class="token function">onCompleted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>protoc 插件也能自动生成 Client 端（调用者）的代码：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">greet</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    logger<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">&quot;Will try to greet &quot;</span> <span class="token operator">+</span> name <span class="token operator">+</span> <span class="token string">&quot; ...&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">HelloRequest</span> request <span class="token operator">=</span> <span class="token class-name">HelloRequest</span><span class="token punctuation">.</span><span class="token function">newBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">setName</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">HelloReply</span> response<span class="token punctuation">;</span>

    <span class="token comment">// 忽略 try-catch 代码</span>
    response <span class="token operator">=</span> blockingStub<span class="token punctuation">.</span><span class="token function">sayHello</span><span class="token punctuation">(</span>request<span class="token punctuation">)</span><span class="token punctuation">;</span>
    logger<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">&quot;Greeting: &quot;</span> <span class="token operator">+</span> response<span class="token punctuation">.</span><span class="token function">getMessage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    response <span class="token operator">=</span> blockingStub<span class="token punctuation">.</span><span class="token function">sayHelloAgain</span><span class="token punctuation">(</span>request<span class="token punctuation">)</span><span class="token punctuation">;</span>
    logger<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">&quot;Greeting: &quot;</span> <span class="token operator">+</span> response<span class="token punctuation">.</span><span class="token function">getMessage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>  
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>gRPC 的服务描述是 <strong>使用 proto 文件来定义接口，接着使用 protoc 插件来自动生成不同语言的服务端和客户端代码，从而具备跨语言服务调用的能力</strong>。</p><p>需要注意的是，在描述接口定义时，IDL 文件需要对接口的名称、参数、返回值都进行详细的定义，因此 <strong>IDL 文件方式不太适用于接口信息经常变化的情况</strong>。</p><h2 id="_2-注册中心" tabindex="-1"><a class="header-anchor" href="#_2-注册中心" aria-hidden="true">#</a> 2. 注册中心</h2><p>解决了服务描述后，能定义好接口了，那么这些接口服务如何被调用者发现进行调用呢？接着就要解决 <strong>服务的发布和订阅</strong> 问题了。</p><p>所以我们需要一个 <strong>注册中心</strong>，用于 <strong>记录服务提供者的所提供的服务及地址，调用者在调用时从注册中心中查询对应的服务地址</strong>，然后发起请求即可。</p><p>一般的注册中心的工作流程如下：</p><ol><li><strong>服务提供者根据发布配置文件向注册中心注册服务</strong>；</li><li><strong>服务消费者根据其配置文件在注册中心订阅自己所需的服务</strong>；</li><li><strong>注册中心将返回服务提供者的地址列表给服务消费者</strong>；</li><li><strong>当服务提供者有变化时（如节点更新），注册中心将更变通知给消费者</strong>。</li></ol><p>流程如下：</p><p><img src="https://run-notes.oss-cn-beijing.aliyuncs.com/notes/202306152322061.png" alt="img" loading="lazy"></p><h2 id="_3-服务框架" tabindex="-1"><a class="header-anchor" href="#_3-服务框架" aria-hidden="true">#</a> 3. 服务框架</h2><p>在有了注册中心后，就可以获取地址调用服务了，但是在调用服务之前，还需要解决下面几个问题：</p><ul><li><strong>服务采用什么协议通信</strong>？是采用四层 TCP/UDP 协议，还是采用七层 HTTP 协议，还是采用 RPC 相关协议？</li><li><strong>数据采用什么方式传输</strong>？有同步、异步、单连接传输、多路复用等。</li><li><strong>数据采用什么格式压缩</strong>？通常都需要对实体进行压缩，减少网络传输的数据量，以加速传输时间。常见的有 JSON 序列化、Protobuf 序列化等。</li></ul><p>这就需要一个 <strong>微服务服务框架</strong> 来解决，比如 SpringCloudAlibaba Dobbo、SpringCloud Feign 等。</p><h2 id="_4-服务监控" tabindex="-1"><a class="header-anchor" href="#_4-服务监控" aria-hidden="true">#</a> 4. 服务监控</h2><p>当微服务多起来的时候，为了掌握每个服务的健康情况，是否能正常提供服务。通常需要一个 <strong>服务监控组件</strong>，它包含三个流程：</p><ul><li><strong>指标收集</strong>：把一次服务调用的请求耗时、成功与否等信息收集起来，给数据处理中心进行分析；</li><li><strong>数据处理</strong>：从上一步中得到数据后，就可以计算每秒服务请求量、平均耗时、成功率等指标；</li><li><strong>数据展示</strong>：数据经过收集分析处理后，需要通过友好的界面展示出来，方便观看，一般是展示到一个 Dashboard 面板上。</li></ul><h2 id="_5-服务追踪" tabindex="-1"><a class="header-anchor" href="#_5-服务追踪" aria-hidden="true">#</a> 5. 服务追踪</h2><p>当调用链路较长时，就需要 <strong>记录服务调用过程中的每层链路情况</strong>，以便进行问题追踪和故障定位。</p><p><strong>服务追踪</strong> 的大致工作原理如下：</p><ul><li><p>服务消费者发起调用时，会生成一个 <strong>requestid</strong>，随着请求参数一起传递给服务提供者；</p></li><li><p>服务提供者收到请求后，<strong>需要记录下 requestid</strong>，然后处理请求。如果 <strong>该服务提供者需要请求其他服务</strong>，那么重复第一步，<strong>将两个 requestid 都向下传递</strong>。</p></li><li><p>最后请求完成后，<strong>根据最开始生产的 requestid，就能串联所有节点</strong>，达到服务追踪的目的。</p></li></ul><h2 id="_6-服务治理" tabindex="-1"><a class="header-anchor" href="#_6-服务治理" aria-hidden="true">#</a> 6. 服务治理</h2><p>服务监控和服务追踪能发现问题所在，而要解决问题，就得靠 <strong>服务治理</strong> 了。</p><p><strong>服务治理：通过一系列的手段来保证服务在意外情况下也能正常调用</strong>。</p><p>在微服务架构中，常见的意外情况有如下几种：</p><ul><li><strong>单机故障</strong>：当遇到集群中的某一台机器故障时，服务治理可以 <strong>自动移除故障机器</strong>，保证业务不受影响；</li><li><strong>单 IDC（互联网数据中心）故障</strong>：在某些极端情况下，例如施工挖断光缆、自然灾害导致机房被摧毁，都将导致单 IDC 故障，服务治理可以 <strong>自动切换故障 IDC 的流量到其他正常的 IDC 下</strong>；</li><li><strong>某微服务不可用</strong>：当调用的某个服务不可用时，服务治理可以进行 <strong>服务熔断</strong>，使服务能正常的返回结果，而避免增加该服务的压力，使其能尽快恢复；</li></ul><p>还有一些服务治理的其他手段，比如 <strong>服务降级、服务限流、自动扩缩容</strong> 等。</p><h2 id="_7-总结" tabindex="-1"><a class="header-anchor" href="#_7-总结" aria-hidden="true">#</a> 7. 总结</h2><p>可以发现，引入微服务后，需要考虑各种各样的问题，只有你都清楚每个问题的解决方案后，才能进一步实施微服务。</p><p>因此，我们接下来需要搞明白上面所提到的一些微服务基本组件：</p><ul><li>服务描述；</li><li>注册中心；</li><li>服务框架；</li><li>服务监控；</li><li>服务追踪；</li><li>服务治理。</li></ul>`,52);function m(v,b){const s=o("router-link");return l(),c("div",null,[n("details",r,[d,n("nav",k,[n("ul",null,[n("li",null,[a(s,{to:"#_1-服务描述"},{default:t(()=>[e("1. 服务描述")]),_:1}),n("ul",null,[n("li",null,[a(s,{to:"#_1-1-restful-api"},{default:t(()=>[e("1.1 RESTful API")]),_:1})]),n("li",null,[a(s,{to:"#_1-2-xml-配置"},{default:t(()=>[e("1.2 XML 配置")]),_:1})]),n("li",null,[a(s,{to:"#_1-3-idl-文件"},{default:t(()=>[e("1.3 IDL 文件")]),_:1})])])]),n("li",null,[a(s,{to:"#_2-注册中心"},{default:t(()=>[e("2. 注册中心")]),_:1})]),n("li",null,[a(s,{to:"#_3-服务框架"},{default:t(()=>[e("3. 服务框架")]),_:1})]),n("li",null,[a(s,{to:"#_4-服务监控"},{default:t(()=>[e("4. 服务监控")]),_:1})]),n("li",null,[a(s,{to:"#_5-服务追踪"},{default:t(()=>[e("5. 服务追踪")]),_:1})]),n("li",null,[a(s,{to:"#_6-服务治理"},{default:t(()=>[e("6. 服务治理")]),_:1})]),n("li",null,[a(s,{to:"#_7-总结"},{default:t(()=>[e("7. 总结")]),_:1})])])])]),g])}const _=p(u,[["render",m],["__file","初探微服务架构.html.vue"]]);export{_ as default};
