import{_ as l}from"./plugin-vue_export-helper-c27b6911.js";import{r as o,o as i,c as u,a as n,d as s,w as t,b as a,e as c}from"./app-a57bf499.js";const r={},d={class:"hint-container details"},k=n("summary",null,"本文内容",-1),v={class:"table-of-contents"},m=c(`<h2 id="_1-什么是-threadlocal" tabindex="-1"><a class="header-anchor" href="#_1-什么是-threadlocal" aria-hidden="true">#</a> 1. 什么是 ThreadLocal？</h2><p>ThreadLocal 叫做本地线程变量，顾名思义，ThreadLocal 中存放的是 <strong>当前线程的变量</strong>，该变量对其他线程而言是 <strong>隔离</strong> 的。对于 ThreadLocal 存放的变量，在每个线程中都有一份自己的 <strong>副本变量</strong>，多个线程互不干扰。</p><p>下面使用一个简单的例子来展示 ThreadLocal 的线程隔离：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Demo01</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">ThreadLocal</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">User</span><span class="token punctuation">&gt;</span></span> localUser <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ThreadLocal</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 线程1 先启动，往 ThreadLocal 中添加 User 对象</span>
        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>
            localUser<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token string">&quot;张三&quot;</span><span class="token punctuation">,</span> <span class="token number">17</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">try</span> <span class="token punctuation">{</span>
                <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">3000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RuntimeException</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token class-name">User</span> user <span class="token operator">=</span> localUser<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;线程1 获取的 User：&quot;</span> <span class="token operator">+</span> user<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token string">&quot;线程1&quot;</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// 主线程获取 ThreadLocal 中的变量</span>
        <span class="token class-name">User</span> user <span class="token operator">=</span> localUser<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;main线程 获取的 User：&quot;</span> <span class="token operator">+</span> user<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">User</span> <span class="token punctuation">{</span>
    <span class="token class-name">String</span> name<span class="token punctuation">;</span>
    <span class="token keyword">int</span> age<span class="token punctuation">;</span>

    <span class="token comment">// 构造方法、toString() 略</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>main线程 获取的 User：null
线程1 获取的 User：User{name=&#39;张三&#39;, age=17}

Process finished with exit code 0
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>可以发现，线程1中添加的 ThreadLocal 变量，只有线程1自己能获取到，main 线程是获取不到的，因此对于这个 ThreadLocal 变量来说，线程之间是隔离的。</p><p>我们还可以在 main 线程中添加属于它的 ThreadLocal 变量，如下：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code>	<span class="token comment">// ......</span>

	<span class="token comment">// main 线程添加自己的 ThreadLocal 变量</span>
    localUser<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token string">&quot;李四&quot;</span><span class="token punctuation">,</span> <span class="token number">18</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">User</span> user <span class="token operator">=</span> localUser<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;main线程 获取的 User：&quot;</span> <span class="token operator">+</span> user<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// .......</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>main线程 获取的 User：User{name=&#39;李四&#39;, age=18}
线程1 获取的 User：User{name=&#39;张三&#39;, age=17}

Process finished with exit code 0
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="_2-threadlocal-内部设计" tabindex="-1"><a class="header-anchor" href="#_2-threadlocal-内部设计" aria-hidden="true">#</a> 2. ThreadLocal 内部设计</h2><p>想要知道 ThreadLocal 为什么能实现线程隔离，就要翻开 ThreadLocal 的源码，看看它是如何实现的。</p><h3 id="_2-1-早期设计" tabindex="-1"><a class="header-anchor" href="#_2-1-早期设计" aria-hidden="true">#</a> 2.1 早期设计</h3><p>在 JDK 最早期的设计中，ThreadLocal 是这样设计的：</p><p>每个 ThreadLocal 都创建一个 Map（ThreadLocalMap），当前线程作为 key，要存储的变量作为 value，这样能达到各个线程的变量互相隔离的效果。如下图：</p><p><img src="https://run-notes.oss-cn-beijing.aliyuncs.com/notes/202212011641956.png" alt="image-20221201164134241" loading="lazy"></p><p>从上面的设计中很容易看出一个缺点：<strong>每创建一个线程都要添加一个 Entry</strong>，即使这个线程根本就没有用到 ThreadLocal。</p><p>所以在 JDK 1.8 中，弃用了这种设计。</p><h3 id="_2-2-jdk-1-8-的设计" tabindex="-1"><a class="header-anchor" href="#_2-2-jdk-1-8-的设计" aria-hidden="true">#</a> 2.2 JDK 1.8 的设计</h3><p>在 JDK 1.8 中，ThreadLocal 的设计是：</p><p><strong>每个 Thread 维护一个 Map（ThreadLocalMap），这个 Map 的 key 为 ThreadLocal 实例（弱引用），value 为要存储的变量</strong>。</p><p><img src="https://run-notes.oss-cn-beijing.aliyuncs.com/notes/202212011710278.png" alt="image-20221201171027198" loading="lazy"></p><p>可以发现，此设计的 ThreadLocal 和 Thread 刚好和早期的设计是相反的，这样设计有如下 <strong>优点</strong>：</p><ul><li>每创建一个线程不一定会增加一个 Entry，当前线程不使用 ThreadLocal 时，Map 就为 null。所以 <strong>每个 Map 存储的 Entry 数量就会减少</strong>，往往线程的数量要大于 ThreadLocal 的数量。</li><li>当 Thread 销毁后，对应的 ThreadLocalMap 也随之销毁，<strong>减少内存占用</strong>。</li><li>当并发量较大时，因为所有的 Entry 在一个 Map 中，<strong>所有线程对同一个 ThreadLocal 变量的操作都在同一个 Map 中（Map 中一个线程对应一个 key），导致访问性能下降</strong>。而现在的设计每个线程自己有一个 Map，访问自己的效率更高。</li></ul><div class="hint-container tip"><p class="hint-container-title">Thread 是怎么拥有 ThreadLocalMap 的呢？</p></div><p>在 Thread 类中有一个类型为 <code>ThreadLocal.ThreadLocalMap</code> 的实例变量 <code>threadLocals</code>，默认值为 null。所以当创建线程时，每个线程都有一个自己的 ThreadLocalMap。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Thread</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span> <span class="token punctuation">{</span>
    <span class="token comment">// ......</span>
    
    <span class="token comment">/* ThreadLocal values pertaining to this thread. This map is maintained
     * by the ThreadLocal class. */</span>
    <span class="token class-name">ThreadLocal<span class="token punctuation">.</span>ThreadLocalMap</span> threadLocals <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
    
    <span class="token comment">// ......</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>当对 ThreadLocal 进行 <code>set()</code> 时，就会先获取当前线程的 ThreadLocalMap，如果为 null 就会创建 ThreadLocalMap：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">set</span><span class="token punctuation">(</span><span class="token class-name">T</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">Thread</span> t <span class="token operator">=</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// getMap(t) 直接返回当前线程的 threadLocals 变量（ThreadLocalMap 类型）</span>
        <span class="token class-name">ThreadLocalMap</span> map <span class="token operator">=</span> <span class="token function">getMap</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>map <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            map<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
            <span class="token function">createMap</span><span class="token punctuation">(</span>t<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token class-name">ThreadLocalMap</span> <span class="token function">getMap</span><span class="token punctuation">(</span><span class="token class-name">Thread</span> t<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> t<span class="token punctuation">.</span>threadLocals<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_2-3-threadlocalmap-的实现" tabindex="-1"><a class="header-anchor" href="#_2-3-threadlocalmap-的实现" aria-hidden="true">#</a> 2.3 ThreadLocalMap 的实现</h3><p>ThreadLocalMap 是 ThreadLocal 的静态内部类，它有自己的独立实现。</p><p>ThreadLocalMap 中用于存储 kv 对的是 Entry 类型的数组，这个 Entry 是 ThreadLocalMap 的静态内部类，它继承了 WeakReference 类，在构造方法中，对 key 的构造使用了父类 WeakReference 的构造方法，所以 <strong>key 是一个弱引用，而不是 ThreadLocal 本身</strong>。</p><p>ThreadLocal 部分源码如下：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ThreadLocal</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>
    <span class="token comment">// ......</span>
    <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">ThreadLocalMap</span> <span class="token punctuation">{</span>
	<span class="token comment">// ......</span>
        <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Entry</span> <span class="token keyword">extends</span> <span class="token class-name">WeakReference</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">ThreadLocal</span><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>
            <span class="token doc-comment comment">/** The value associated with this ThreadLocal. */</span>
            <span class="token class-name">Object</span> value<span class="token punctuation">;</span>

            <span class="token class-name">Entry</span><span class="token punctuation">(</span><span class="token class-name">ThreadLocal</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> k<span class="token punctuation">,</span> <span class="token class-name">Object</span> v<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">super</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">;</span>
                value <span class="token operator">=</span> v<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>

        <span class="token doc-comment comment">/**
         * The table, resized as necessary.
         * table.length MUST always be a power of two.
         */</span>
        <span class="token keyword">private</span> <span class="token class-name">Entry</span><span class="token punctuation">[</span><span class="token punctuation">]</span> table<span class="token punctuation">;</span>
    
        <span class="token comment">// ......</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_2-4-threadlocal-会发生内存泄漏吗" tabindex="-1"><a class="header-anchor" href="#_2-4-threadlocal-会发生内存泄漏吗" aria-hidden="true">#</a> 2.4 ThreadLocal 会发生内存泄漏吗？</h3><p>先简单的了解下什么是内存泄漏以及 Java 的四种引用类型。</p><div class="hint-container tip"><p class="hint-container-title">什么是内存泄漏？</p></div><p>内存泄漏就是已经不再使用得内存得不到释放，让这块内存空间白白的被占有，一旦内存泄漏出现的次数多了，就可能导致 OOM。</p><div class="hint-container tip"><p class="hint-container-title">Java 的四种引用类型</p></div><p>Java 的四种引用类型如下：</p><ul><li><strong>强引用</strong>：通常 new 出来的对象就是强引用类型（把一个对象赋给一个引用变量，这个引用变量就是一个强引用）。只要强引用的存在，对象没有被置为 null，垃圾回收器将 <strong>永远不会回收被引用的对象，哪怕内存不足的时候</strong>。</li><li><strong>软引用</strong>：使用 SoftReference 修饰的对象被称为软引用，软引用指向的对象在 <strong>内存要溢出的时候被回收</strong>。</li><li><strong>弱引用</strong>：使用 WeakReference 修饰的对象被称为弱引用，<strong>只要发生垃圾回收</strong>，若这个对象 <strong>只被弱引用指向，那么就会被回收</strong>。</li><li><strong>虚引用</strong>：虚引用是最弱的引用，在 Java 中使用 PhantomReference 进行定义。虚引用中唯一的作用就是 <strong>用队列接收对象即将死亡的通知</strong>。</li></ul><div class="hint-container tip"><p class="hint-container-title">ThreadLocal 内存泄漏分析</p></div><p>根据 ThreadLocal 的内部实现原理，每个 Thread 维护了一个 ThreadLocalMap，key 为使用 <strong>弱引用</strong> 的ThreadLocal，value 为我们要存储的对象。</p><p>这些对象之间的引用关系如下（实线 - 强引用，虚线 - 弱引用）。可以看出，ThreadLocal 被两种引用指向：</p><ul><li><p>强引用：<code>ThreadLocalRef -&gt; ThreadLocal</code>；</p></li><li><p>弱引用：<code>key -&gt; ThreadLocal</code>；</p></li></ul><p><img src="https://run-notes.oss-cn-beijing.aliyuncs.com/notes/202212012055668.png" alt="image-20221201205530538" loading="lazy"></p><p>根据上图进行分析：</p><p><strong>如果一个 ThreadLocal 不存在外部强引用时（外界把 ThreadLocal 变量置为 null），key 势必会被 GC 回收，这样就会导致 ThreadLocalMap 中的 key 为 null，而 value 不为 null</strong>，只有 Thread 线程销毁后，ThreadLocalMap 才会随之销毁，value 的强引用链条才会断掉。</p><p>但是如果 <strong>线程迟迟不关闭（比如使用线程池），这些 key 为 null 对应的 value 就会一直存在 Entry 中</strong>，占用内存空间，又无法回收，就造成了 <strong>内存泄漏</strong>。</p><p>所以，为了避免内存泄漏，我们通常在使用完 ThreadLocal 后，需要 <strong>主动调用 remove() 方法</strong>，释放掉当前线程占用的 Entry。这样即使线程不被销毁，内存空间也得到释放了。</p><h3 id="_2-5-key-为什么设计成弱引用" tabindex="-1"><a class="header-anchor" href="#_2-5-key-为什么设计成弱引用" aria-hidden="true">#</a> 2.5 key 为什么设计成弱引用？</h3><p>既然把 key 设置成弱引用会有内存泄漏的风险，为什么 JDK 团队还要这样做呢？先来看看下面这个问题。</p><div class="hint-container tip"><p class="hint-container-title">ThreadLocal 的 key 是弱引用，发生 GC 后 key 是否为 null 呢？</p></div><p>还是用上面的图来分析：</p><p><img src="https://run-notes.oss-cn-beijing.aliyuncs.com/notes/202212012055668.png" alt="image-20221201205530538" loading="lazy"></p><p>从上图可知，ThreadLocal 被两种引用指向：</p><ul><li>强引用：<code>ThreadLocalRef -&gt; ThreadLocal</code>；</li><li>弱引用：<code>ThreadLocalMap key -&gt; ThreadLocal</code>；</li></ul><p>所以，即使把 key 设置成了弱引用，<strong>只要 ThreadLocal 没被回收（强引用存在），那 ThreadLocalMap 中 key 指向 ThreadLocal 的弱引用就不会在 GC 时被回收</strong>，不会被置为 null。</p><p>而外界是通过 ThreadLocal 来对 ThreadLocalMap 进行操作的，<strong>假设外界使用的 ThreadLocal 对象被置为 null 了，如果 key 指向 ThreadLocal 的引用是强引用，也就是 key 的强引用指向 null，而这个强引用无论什么情况都不会被 GC 回收</strong>，此时的内存泄漏岂不是更糟糕吗？</p><p>所以，<strong>key 设计成弱引用反而可以预防大多数内存泄漏的情况</strong>。毕竟被回收后，下一次调用 set/get/remove 方法时，都会进行一次 null key 的清理。（清理内容在后面）</p><h3 id="_2-5-value-为什么不设计成弱引用呢" tabindex="-1"><a class="header-anchor" href="#_2-5-value-为什么不设计成弱引用呢" aria-hidden="true">#</a> 2.5 value 为什么不设计成弱引用呢？</h3><p>首先我们得知道，<strong>Object（存储的对象）除了被 value 指向外，没有任何引用指向它</strong>。所以如果 value 被设计成弱引用，则 <strong>Object 就只被弱引用指向</strong>，那么 <strong>Object 肯定会被 GC 回收</strong>，那再调用 <code>ThreadLocal.get()</code> 时，得到的就是一个 null 值。</p><p>所以，value 是绝对不可以设计成弱引用的，我们要确保它指向的 Object 不为 null。</p><h2 id="_3-threadlocal-应用场景" tabindex="-1"><a class="header-anchor" href="#_3-threadlocal-应用场景" aria-hidden="true">#</a> 3. ThreadLocal 应用场景</h2><h3 id="_3-1-维护数据库连接对象-connection" tabindex="-1"><a class="header-anchor" href="#_3-1-维护数据库连接对象-connection" aria-hidden="true">#</a> 3.1 维护数据库连接对象 Connection</h3><p>在多线程场景下，可能一个线程要处理多个客户端请求，如果每个客户端都需要连接相同的数据库，此时使用 ThreadLocal 再合适不过了。</p><p>若不使用 ThreadLocal，同一个线程处理多个客户端时，需要为每一个客户端都创建一次数据库连接，而数据库的创建和关闭都是需要耗时的。</p><p>此时你可能会说，定义一个全局的 Connection 变量，所有线程都共用一个连接。但是这样有一个问题，你何时关闭这个连接呢？若关闭后后面又来了一个线程要使用连接怎么办。</p><p>所以使用 ThreadLocal 的话，一个线程只需要创建一个数据库连接，这个线程处理其他客户端时就可以直接复用此连接，避免了创建连接的消耗。同时若此线程处理完了所有请求，就关闭自己的连接即可，不会影响到其他线程的连接。</p><h3 id="_3-2-保存用户信息" tabindex="-1"><a class="header-anchor" href="#_3-2-保存用户信息" aria-hidden="true">#</a> 3.2 保存用户信息</h3><p>ThreadLocal 最常用的场景就是在项目中保存用户的信息，这样就方便同一个线程执行不同方法时，获取到该用户的信息。</p><p>通常是在拦截器中将已经登录的用户存入 ThreadLocal 中，这样在这个线程处理用户的请求时，便可以在不同方法中通过 ThreadLocal 快速获取该登录用户的信息。</p><h3 id="_3-3-保存线程不安全的工具类" tabindex="-1"><a class="header-anchor" href="#_3-3-保存线程不安全的工具类" aria-hidden="true">#</a> 3.3 保存线程不安全的工具类</h3><p>若某个工具类在并发的场景下会有线程不安全的情况，那么可以使用 ThreadLocal。</p><p>常见的线程不安全工具类有 Random、SimpleDateFormat，下面使用 SimpleDateFormat 来举例。</p><p>假设我们需要对 1000 个时间进行格式化，为了提高效率，我们采用 10 个线程对这 1000 个时间进行格式化。如果不采取任何同步措施，会出现上一个线程还在使用 SimpleDateFormat 时，这个线程也去使用，这样返回格式化后的时间可能存在一个线程把另一个线程格式化完的时间覆盖了，最后这 1000 个时间里会有一些时间没被格式化到。</p><p>利用上面的例子，我们先来看看不适用 ThreadLocal，使用一个全局变量来格式化这些时间：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Demo2</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">ExecutorService</span> executorService <span class="token operator">=</span> <span class="token class-name">Executors</span><span class="token punctuation">.</span><span class="token function">newFixedThreadPool</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        
        <span class="token class-name">SimpleDateFormat</span> dateFormat <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SimpleDateFormat</span><span class="token punctuation">(</span><span class="token string">&quot;mm:ss&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">1000</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">int</span> tmp <span class="token operator">=</span> i<span class="token punctuation">;</span>
            executorService<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>
                <span class="token comment">// 10 个线程都共用同一个 SimpleDateFormat 对象进行格式化</span>
                <span class="token class-name">String</span> date <span class="token operator">=</span> dateFormat<span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token number">1000</span> <span class="token operator">*</span> tmp<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>date<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        executorService<span class="token punctuation">.</span><span class="token function">shutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>00:04
00:04
00:02
00:04
00:07
00:04
00:06
00:09
00:05
00:10
......
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>从前几个就可以看出，有好几个时间格式化成了 00:04，这说明多个线程使用了同一个 SimpleDateFormat 对象，出现了并发问题。</p><p>使用 ThreadLocal 后，这 10 个线程，每个线程都会有一个自己的 SimpleDateformat 副本：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Demo2</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">ThreadLocal</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">SimpleDateFormat</span><span class="token punctuation">&gt;</span></span> <span class="token constant">THREAD_LOCAL</span> <span class="token operator">=</span>
            <span class="token class-name">ThreadLocal</span><span class="token punctuation">.</span><span class="token function">withInitial</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token keyword">new</span> <span class="token class-name">SimpleDateFormat</span><span class="token punctuation">(</span><span class="token string">&quot;mm:ss&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">ExecutorService</span> executorService <span class="token operator">=</span> <span class="token class-name">Executors</span><span class="token punctuation">.</span><span class="token function">newFixedThreadPool</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">//        SimpleDateFormat dateFormat = new SimpleDateFormat(&quot;mm:ss&quot;);</span>

        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">1000</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">int</span> tmp <span class="token operator">=</span> i<span class="token punctuation">;</span>
            executorService<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>
                <span class="token class-name">SimpleDateFormat</span> dateFormat <span class="token operator">=</span> <span class="token constant">THREAD_LOCAL</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token class-name">String</span> date <span class="token operator">=</span> dateFormat<span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token number">1000</span> <span class="token operator">*</span> tmp<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>date<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        executorService<span class="token punctuation">.</span><span class="token function">shutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出的结果中没有重复的时间：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>......
16:36
16:35
16:34
16:33
16:32
16:31
16:30
16:39

Process finished with exit code 0
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="_4-threadlocal-源码初探" tabindex="-1"><a class="header-anchor" href="#_4-threadlocal-源码初探" aria-hidden="true">#</a> 4. ThreadLocal 源码初探</h2><p>ThreadLocal 中的 set 方法很简单：</p><ol><li>获取当前线程的 ThreadLocalMap 实例；</li><li>判断 ThreadLocalMap 是否存在： <ul><li>存在：调用 ThreadLocalMap 的 set 方法；</li><li>不存在：创建 ThreadLocalMap；</li></ul></li></ol><p>源码如下：</p><p><img src="https://run-notes.oss-cn-beijing.aliyuncs.com/notes/202212021536350.png" alt="image-20221202153601534" loading="lazy"></p><p>所以核心逻辑主要是在 ThreadLocalMap 中的 set 方法。</p><h2 id="_5-threadlocalmap-源码剖析" tabindex="-1"><a class="header-anchor" href="#_5-threadlocalmap-源码剖析" aria-hidden="true">#</a> 5. ThreadLocalMap 源码剖析</h2><p>当调用 ThreadLocal 的 set 方法时，如果当前线程的 ThreadLocalMap 不为 null，则会调用 <code>ThreadLocalMap.set(this, value)</code> 来设置值，会先计算 key 在 Entry 数组中的下标（槽位）。</p><p>所以先来看看 ThreadLocalMap 的槽位是怎么计算的。</p><h3 id="_5-1-threadlocalmap-hash-算法" tabindex="-1"><a class="header-anchor" href="#_5-1-threadlocalmap-hash-算法" aria-hidden="true">#</a> 5.1 ThreadLocalMap Hash 算法</h3><p>ThreadLocalMap 肯定也是一个 Map 结构，它实现了自己的 hash 算法。和 HashMap 的 hash 算法相似，用当前 key 的 HashCode 与 (len - 1) 取余，所以 ThreadLocalMap 的 Entry 数组长度也必须为 2 的幂次方（初始容量为 16，扩容倍数为 2）。</p><p><img src="https://run-notes.oss-cn-beijing.aliyuncs.com/notes/202212021642240.png" alt="image-20221202164251887" loading="lazy"></p><p>再来看看这个 <code>key.threadLocalHashCode</code> 值是如何计算的，ThreadLocal 中有一个常量 <strong>HASH_INCREMENT</strong> = 0x61c88647。每当 <strong>创建一个 ThreadLocal 对象</strong> ，这个 <code>ThreadLocal.nextHashCode</code> 的值就会 <strong>增长 0x61c88647</strong>。</p><p><img src="https://run-notes.oss-cn-beijing.aliyuncs.com/notes/202212041532226.png" alt="image-20221204153016353" loading="lazy"></p><p>HASH_INCREMENT = 0x61c88647 这个值很特殊，它是斐波那契数，也叫黄金分割数。hash 增量为这个数字，带来的好处就是 <strong>hash 分布非常均匀</strong>。我们自己可以尝试下：</p><p><img src="https://run-notes.oss-cn-beijing.aliyuncs.com/notes/202212041532689.png" alt="image-20221204153217638" loading="lazy"></p><p>虽然 ThreadLocalMap 中使用了黄金分割数来作为 hash 计算因子，大大减少了 Hash 冲突的概率，但是仍然会存在冲突。</p><p>ThreadLocalMap 中解决哈希冲突的方法比较直接简单，就是 <strong>向后探测</strong>，找到空槽位即可。</p><p>在向后探测的过程中，可能会遇到 key 为 null 的 Entry，这时候会进行一轮 <strong>探测式清理</strong> 工作，后面会讲到。</p><h3 id="_5-2-threadlocalmap-set-详解" tabindex="-1"><a class="header-anchor" href="#_5-2-threadlocalmap-set-详解" aria-hidden="true">#</a> 5.2 ThreadLocalMap.set() 详解</h3><p>前面我们也提到过，ThreadLocal 的 set 方法的主要逻辑在 ThreadLocalMap 的 set 方法中，接下来就详细分析一下。</p><p>往 ThreadLocalMap 中 set 数据（新增或修改）时，分为好几种情况，先浏览一下源码，看看大致的流程：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ThreadLocal</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>
    <span class="token comment">// ......</span>
    <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">ThreadLocalMap</span> <span class="token punctuation">{</span>
        <span class="token comment">// ......</span>
        
        <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">set</span><span class="token punctuation">(</span><span class="token class-name">ThreadLocal</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> key<span class="token punctuation">,</span> <span class="token class-name">Object</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token class-name">Entry</span><span class="token punctuation">[</span><span class="token punctuation">]</span> tab <span class="token operator">=</span> table<span class="token punctuation">;</span>
            <span class="token keyword">int</span> len <span class="token operator">=</span> tab<span class="token punctuation">.</span>length<span class="token punctuation">;</span>
            <span class="token comment">// 1. 获取该 key 在散列表中的槽位</span>
            <span class="token keyword">int</span> i <span class="token operator">=</span> key<span class="token punctuation">.</span>threadLocalHashCode <span class="token operator">&amp;</span> <span class="token punctuation">(</span>len<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

            <span class="token comment">// 2. 从该槽位开始，找到可用的位置</span>
            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Entry</span> e <span class="token operator">=</span> tab<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span> e <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> e <span class="token operator">=</span> tab<span class="token punctuation">[</span>i <span class="token operator">=</span> <span class="token function">nextIndex</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> len<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                
                <span class="token comment">// 2.1 Entry 的引用对象指向该 key，说明是更新数据，则改完 value 返回即可</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span><span class="token function">refersTo</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    e<span class="token punctuation">.</span>value <span class="token operator">=</span> value<span class="token punctuation">;</span>
                    <span class="token keyword">return</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>

                <span class="token comment">// 2.2 引用对象指向 null，说明遇到过期数据，执行替换过期数据的方法，占用该过期数据的槽位</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span><span class="token function">refersTo</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    <span class="token function">replaceStaleEntry</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token keyword">return</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>

            <span class="token comment">// 3. for 循环结束，说明遇到了空槽位，在空槽位添加该 Entry 即可</span>
            tab<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Entry</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">int</span> sz <span class="token operator">=</span> <span class="token operator">++</span>size<span class="token punctuation">;</span>
            
            <span class="token comment">// 4. 先执行一次启发式清理，清理散列表中过期的数据，</span>
            <span class="token comment">// 若未清理掉任何数据 且 数据大小到达 threshold，则进行 rehash 操作</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">cleanSomeSlots</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> sz<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> sz <span class="token operator">&gt;=</span> threshold<span class="token punctuation">)</span>
                <span class="token function">rehash</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>通过上面的分析，set 方法的流程如下：</p><ol><li>通过该 key 的 <code>threadLocalHashCode</code> 和 Entry 数组的长度 <code>len</code> 计算出槽位 <code>i</code>；</li><li>从槽位 <code>i</code> 开始遍历 Entry 数组，在遍历过程中： <ol><li>该 Entry 的引用指向该 key，说明是更新数据，执行更新逻辑，直接退出方法；</li><li>该 Entry 的引用指向 null，说明遇到了过期数据，则执行替换逻辑，占用该过期数据的槽位，直接退出方法；</li></ol></li><li>查找过程中，遇到空槽位，直接使用该槽位即可；</li><li>执行一次启发式清理，清理散列表中过期的数据： <ul><li>若清理到了数据，则方法结束；</li><li>若没清理到数据，则会看当前的数据大小是否已达到 threshold（<code>threshold = len * 2/3</code>），是则进行 rehash 操作；</li></ul></li></ol><p>流程图如下：</p><p><img src="https://run-notes.oss-cn-beijing.aliyuncs.com/notes/202212041829971.png" alt="image-20221204182930626" loading="lazy"></p><p>对过期键的清理过程比较复杂，我们重点来看看替换过期数据的 <code>replaceStaleEntry()</code> 方法。</p><div class="hint-container tip"><p class="hint-container-title">replaceStaleEntry() 方法解读</p></div><p>在执行 set 方法的时候，如果往后探测的过程中遇到了过期的数据（null key），则会执行替换过期数据的方法 <code>replaceStaleEntry()</code>，这个方法的源码如下：</p><p>说明：</p><ul><li><p><code>slotToExpunge</code> 记录清理工作的开始下标，<code>staleSlot</code> 是当前过期数据的下标；</p></li><li><p><code>prevIndex(idx, len)</code> 和 <code>nextIndex(idx, len)</code> 是将下标向前/向后移动，只不过在越界时，会自动移动到尾部/首部，相当于是一个 <strong>循环数组</strong>。</p></li></ul><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">replaceStaleEntry</span><span class="token punctuation">(</span><span class="token class-name">ThreadLocal</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> key<span class="token punctuation">,</span> <span class="token class-name">Object</span> value<span class="token punctuation">,</span> <span class="token keyword">int</span> staleSlot<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">Entry</span><span class="token punctuation">[</span><span class="token punctuation">]</span> tab <span class="token operator">=</span> table<span class="token punctuation">;</span>
    <span class="token keyword">int</span> len <span class="token operator">=</span> tab<span class="token punctuation">.</span>length<span class="token punctuation">;</span>
    <span class="token class-name">Entry</span> e<span class="token punctuation">;</span>

    <span class="token comment">// 初始化 slotToExpunge 位置</span>
    <span class="token keyword">int</span> slotToExpunge <span class="token operator">=</span> staleSlot<span class="token punctuation">;</span>
    
    <span class="token comment">// 向前查找过期的数据，遇到了就更新 slotToExpunge 的位置</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token function">prevIndex</span><span class="token punctuation">(</span>staleSlot<span class="token punctuation">,</span> len<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">(</span>e <span class="token operator">=</span> tab<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> i <span class="token operator">=</span> <span class="token function">prevIndex</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> len<span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span><span class="token function">refersTo</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
            slotToExpunge <span class="token operator">=</span> i<span class="token punctuation">;</span>

    <span class="token comment">// 向后查找</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token function">nextIndex</span><span class="token punctuation">(</span>staleSlot<span class="token punctuation">,</span> len<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">(</span>e <span class="token operator">=</span> tab<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> i <span class="token operator">=</span> <span class="token function">nextIndex</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> len<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        
        <span class="token comment">// 若碰到引用对象指向该 key，说明是更新数据</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span><span class="token function">refersTo</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            e<span class="token punctuation">.</span>value <span class="token operator">=</span> value<span class="token punctuation">;</span>
	    
            <span class="token comment">// 更新完 value 后，将该 Entry位置 与 staleSlot位置 进行交换</span>
            tab<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> tab<span class="token punctuation">[</span>staleSlot<span class="token punctuation">]</span><span class="token punctuation">;</span>
            tab<span class="token punctuation">[</span>staleSlot<span class="token punctuation">]</span> <span class="token operator">=</span> e<span class="token punctuation">;</span>

            <span class="token comment">// 如果之前向前查找没有过期的数据，向后查找也没找到过期数据（下面）</span>
            <span class="token comment">// 则将 slotToExpunge 更新为现在的位置</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>slotToExpunge <span class="token operator">==</span> staleSlot<span class="token punctuation">)</span>
                slotToExpunge <span class="token operator">=</span> i<span class="token punctuation">;</span>
            
            <span class="token comment">// 清理逻辑：先进行探测式清理，再进行启发式清理</span>
            <span class="token function">cleanSomeSlots</span><span class="token punctuation">(</span><span class="token function">expungeStaleEntry</span><span class="token punctuation">(</span>slotToExpunge<span class="token punctuation">)</span><span class="token punctuation">,</span> len<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">return</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

       <span class="token comment">// 遇到过期数据，而且向前查找没有过期的数据，则将 slotToExpunge 更新为现在的位置</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span><span class="token function">refersTo</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> slotToExpunge <span class="token operator">==</span> staleSlot<span class="token punctuation">)</span>
            slotToExpunge <span class="token operator">=</span> i<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 走到这说明不是更新数据，遇到 Entry 为 null了，则将新数据放在过期数据的槽位</span>
    tab<span class="token punctuation">[</span>staleSlot<span class="token punctuation">]</span><span class="token punctuation">.</span>value <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
    tab<span class="token punctuation">[</span>staleSlot<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Entry</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 如果在之前的向前、前后查找过程中，遇到了其他的过期数据，则开启清理逻辑</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>slotToExpunge <span class="token operator">!=</span> staleSlot<span class="token punctuation">)</span>
        <span class="token function">cleanSomeSlots</span><span class="token punctuation">(</span><span class="token function">expungeStaleEntry</span><span class="token punctuation">(</span>slotToExpunge<span class="token punctuation">)</span><span class="token punctuation">,</span> len<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>通过上面的源码解读，<code>replaceStaleEntry()</code> 的执行流程图如下：</p><p><img src="https://run-notes.oss-cn-beijing.aliyuncs.com/notes/202212050034295.png" alt="image-20221205003414069" loading="lazy"></p><p>下面列举一下向前查找没有找到过期数据，向后查找遇到更新数据，且在这之前也没有找到过期数据的情况：</p><p><img src="https://run-notes.oss-cn-beijing.aliyuncs.com/notes/202212050101357.png" alt="image-20221205010122302" loading="lazy"></p><p>其他情况就不画图分析了，都大差不差。现在我们基本上把 <code>ThreadLocalMap.set()</code> 解析完了，还剩下清理工作的逻辑没分析。</p><h3 id="_5-3-清理逻辑" tabindex="-1"><a class="header-anchor" href="#_5-3-清理逻辑" aria-hidden="true">#</a> 5.3 清理逻辑</h3><p>通过上面的分析，可以发现 ThreadLocalMap 对过期数据的清理主要有两种方式：</p><ul><li>探测式清理 <code>expungeStaleEntry(int staleSlot)</code>；</li><li>启发式清理 <code>cleanSomeSlots(int i, int n)</code>；</li></ul><p>接下来我们就分别分析一下这两种清理方式。</p><h4 id="_1-探测式清理" tabindex="-1"><a class="header-anchor" href="#_1-探测式清理" aria-hidden="true">#</a> (1) 探测式清理</h4><p>先浏览一遍探测式清理 <code>expungeStaleEntry(int staleSlot)</code> 的源码：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">private</span> <span class="token keyword">int</span> <span class="token function">expungeStaleEntry</span><span class="token punctuation">(</span><span class="token keyword">int</span> staleSlot<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">Entry</span><span class="token punctuation">[</span><span class="token punctuation">]</span> tab <span class="token operator">=</span> table<span class="token punctuation">;</span>
    <span class="token keyword">int</span> len <span class="token operator">=</span> tab<span class="token punctuation">.</span>length<span class="token punctuation">;</span>

    <span class="token comment">// 清理 staleSlot 位置（将槽位置为 null）</span>
    tab<span class="token punctuation">[</span>staleSlot<span class="token punctuation">]</span><span class="token punctuation">.</span>value <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
    tab<span class="token punctuation">[</span>staleSlot<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
    size<span class="token operator">--</span><span class="token punctuation">;</span>

    <span class="token class-name">Entry</span> e<span class="token punctuation">;</span>
    <span class="token keyword">int</span> i<span class="token punctuation">;</span>
    <span class="token comment">// 循环进行探测式清理，知道遇到 null 的 Entry</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token function">nextIndex</span><span class="token punctuation">(</span>staleSlot<span class="token punctuation">,</span> len<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">(</span>e <span class="token operator">=</span> tab<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> i <span class="token operator">=</span> <span class="token function">nextIndex</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> len<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">ThreadLocal</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> k <span class="token operator">=</span> e<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 遇到过期数据，将该槽位置为 null</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>k <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            e<span class="token punctuation">.</span>value <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
            tab<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
            size<span class="token operator">--</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>    
            <span class="token comment">// 不是过期数据，先计算出该数据的槽位</span>
            <span class="token keyword">int</span> h <span class="token operator">=</span> k<span class="token punctuation">.</span>threadLocalHashCode <span class="token operator">&amp;</span> <span class="token punctuation">(</span>len <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            
            <span class="token comment">// 如果数据不在该槽位上，说明该数据原来发生了哈希冲突，被放在后面去了</span>
            <span class="token comment">// 则会找到离正确槽位最近的空位置，将该数据重新放置，使其更靠近正确槽位</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>h <span class="token operator">!=</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                tab<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
                <span class="token keyword">while</span> <span class="token punctuation">(</span>tab<span class="token punctuation">[</span>h<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
                    h <span class="token operator">=</span> <span class="token function">nextIndex</span><span class="token punctuation">(</span>h<span class="token punctuation">,</span> len<span class="token punctuation">)</span><span class="token punctuation">;</span>
                tab<span class="token punctuation">[</span>h<span class="token punctuation">]</span> <span class="token operator">=</span> e<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> i<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>从源码中可以看出，探测式清理在清理完 <code>staleSlot</code> 位置后，还会向后查找，遇到过期数据就清理。遇到正常数据会将 <strong>产生了哈希冲突的数据重新定位（相当于 rehash），让它离正确的槽位更近</strong>，这样有利于提高查询效率。</p><p>流程图如下：</p><p><img src="https://run-notes.oss-cn-beijing.aliyuncs.com/notes/202212051408230.png" alt="image-20221205140752004" loading="lazy"></p><p>下面列举一个将正常数据重新定位的情况。</p><p>进入 <code>expungeStaleEntry()</code> 方法时，<code>staleSlot = 2</code>，然后 Entry[5] 经过哈希计算的正确槽位是 4，因为发生了哈希碰撞，所以被放置在了槽位为 5 的位置上：</p><p><img src="https://run-notes.oss-cn-beijing.aliyuncs.com/notes/202212051445585.png" alt="image-20221205144546177" loading="lazy"></p><p>进入 <code>expungeStaleEntry()</code> 方法：</p><ul><li>先将清理 <code>staleSlot</code> 位置，接着向后遍历，槽位为 3 的位置是正常数据且槽位位置正确；</li><li>继续遍历，遇到槽位为 4 的过期数据，清理掉该数据，将槽位置为空；</li></ul><p><img src="https://run-notes.oss-cn-beijing.aliyuncs.com/notes/202212051456192.png" alt="image-20221205145658252" loading="lazy"></p><p>继续遍历，遇到槽位为 5 的正常数据，计算得槽位为 4，但现在在 5 号槽位：</p><ul><li>先把现在的槽位（5号）置空，接着从 4 号槽位开始，向后遍历，找到空位置；</li><li>恰好 4 号槽位刚刚被清理了，所以就把该数据放在 4 号槽位上；</li></ul><p><img src="https://run-notes.oss-cn-beijing.aliyuncs.com/notes/202212051459263.png" alt="image-20221205145950289" loading="lazy"></p><p>继续遍历到 6 号槽位，该槽位为空，则该方法结束，返回 6。</p><p>探测式清理就是这么回事儿，接下来看看更简单的启发式清理。</p><h4 id="_2-启发式清理" tabindex="-1"><a class="header-anchor" href="#_2-启发式清理" aria-hidden="true">#</a> (2) 启发式清理</h4><p>只有两个方法会调用到 <code>cleanSomeSlots(int i, int n)</code>，分别是 <code>set</code> 和 <code>replaceStaleEntry</code>：</p><ul><li>当在 <strong>set</strong> 方法中调用时，传入的参数 <code>n</code> <strong>是元素的数量 <code>size</code></strong>；</li><li>当在 <strong>replaceStaleEntry</strong> 方法中调用时，传入的参数 <code>n</code> <strong>是 Entry 数组的长度 <code>len</code></strong>；</li></ul><p>启发式清理 <code>cleanSomeSlots(int i, int n)</code> 的源码分析如下：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">private</span> <span class="token keyword">boolean</span> <span class="token function">cleanSomeSlots</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 是否清理到了数据的标志</span>
    <span class="token keyword">boolean</span> removed <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    <span class="token class-name">Entry</span><span class="token punctuation">[</span><span class="token punctuation">]</span> tab <span class="token operator">=</span> table<span class="token punctuation">;</span>
    <span class="token keyword">int</span> len <span class="token operator">=</span> tab<span class="token punctuation">.</span>length<span class="token punctuation">;</span>
    <span class="token keyword">do</span> <span class="token punctuation">{</span>
        i <span class="token operator">=</span> <span class="token function">nextIndex</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> len<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">Entry</span> e <span class="token operator">=</span> tab<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
        
        <span class="token comment">// 遇到过期数据需要清理，此时会重置 n 为 len，然后执行探测式清理方法清理过期数据</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>e <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> e<span class="token punctuation">.</span><span class="token function">refersTo</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            n <span class="token operator">=</span> len<span class="token punctuation">;</span>
            removed <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
            i <span class="token operator">=</span> <span class="token function">expungeStaleEntry</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span> <span class="token punctuation">(</span>n <span class="token operator">&gt;&gt;&gt;=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 如果没有遇到过期数据，则每次将 n 变为原来的一半</span>
    <span class="token keyword">return</span> removed<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>所以启发式清理的流程图如下：</p><p><img src="https://run-notes.oss-cn-beijing.aliyuncs.com/notes/202212051528880.png" alt="image-20221205152840486" loading="lazy"></p><p>示例如下：</p><p><img src="https://run-notes.oss-cn-beijing.aliyuncs.com/notes/202212051548294.png" alt="image-20221205154830182" loading="lazy"></p><div class="hint-container tip"><p class="hint-container-title">replaceStaleEntry 为什么进行探测式清理后还要进行一次启发式清理呢？</p></div><p>我们知道，探测式清理在遇到 Entry 为 null 时就会停止清理，所以为了清理到后面的一些槽位，就再进行一次启发式清理。这样可以尽可能的清理到更多的过期数据。</p><h3 id="_5-4-扩容机制" tabindex="-1"><a class="header-anchor" href="#_5-4-扩容机制" aria-hidden="true">#</a> 5.4 扩容机制</h3><p>在 <code>ThreadLocalMap.set()</code> 方法的最后，如果执行完 <strong>启发式清理没有清理到数据</strong>，且当前 <strong>散列数组中的 Entry 数量（元素数量）已经达到了扩容阈值 threshold</strong>（threshold = len * 2/3），就开始执行 <strong>rehash()</strong> 逻辑。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">cleanSomeSlots</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> sz<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> sz <span class="token operator">&gt;=</span> threshold<span class="token punctuation">)</span>
    <span class="token function">rehash</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>注意：<strong>此时还没有执行扩容，具体需不需要扩容在 rehash() 方法中判断</strong>。</p><p>rehash() 的具体实现如下：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">rehash</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 先进行一轮全局的探测式清理</span>
    <span class="token function">expungeStaleEntries</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 若清理后的 size 还是 &gt;= threshold * 3/4，则执行 resize() 进行扩容</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>size <span class="token operator">&gt;=</span> threshold <span class="token operator">-</span> threshold <span class="token operator">/</span> <span class="token number">4</span><span class="token punctuation">)</span>
        <span class="token function">resize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>全局的探测式清理 <code>expungeStaleEntries()</code> 其实就是从 Entry 数组的 <strong>起始位置开始往后清理</strong>，遇到过期数据还是调用探测式清理 <code>expungeStaleEntry(int staleSlot)</code> 来清理数据。</p><p>因为探测式清理会 <strong>将正常且不在正确槽位的数据重新放置</strong>，这个重新放置的过程其实就相当于 rehash，所以这个方法叫做 <code>rehash()</code>。</p><p>全局的探测式清理方法如下：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">expungeStaleEntries</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">Entry</span><span class="token punctuation">[</span><span class="token punctuation">]</span> tab <span class="token operator">=</span> table<span class="token punctuation">;</span>
    <span class="token keyword">int</span> len <span class="token operator">=</span> tab<span class="token punctuation">.</span>length<span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> len<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">Entry</span> e <span class="token operator">=</span> tab<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>e <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> e<span class="token punctuation">.</span><span class="token function">refersTo</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
            <span class="token function">expungeStaleEntry</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在全局的探测式清理后，如果 <code>size</code> 还是大于等于 <code>threshold * 3/4</code>，因为 <code>threshold = len * 2/3</code>，所以扩容的 <strong>最终条件</strong> 是：<code>size &gt;= len * 2/3 * 3/4 = len * 1/2</code>，也就是 <strong>元素数量达到了 Entry 数组大小的一半</strong> 时，才进行 <code>resize()</code> 扩容。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code>        <span class="token keyword">private</span> <span class="token keyword">int</span> threshold<span class="token punctuation">;</span> <span class="token comment">// Default to 0</span>

        <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">setThreshold</span><span class="token punctuation">(</span><span class="token keyword">int</span> len<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            threshold <span class="token operator">=</span> len <span class="token operator">*</span> <span class="token number">2</span> <span class="token operator">/</span> <span class="token number">3</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="hint-container tip"><p class="hint-container-title">resize() 扩容流程</p></div><p>真正的扩容函数是 <code>resize()</code>，源码如下：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">resize</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">Entry</span><span class="token punctuation">[</span><span class="token punctuation">]</span> oldTab <span class="token operator">=</span> table<span class="token punctuation">;</span>
    <span class="token keyword">int</span> oldLen <span class="token operator">=</span> oldTab<span class="token punctuation">.</span>length<span class="token punctuation">;</span>
    <span class="token comment">// 扩容到原来的 2 倍</span>
    <span class="token keyword">int</span> newLen <span class="token operator">=</span> oldLen <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">;</span>
    <span class="token comment">// 新定义一个散列表</span>
    <span class="token class-name">Entry</span><span class="token punctuation">[</span><span class="token punctuation">]</span> newTab <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Entry</span><span class="token punctuation">[</span>newLen<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

    <span class="token comment">// 遍历旧的散列表</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Entry</span> e <span class="token operator">:</span> oldTab<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>e <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token class-name">ThreadLocal</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> k <span class="token operator">=</span> e<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment">// 若遇到过期数据，则将 value 也置为 null，以便 GC 回收</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>k <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                e<span class="token punctuation">.</span>value <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> <span class="token comment">// Help the GC</span>
            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
                <span class="token comment">// 计算元素在新散列表中的槽位</span>
                <span class="token keyword">int</span> h <span class="token operator">=</span> k<span class="token punctuation">.</span>threadLocalHashCode <span class="token operator">&amp;</span> <span class="token punctuation">(</span>newLen <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token comment">// 发生哈希冲突时，线性探测</span>
                <span class="token keyword">while</span> <span class="token punctuation">(</span>newTab<span class="token punctuation">[</span>h<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
                    h <span class="token operator">=</span> <span class="token function">nextIndex</span><span class="token punctuation">(</span>h<span class="token punctuation">,</span> newLen<span class="token punctuation">)</span><span class="token punctuation">;</span>
                newTab<span class="token punctuation">[</span>h<span class="token punctuation">]</span> <span class="token operator">=</span> e<span class="token punctuation">;</span>
                count<span class="token operator">++</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 设置新的扩容阈值</span>
    <span class="token function">setThreshold</span><span class="token punctuation">(</span>newLen<span class="token punctuation">)</span><span class="token punctuation">;</span>
    size <span class="token operator">=</span> count<span class="token punctuation">;</span>
    table <span class="token operator">=</span> newTab<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>resize()</code> 方法主要就是将旧散列表中的数据倒入新的散列表，<strong>遇到过期数据则将 value 的引用置为 null</strong>，方便 GC 回收掉。</p><p>ThreadLocalMap 扩容过程的流程图如下：</p><p><img src="https://run-notes.oss-cn-beijing.aliyuncs.com/notes/202212051821004.png" alt="image-20221205182123973" loading="lazy"></p><h3 id="_5-5-threadlocalmap-get-分析" tabindex="-1"><a class="header-anchor" href="#_5-5-threadlocalmap-get-分析" aria-hidden="true">#</a> 5.5 ThreadLocalMap.get() 分析</h3><p>ThreadLocal 调用 get() 方法，和 set() 方法有些类似，都是通过先通过当前线程获取到 ThreadLocalMap。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ThreadLocal</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>
    <span class="token comment">// ......</span>
    <span class="token keyword">public</span> <span class="token class-name">T</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">Thread</span> t <span class="token operator">=</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">ThreadLocalMap</span> map <span class="token operator">=</span> <span class="token function">getMap</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>map <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token class-name">ThreadLocalMap<span class="token punctuation">.</span>Entry</span> e <span class="token operator">=</span> map<span class="token punctuation">.</span><span class="token function">getEntry</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>e <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token annotation punctuation">@SuppressWarnings</span><span class="token punctuation">(</span><span class="token string">&quot;unchecked&quot;</span><span class="token punctuation">)</span>
                <span class="token class-name">T</span> result <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">T</span><span class="token punctuation">)</span>e<span class="token punctuation">.</span>value<span class="token punctuation">;</span>
                <span class="token keyword">return</span> result<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> <span class="token function">setInitialValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>通过上面的源码可以看出：</p><ul><li><p>ThreadLocalMap 不为空时，会先调用 <code>getEntry(this)</code> 获取到当前 key 对应的 Entry，若 Entry 不为 null，则返回该 Entry 的 value 值。若 <strong>Entry 为 null</strong>，则会走下面的 <strong><code>setInitialValue()</code> 方法</strong>。</p></li><li><p>当 <strong>ThreadLocalMap 为空时</strong>，则调用 <strong><code>setInitialValue()</code> 方法</strong>。</p></li></ul><div class="hint-container tip"><p class="hint-container-title">setInitialValue()</p></div><p>先来看看 <code>setInitialValue()</code> 方法，从上面的分析可知，有两种情况会走此方法：</p><ul><li>ThreadLocalMap 为 null，说明当前线程还未创建 Map；</li><li>当前 Entry 为 null，说明当前 Map 中还没有该 key 对应的 Entry；</li></ul><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">private</span> <span class="token class-name">T</span> <span class="token function">setInitialValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">T</span> value <span class="token operator">=</span> <span class="token function">initialValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// initialValue() 返回 null</span>
    <span class="token class-name">Thread</span> t <span class="token operator">=</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">ThreadLocalMap</span> map <span class="token operator">=</span> <span class="token function">getMap</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// map 不为 null，说明是当前 Entry 为 null 走到此方法的</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>map <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        map<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 调用 set 方法</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token comment">// map 为 null，则创建 Map，将该 ThreadLocal 的 value 设为 null</span>
        <span class="token function">createMap</span><span class="token punctuation">(</span>t<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span> <span class="token keyword">instanceof</span> <span class="token class-name">TerminatingThreadLocal</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">TerminatingThreadLocal</span><span class="token punctuation">.</span><span class="token function">register</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">TerminatingThreadLocal</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">)</span> <span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> value<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>看完源码后可能会发现，为什么 map 不为空，当前 entry 为空时，要调用 <code>set</code> 方法呢？</p><p>答案其实都在 <code>set</code> 方法里，可能会进行 <strong>探测式清理</strong> 操作、<strong>rehash()</strong> 等。</p><div class="hint-container tip"><p class="hint-container-title">getEntry(ThreadLocal key)</p></div><p>在 ThreadLocalMap 不为 null 时，就会调用 <code>getEntry(ThreadLocal&lt;?&gt; key)</code> 来获取当前 ThreadLocal 对应的 Entry，源码如下：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">private</span> <span class="token class-name">Entry</span> <span class="token function">getEntry</span><span class="token punctuation">(</span><span class="token class-name">ThreadLocal</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> i <span class="token operator">=</span> key<span class="token punctuation">.</span>threadLocalHashCode <span class="token operator">&amp;</span> <span class="token punctuation">(</span>table<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">Entry</span> e <span class="token operator">=</span> table<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token comment">// 若计算出来的槽位刚好是要 get 元素的位置时，直接返回该 Entry</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>e <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> e<span class="token punctuation">.</span><span class="token function">refersTo</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> e<span class="token punctuation">;</span>
    <span class="token keyword">else</span>
        <span class="token comment">// 没有直接命中，调用 getEntryAfterMiss() 方法</span>
        <span class="token keyword">return</span> <span class="token function">getEntryAfterMiss</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> i<span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在该方法中，若计算出来的槽位刚好是要获取的元素的槽位时，说明刚好命中，则直接返回该 Entry。</p><p>否则，说明没有直接命中，可能存在哈希冲突（因为还有此元素不存在的情况），则会调用 <code>getEntryAfterMiss(ThreadLocal&lt;?&gt; key, int i, Entry e)</code> 方法。</p><p><code>getEntryAfterMiss()</code> 方法的源码如下：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">private</span> <span class="token class-name">Entry</span> <span class="token function">getEntryAfterMiss</span><span class="token punctuation">(</span><span class="token class-name">ThreadLocal</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> key<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token class-name">Entry</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">Entry</span><span class="token punctuation">[</span><span class="token punctuation">]</span> tab <span class="token operator">=</span> table<span class="token punctuation">;</span>
    <span class="token keyword">int</span> len <span class="token operator">=</span> tab<span class="token punctuation">.</span>length<span class="token punctuation">;</span>

    <span class="token comment">// 当 entry 不为 null 时，向后查找</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>e <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 找到该 key 对应的 entry 了，直接返回</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span><span class="token function">refersTo</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span>
            <span class="token keyword">return</span> e<span class="token punctuation">;</span>
        <span class="token comment">// 遇到过期数据，执行探测式清理</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span><span class="token function">refersTo</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
            <span class="token function">expungeStaleEntry</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">else</span>
            i <span class="token operator">=</span> <span class="token function">nextIndex</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> len<span class="token punctuation">)</span><span class="token punctuation">;</span>
        e <span class="token operator">=</span> tab<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 向后查找到空 entry，都没找到，说明不存在该元素，返回 null</span>
    <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>可以看到，在向后查找时，若遇到过期数据，会执行探测式清理，探测式清理除了会清理掉过期数据，还会进行 rehash（槽位重置），所以清理完后继续从该位置开始遍历。</p><div class="hint-container tip"><p class="hint-container-title">总结</p></div><p>当调用 <code>ThreadLocal.get()</code> 方法时，流程如下：</p><p><img src="https://run-notes.oss-cn-beijing.aliyuncs.com/notes/202212051928666.png" alt="image-20221205192838651" loading="lazy"></p><p><code>setInitialValue()</code> 方法流程如下：</p><p><img src="https://run-notes.oss-cn-beijing.aliyuncs.com/notes/202212051952372.png" alt="image-20221205195213343" loading="lazy"></p><p><code>getEntry()</code> 方法流程如下：</p><p><img src="https://run-notes.oss-cn-beijing.aliyuncs.com/notes/202212051932953.png" alt="image-20221205193246822" loading="lazy"></p><p><code>getEntryAfterMiss()</code> 方法流程如下：</p><p><img src="https://run-notes.oss-cn-beijing.aliyuncs.com/notes/202212051945423.png" alt="image-20221205194548986" loading="lazy"></p><h2 id="_6-inheritablethreadlocal-类" tabindex="-1"><a class="header-anchor" href="#_6-inheritablethreadlocal-类" aria-hidden="true">#</a> 6. InheritableThreadLocal 类</h2><p>ThreadLocal 是线程隔离的，那如果我想在子线程中获取到父线程中的元素怎么办呢？</p><p>这就需要使用 InheritableThreadLocal（可继承的 ThreadLocal）了，它继承了 ThreadLocal，主要功能就是 <strong>对于 InheritableThreadLocal 类型变量的值，在子线程中可以获取到</strong>。</p><p>通过下面的示例来说明：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">InheritableThreadLocalTest</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">ThreadLocal</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> threadLocal <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ThreadLocal</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">ThreadLocal</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> inheritableThreadLocal <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">InheritableThreadLocal</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// 在 main 线程中设置变量值</span>
        threadLocal<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token string">&quot;ThreadLocal Data&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        inheritableThreadLocal<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token string">&quot;InheritableThreadLocal Data&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// 子线程中分别获取两个变量</span>
        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;ThreadLocal Data: &quot;</span> <span class="token operator">+</span> threadLocal<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;InheritableThreadLocal Data: &quot;</span> <span class="token operator">+</span> inheritableThreadLocal<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">/*
输出：
ThreadLocal Data: null
InheritableThreadLocal Data: InheritableThreadLocal Data

Process finished with exit code 0
 */</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>通过前面对 ThreadLocal 的理解，在 Thread 中有一个 ThreadLocalMap，以 ThreadLocal 类型的变量作为 key，我们 set 的值作为 value。在子线程中执行 get 方法自然是获取子线程的 ThreadLocalMap，很显然，子线程中的 ThreadLocalMap 并没有进行设置，所以初始值 null 被读了出来。</p><p>那么，InheritableThreadLocal 类型变量的值，为什么子线程能够读取到呢？</p><h3 id="_6-1-原理分析" tabindex="-1"><a class="header-anchor" href="#_6-1-原理分析" aria-hidden="true">#</a> 6.1 原理分析</h3><p>在 Thread 类中，有一个 <code>ThreadLocal.ThreadLocalMap</code> 类型的变量 <code>inheritableThreadLocals</code>，有没有发现很熟悉？这不就是和 Thread 类中的 <code>threadLocals</code> 变量一样嘛？</p><p><img src="https://run-notes.oss-cn-beijing.aliyuncs.com/notes/202212052112277.png" alt="image-20221205211230191" loading="lazy"></p><p>在 JDK 1.8 中，Thread 的构造方法中有一个 <code>init()</code> 方法，这个 <code>init()</code> 方法是所有的 Thread 对象创建的必经之路：</p><p><img src="https://run-notes.oss-cn-beijing.aliyuncs.com/notes/202212052201704.png" alt="image-20221205220149328" loading="lazy"></p><p>这个带 Runnable 参数的 init 方法，内部会调用另一个重载的 init 方法，默认把 <code>inheritThreadLocals</code> 参数设为 true：</p><p><img src="https://run-notes.oss-cn-beijing.aliyuncs.com/notes/202212052217570.png" alt="image-20221205221706365" loading="lazy"></p><p>可以看到，在方法中如果判断 <strong>父线程的 <code>inheritableThreadLocals</code> 不为 null</strong>，则会 <strong>通过 <code>createInheritedMap()</code> 方法创建当前子线程的 <code>inheritableThreadLocals</code></strong>。</p><p>来看看 ThreadLocal 的 <code>createInheritedMap(ThreadLocalMap parentMap)</code> 方法，可以发现，<strong>传入的参数是父线程的 Map</strong>（<code>parent.inheritableThreadLocals</code>），这个方法其实就是 <strong>根据父线程的 ThreadLocalMap，拷贝里面的数据给子线程的 ThreadLocalMap</strong>：</p><p><img src="https://run-notes.oss-cn-beijing.aliyuncs.com/notes/202212052231389.png" alt="image-20221205223112365" loading="lazy"></p><p>从上面的这个方法可以很清晰的看得到，<strong>如果 parent 的 <code>inheritableThreadLocals</code> 不是 null，</strong><br><strong>那么就会将当前子线程的 <code>inheritableThreadLocals</code> 设置为 parent 的 <code>inheritableThreadLocals</code></strong>。</p><p>所以借助于 <code>inheritableThreadLocals</code>，可以实现创建线程向被创建线程进行数据的传递。</p><p>这里需要注意以下 <code>key.childValue(e.value)</code> 这个方法：</p><p><img src="https://run-notes.oss-cn-beijing.aliyuncs.com/notes/202212141640894.png" alt="image-20221214164047117" loading="lazy"></p><p>可以发现，它直接返回传入的参数，也就是把传进来的父类的 value 对象直接赋值给子类，即 <strong>子类和父类使用的是同一个 value 对象</strong>。</p><p>另外，在 JDK 17 中 Thread 的 <code>init()</code> 方法不再被使用，Thread 的构造函数中不会调用 <code>init()</code> 方法，而是直接把 <code>init()</code> 的代码放到自己的构造函数中，所以只需要调用本身的构造方法即可。</p><h3 id="_6-2-inheritablethreadlocal-的缺陷" tabindex="-1"><a class="header-anchor" href="#_6-2-inheritablethreadlocal-的缺陷" aria-hidden="true">#</a> 6.2 InheritableThreadLocal 的缺陷</h3><p>InheritableThreadLocal 仍然有缺陷，一般我们做异步化处理都是使用的 <strong>线程池</strong>，线程池是线程复用的逻辑，而 InheritableThreadLocal 是在 Thread 构造方法中的 <code>init()</code> 方法给赋值的，所以这里会存在问题。</p><p>在线程池中，我们都是直接使用线程池已经创建好的线程，所以可能会出现如下两个问题：</p><p>下面假设业务线程是父线程，线程池中的线程是子线程，需要执行业务线程执行过程中的某个任务。</p><ul><li>问题一：处理业务的线程并不创建线程池中的线程，因此线程池中的线程在被创建时，它的父线程的 <code>inheritableThreadLocals</code> 肯定为 null，那么 <strong>线程池中的线程也就获取不到业务线程中的 InheritableThreadLocal 变量</strong>；</li><li>问题二：如果处理业务的线程就是主线程，主线程也负责创建线程池中的线程，那么虽然线程池中的线程能获取到业务线程的 InheritableThreadLocal 变量，但每个线程获取到的都是一样的（因为所有子类和父类共用一个 value 对象）。也就是说，<strong>线程池中的某个线程改变了 InheritableThreadLocal 变量的值，那么其他线程也会被影响</strong>。</li></ul><blockquote><p>问题二的解决方法</p></blockquote><p>第二个问题很好解决，上面也提到了 <code>key.childValue(e.value)</code> 这个方法：</p><p><img src="https://run-notes.oss-cn-beijing.aliyuncs.com/notes/202212141640894.png" alt="image-20221214164047117" loading="lazy"></p><p>它直接返回传入的参数，也就是把传进来的父类的 value 对象直接赋值给子类，即 <strong>子类和父类使用的是同一个 value 对象</strong>。</p><p>该方法的注释中也说明了，“此方法仅返回其输入参数，如果需要不同的行为，则应该重写该方法”。</p><p>所以，我们可以继承 InheritableThreadLocal 重写 <code>childValue()</code> 方法，做一次深拷贝即可，让子类和父类使用不同的对象。但是这样做之后，父类中的对象更改就不能影响子类的对象了。</p><blockquote><p>问题一的解决方法</p></blockquote><p>问题一的关键在于业务和功能不在同一个地方进行，这是常见的场景，例如业务线程只是将任务对象（实现了 Runnable 或者 Callable 的对象）加入到任务队列中，然后让线程池去执行任务队列中的任务。</p><p>所以我们实际上需要的是：<strong>把任务提交给线程池时</strong> 的 <code>ThreadLocal</code> 值传递到 <strong>任务执行时</strong> 继续使用。</p>`,239),h={href:"https://github.com/alibaba/transmittable-thread-local",target:"_blank",rel:"noopener noreferrer"},b=c('<h2 id="_7-threadlocal-使用注意事项" tabindex="-1"><a class="header-anchor" href="#_7-threadlocal-使用注意事项" aria-hidden="true">#</a> 7. ThreadLocal 使用注意事项</h2><h3 id="_7-1-避免线程复用-线程池-时的脏数据" tabindex="-1"><a class="header-anchor" href="#_7-1-避免线程复用-线程池-时的脏数据" aria-hidden="true">#</a> 7.1 避免线程复用（线程池）时的脏数据</h3><p>在使用线程池的情况下，会有线程复用的情况，一个线程可能会处理多个任务。</p><p>由于线程池会复用 Thread 对象，因此 Thread 类的成员变量 threadLocals（ThreadLocalMap）也会被复用。</p><p>如果在一个线程处理完当前任务后，<strong>忘记将该 ThreadLocal 进行清理 <code>remove()</code></strong>，并且这个线程在处理下一个任务时，<strong>不调用 <code>set()</code> 设置值</strong>（调用 <code>set()</code> 会将之前 ThreadLocal 对应的 value 修改掉），那么这时也 <strong>能获取到之前的 ThreadLocal 变量对应的值</strong>。</p><p>例如，thread-1 在处理下一个任务时，能获取到上一个任务中 ThreadLocal 的值：</p><p><img src="https://run-notes.oss-cn-beijing.aliyuncs.com/notes/202212052355780.png" alt="image-20221205235551233" loading="lazy"></p><p>所以，在线程复用的情况下，一定要注意及时进行 threadlocals 的清理工作。</p><h3 id="_7-2-内存泄漏问题" tabindex="-1"><a class="header-anchor" href="#_7-2-内存泄漏问题" aria-hidden="true">#</a> 7.2 内存泄漏问题</h3><p>在一开始也讲到过，<strong>如果一个 ThreadLocal 不存在外部强引用时（外界把 ThreadLocal 变量置为 null），key 势必会被 GC 回收，这样就会导致 ThreadLocalMap 中的 key 为 null，而 value 不为 null</strong>，只有 Thread 线程销毁后，ThreadLocalMap 才会随之销毁，value 的强引用链条才会断掉。</p><p>但是如果 <strong>线程迟迟不关闭（比如使用线程池），这些 key 为 null 对应的 value 就会一直存在 Entry 中</strong>，占用内存空间，又无法回收，就造成了 <strong>内存泄漏</strong>。</p><p>其实，ThreadLocalMap 的设计中已经考虑到这种情况，也加上了一些防护措施：</p><ul><li>在 ThreadLocal 的 <code>get()</code>，<code>set()</code>，<code>remove()</code> 的时候都会清除掉 ThreadLocalMap 里一些 key 为 null 的 entry；</li></ul><p>解决以上问题的办法很简单，就是在每次用完 ThreadLocal 后，及时调用 <code>remove()</code> 方法清理即可。</p><h2 id="_8-参考文章" tabindex="-1"><a class="header-anchor" href="#_8-参考文章" aria-hidden="true">#</a> 8. 参考文章</h2>',15),g={href:"https://juejin.cn/post/6844904151567040519",target:"_blank",rel:"noopener noreferrer"};function y(T,L){const e=o("router-link"),p=o("ExternalLinkIcon");return i(),u("div",null,[n("details",d,[k,n("nav",v,[n("ul",null,[n("li",null,[s(e,{to:"#_1-什么是-threadlocal"},{default:t(()=>[a("1. 什么是 ThreadLocal？")]),_:1})]),n("li",null,[s(e,{to:"#_2-threadlocal-内部设计"},{default:t(()=>[a("2. ThreadLocal 内部设计")]),_:1}),n("ul",null,[n("li",null,[s(e,{to:"#_2-1-早期设计"},{default:t(()=>[a("2.1 早期设计")]),_:1})]),n("li",null,[s(e,{to:"#_2-2-jdk-1-8-的设计"},{default:t(()=>[a("2.2 JDK 1.8 的设计")]),_:1})]),n("li",null,[s(e,{to:"#_2-3-threadlocalmap-的实现"},{default:t(()=>[a("2.3 ThreadLocalMap 的实现")]),_:1})]),n("li",null,[s(e,{to:"#_2-4-threadlocal-会发生内存泄漏吗"},{default:t(()=>[a("2.4 ThreadLocal 会发生内存泄漏吗？")]),_:1})]),n("li",null,[s(e,{to:"#_2-5-key-为什么设计成弱引用"},{default:t(()=>[a("2.5 key 为什么设计成弱引用？")]),_:1})]),n("li",null,[s(e,{to:"#_2-5-value-为什么不设计成弱引用呢"},{default:t(()=>[a("2.5 value 为什么不设计成弱引用呢？")]),_:1})])])]),n("li",null,[s(e,{to:"#_3-threadlocal-应用场景"},{default:t(()=>[a("3. ThreadLocal 应用场景")]),_:1}),n("ul",null,[n("li",null,[s(e,{to:"#_3-1-维护数据库连接对象-connection"},{default:t(()=>[a("3.1 维护数据库连接对象 Connection")]),_:1})]),n("li",null,[s(e,{to:"#_3-2-保存用户信息"},{default:t(()=>[a("3.2 保存用户信息")]),_:1})]),n("li",null,[s(e,{to:"#_3-3-保存线程不安全的工具类"},{default:t(()=>[a("3.3 保存线程不安全的工具类")]),_:1})])])]),n("li",null,[s(e,{to:"#_4-threadlocal-源码初探"},{default:t(()=>[a("4. ThreadLocal 源码初探")]),_:1})]),n("li",null,[s(e,{to:"#_5-threadlocalmap-源码剖析"},{default:t(()=>[a("5. ThreadLocalMap 源码剖析")]),_:1}),n("ul",null,[n("li",null,[s(e,{to:"#_5-1-threadlocalmap-hash-算法"},{default:t(()=>[a("5.1 ThreadLocalMap Hash 算法")]),_:1})]),n("li",null,[s(e,{to:"#_5-2-threadlocalmap-set-详解"},{default:t(()=>[a("5.2 ThreadLocalMap.set() 详解")]),_:1})]),n("li",null,[s(e,{to:"#_5-3-清理逻辑"},{default:t(()=>[a("5.3 清理逻辑")]),_:1})]),n("li",null,[s(e,{to:"#_5-4-扩容机制"},{default:t(()=>[a("5.4 扩容机制")]),_:1})]),n("li",null,[s(e,{to:"#_5-5-threadlocalmap-get-分析"},{default:t(()=>[a("5.5 ThreadLocalMap.get() 分析")]),_:1})])])]),n("li",null,[s(e,{to:"#_6-inheritablethreadlocal-类"},{default:t(()=>[a("6. InheritableThreadLocal 类")]),_:1}),n("ul",null,[n("li",null,[s(e,{to:"#_6-1-原理分析"},{default:t(()=>[a("6.1 原理分析")]),_:1})]),n("li",null,[s(e,{to:"#_6-2-inheritablethreadlocal-的缺陷"},{default:t(()=>[a("6.2 InheritableThreadLocal 的缺陷")]),_:1})])])]),n("li",null,[s(e,{to:"#_7-threadlocal-使用注意事项"},{default:t(()=>[a("7. ThreadLocal 使用注意事项")]),_:1}),n("ul",null,[n("li",null,[s(e,{to:"#_7-1-避免线程复用-线程池-时的脏数据"},{default:t(()=>[a("7.1 避免线程复用（线程池）时的脏数据")]),_:1})]),n("li",null,[s(e,{to:"#_7-2-内存泄漏问题"},{default:t(()=>[a("7.2 内存泄漏问题")]),_:1})])])]),n("li",null,[s(e,{to:"#_8-参考文章"},{default:t(()=>[a("8. 参考文章")]),_:1})])])])]),m,n("p",null,[a("阿里开源了一个 "),n("a",h,[a("TransmittableThreadLocal"),s(p)]),a(" 组件，可以解决这个问题。")]),b,n("ul",null,[n("li",null,[n("a",g,[a("万字解析 ThreadLocal"),s(p)])])])])}const x=l(r,[["render",y],["__file","ThreadLocal详解.html.vue"]]);export{x as default};
