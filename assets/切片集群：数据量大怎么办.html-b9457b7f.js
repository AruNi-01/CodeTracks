import{_ as o}from"./plugin-vue_export-helper-c27b6911.js";import{r as a,o as i,c as l,b as s,e as n,w as e,a as g,d as r}from"./app-61ed31ff.js";const p={},d={class:"hint-container details"},c=s("summary",null,"本文内容",-1),u={class:"table-of-contents"},_=g(`<h2 id="_1-纵向扩展-vs-横向扩展" tabindex="-1"><a class="header-anchor" href="#_1-纵向扩展-vs-横向扩展" aria-hidden="true">#</a> 1. 纵向扩展 vs 横向扩展</h2><p>当 Redis 需要保存大量数据时，一般都有两种方案，纵向扩展（scale up）和横向扩展（scale out）：</p><ul><li><strong>纵向扩展</strong>：<strong>升级单个实例的配置</strong>，比如增加内存容量、CPU 核数和磁盘容量等；</li><li><strong>横向扩展</strong>：<strong>增加实例的个数</strong>，比如从 1 台实例增加到 3 态。</li></ul><p><img src="https://run-notes.oss-cn-beijing.aliyuncs.com/notes/https%2Fstatic001.geekbang.org%2Fresource%2Fimage%2F7a%2F1a-2024_01_06-1704527210.jpeg" alt="img" loading="lazy"></p><p>这两种方式各有什么优缺点呢？</p><p><strong>纵向扩展</strong> 一个很明显的好处就是 <strong>实施起来简单、直接</strong>，因为只需要使用更高规格的服务器即可，不需要关注其他。</p><p>但也有两个缺点：</p><ul><li>当使用 <strong>RDB 快照</strong> 进行持久化时，如果一台实例上的数据量过大，内存使用过多，<strong>主线程在 fork 子进程时可能会造成阻塞</strong>，因为内存太大会导致 <strong>拷贝页表时耗时较长</strong>。同理，若使用 AOF 日志，<strong>AOF 重写时也会造成阻塞</strong>；</li><li><strong>硬件和成本有所限制</strong>，比如把内存从 32GB 扩展到 64GB 还算容易，但要扩展到几百 GB，甚至 1 TB，就很难找到这么大容量的内存了，而且价格成本也会大大增加。</li></ul><p>而横向扩展就可以很好的避免上面纵向扩展的问题，因为只需要增加实例个数即可，实例的内存小点也没关系。<strong>在百万、千万级用户规模时，横向扩展是一个很好的选择</strong>。</p><h2 id="_2-redis-切片集群-—-cluster-方案" tabindex="-1"><a class="header-anchor" href="#_2-redis-切片集群-—-cluster-方案" aria-hidden="true">#</a> 2. Redis 切片集群 — Cluster 方案</h2><p>在 Redis 中，提供了 <strong>切片集群</strong> 来支持横向扩展，<strong>切片集群是由多个 Redis 实例组成的集群，会按照一定规则把数据划分到多个实例中</strong>。</p><p>不过对于切片集群，需要考虑一个复杂的问题，就是数据存在哪个切片上，这个映射规则是什么？客户端怎么访问实例？</p><p>这些都是 Redis 切片集群需要解决的问题，而 Redis 3.0 开始，提供了一个名为 Redis Cluster 的方案，用来实现切片集群，解决了上面的问题。</p><h3 id="_2-1-数据和实例的映射关系" tabindex="-1"><a class="header-anchor" href="#_2-1-数据和实例的映射关系" aria-hidden="true">#</a> 2.1 数据和实例的映射关系</h3><p>在切片集群中，数据是分布到不同的实例上的，首先要解决的就是数据和实例之间如何映射？<strong>在 Redis Cluster 方案中规定了数据和实例的对应规则</strong>。</p><p>Redis Cluster 采用 <strong>哈希槽 Hash Slot</strong> 来处理数据和实例之间的映射关系。在 Redis Cluster 方案中，<strong>一个切片集群有 16384 个哈希槽，每个键值对会根据 key 被映射到一个哈希槽中</strong>，这个映射过程分为两步：</p><ol><li>根据 key 按照 CRC16 算法计算出一个 16 bit 的值；</li><li>用该 16 bit 值对 16384 取模，得到一个 0~16384 内的模数，每个模数代表一个哈希槽。</li></ol><p><strong>key 映射到哈希槽后，这些哈希槽又会被映射到具体的 Redis 实例上</strong>，下面来看看哈希槽到实例的映射规则。</p><p>在部署 Redis Cluster 方案时，可以使用 <strong><code>cluster create</code> 命令创建集群</strong>，此时 Redis 会 <strong>把 16384 个哈希槽平均分配在集群中</strong>。例如有 N 个实例的集群，那每个实例上会有 16384/N 个哈希槽。</p><p>除了平均分配外，也可以使用 <strong><code>cluster meet</code> 命令手动建立实例间的连接，形成集群</strong>，然后使用 <strong><code>cluster addslots</code> 命令指定每个实例上的哈希槽个数</strong>。想要根据 Redis 服务器不同配置，分配不同数量的哈希槽时，可以使用该手动分配方法。</p><p>不过需要注意，<strong>在手动分配哈希槽时，要把 16384 个哈希槽都分配完</strong>，否则 Redis 集群无法正常工作。</p><p>到此，<strong>通过哈希槽完成了数据和实例的映射</strong>，<strong>数据、哈希槽、实例这三者的映射</strong> 就像下面这样：</p><p><img src="https://run-notes.oss-cn-beijing.aliyuncs.com/notes/https%2Fstatic001.geekbang.org%2Fresource%2Fimage%2F7d%2Fab-2024_01_06-1704531224.jpeg" alt="img" loading="lazy"></p><h3 id="_2-2-客户端访问实例" tabindex="-1"><a class="header-anchor" href="#_2-2-客户端访问实例" aria-hidden="true">#</a> 2.2 客户端访问实例</h3><p>有了数据和实例的映射关系后，还需要解决 <strong>客户端如何知道要访问的数据在哪个实例上</strong>？</p><p>首先来看看键值对到实例的映射路径：<strong>键值对的 key -&gt; 哈希槽位 -&gt; 实例</strong>。</p><p>客户端本身可以在发送请求时通过 CRC16 算法对 key 进行计算，再对 16384 取模，得到哈希槽位，但是 <strong>客户端如何知道该哈希槽分布在哪个实例上呢</strong>？</p><p><strong>客户端在和集群实例建立连接后，Redis 实例就会把哈希槽的分配信息发送给客户端</strong>，但是，<strong>每个实例只知道自己身上的哈希槽，不知道其他实例的</strong>，那客户端怎么 <strong>在访问任何一个实例时，就能获取到所有的哈希槽信息呢</strong>？</p><p>其实，<strong>Redis 实例之间会互相共享哈希槽的分配信息，当实例之间互相连接后，每个实例就都有所有哈希槽的映射关系了</strong>。</p><p><strong>客户端收到哈希槽信息后，就会把哈希槽信息缓存在本地，客户端请求时，先计算出 key 的哈希槽后，就可以向对应的实例发送请求了</strong>。</p><p>不过 <strong>哈希槽和实例的映射不是一成不变的</strong>，比如：</p><ul><li><strong>集群实例数量的扩容或缩容</strong>，都会导致哈希槽的重新分配；</li><li>为了 <strong>将数据负载均衡</strong>，需要把哈希槽重新分配一遍。</li></ul><p>此时 <strong>集群实例之间还可以通过互相传递信息获取最新的哈希槽分配信息</strong>，但 <strong>客户端是无法主动感知这些变化的</strong>，如果还按照本地缓存的信息去请求，怎么请求得到数据呢？</p><p>Redis Cluster 方案提供了一种 <strong>重定向机制</strong>，客户端在向一个实例发送请求时，<strong>如果该实例上没有该数据对应的哈希槽，就会响应下面的 MOVED 命令，其中包含了新实例的访问地址</strong>：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>GET hello:key
<span class="token punctuation">(</span>error<span class="token punctuation">)</span> MOVED <span class="token number">13320</span> <span class="token number">172.16</span>.19.5:6379
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>该 MOVED 命令表示客户端请求的键值对所在的哈希槽 13320 实际在 172.16.19.5 实例上。</p><p><strong>通过这个 MOVED 命令，就相当于把该哈希槽所在的新实例的信息告诉了客户端，客户端知道后就会更新本地缓存</strong>。</p><p>例如，由于负载均衡，Slot 2 从实例 2 迁移到了实例 3，客户端请求的逻辑如下：</p><p><img src="https://run-notes.oss-cn-beijing.aliyuncs.com/notes/https%2Fstatic001.geekbang.org%2Fresource%2Fimage%2F35%2F09-2024_01_06-1704534955.jpeg" alt="img" loading="lazy"></p><p>注意，如果 Slot 2 中的数据比较多，可能会出现数据一部分迁移到了实例 3 上，还有一部分任然在实例 2 中的情况。在这种 <strong>迁移部分完成</strong> 的情况下，客户端会收到一条 ASK 信息，如下所示：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>GET hello:key
<span class="token punctuation">(</span>error<span class="token punctuation">)</span> ASK <span class="token number">13320</span> <span class="token number">172.16</span>.19.5:6379
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>该 ASK 命令表示，客户端请求的键值对所在的哈希槽 13320 在 172.16.19.5 实例上，但是 <strong>该哈希槽正在迁移</strong>。</p><p>此时客户端需要 <strong>先给 172.16.19.5 实例发送 ASKING 命令</strong>，表示 <strong>该实例允许执行客户端接下来发送的命令</strong>。然后客户端 <strong>再向该实例发送 GET 命令</strong>，才能读取到数据。</p><p>例如，Slot 2 正在从实例 2 迁移到实例 3，key1、key2 已经迁移过去，key3、key4 还在实例 2 中。此时客户端向实例 2 请求 key2 时，就会收到 ASK 命令，然后客户端可以先发送 ASKING 命令，再发送 get key2 命令获取数据：</p><p><img src="https://run-notes.oss-cn-beijing.aliyuncs.com/notes/https%2Fstatic001.geekbang.org%2Fresource%2Fimage%2Fe9%2Fb0-2024_01_06-1704536177.jpeg" alt="img" loading="lazy"></p><p>注意：和 MOVED 命令不同，<strong>ASK 命令不会更新客户端的本地缓存</strong>。</p><h2 id="_3-为什么不直接把-key-映射到实例-而要采用哈希槽" tabindex="-1"><a class="header-anchor" href="#_3-为什么不直接把-key-映射到实例-而要采用哈希槽" aria-hidden="true">#</a> 3. 为什么不直接把 key 映射到实例，而要采用哈希槽？</h2><p>Redis Cluster 方案 通过哈希槽把键值对分配到不同的实例上，这个过程需要对键值对的 key 做 CRC16 计算，然后再和哈希槽做映射。而如果 <strong>用一个映射表直接把键值对和实例的对应关系记录下来（例如键值对 1 在实例 2 上，键值对 2 在实例 1 上），这样就只用查表即可</strong>，Redis 为什么不这么做呢？</p><p>这是因为，<strong>当数据量非常多时，该映射表会非常庞大</strong>，无论该映射表存储在客户端还是服务端，都会 <strong>占用大量的内存空间</strong>。</p><p>而且通过上面的内容也知道，Redis Cluster 方案会 <strong>将映射信息共享到所有的实例上，以达到在数据迁移后的重定向的功能，所以每个实例上都有完整的路由信息</strong>。如果采用映射表，<strong>该映射表非常庞大时，实例间需要交换路由表信息就会消耗更多的网络资源，而且实例存储的路由表也会占用更多的内存</strong>。</p><p>采用哈希槽的方式，<strong>无论数据量多大，哈希槽的数量都是固定的 16384 个</strong>，所以实例只需要存储这么多个槽位信息，占用的内存不是很大。</p><p><strong>在集群扩容、缩容、负载均衡时，实例中的数据会发生迁移，如果直接把 key 映射到实例，那会涉及到大量 key 映射关系的修改，维护成本太高</strong>。</p><p>因此，综合考虑，使用哈希槽是一个更合适的选择。</p><h2 id="_4-参考文章" tabindex="-1"><a class="header-anchor" href="#_4-参考文章" aria-hidden="true">#</a> 4. 参考文章</h2><ul><li>《Redis 核心技术与实战》</li></ul>`,55);function h(m,k){const t=a("router-link");return i(),l("div",null,[s("details",d,[c,s("nav",u,[s("ul",null,[s("li",null,[n(t,{to:"#_1-纵向扩展-vs-横向扩展"},{default:e(()=>[r("1. 纵向扩展 vs 横向扩展")]),_:1})]),s("li",null,[n(t,{to:"#_2-redis-切片集群-—-cluster-方案"},{default:e(()=>[r("2. Redis 切片集群 — Cluster 方案")]),_:1}),s("ul",null,[s("li",null,[n(t,{to:"#_2-1-数据和实例的映射关系"},{default:e(()=>[r("2.1 数据和实例的映射关系")]),_:1})]),s("li",null,[n(t,{to:"#_2-2-客户端访问实例"},{default:e(()=>[r("2.2 客户端访问实例")]),_:1})])])]),s("li",null,[n(t,{to:"#_3-为什么不直接把-key-映射到实例-而要采用哈希槽"},{default:e(()=>[r("3. 为什么不直接把 key 映射到实例，而要采用哈希槽？")]),_:1})]),s("li",null,[n(t,{to:"#_4-参考文章"},{default:e(()=>[r("4. 参考文章")]),_:1})])])])]),_])}const R=o(p,[["render",h],["__file","切片集群：数据量大怎么办.html.vue"]]);export{R as default};
