const t=JSON.parse('{"key":"v-03d322b4","path":"/backend/database/mysql/transaction/%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86.html","title":"隔离级别的实现原理","lang":"zh-CN","frontmatter":{"title":"隔离级别的实现原理","date":"2023-12-07T00:00:00.000Z","order":3,"category":["数据库"],"tag":["MySQL"],"sticky":false,"star":false,"article":true,"timeline":true,"description":"本文内容 1. 四种隔离级别是如何实现的？ 在四种隔离级别中，读未提交和串行化的实现是最简单的，基本不需要做过多的事情： 读未提交：每次读取数据时，不做任何措施，直接读取最新数据 就好了，所以可以读到未提交的数据； 串行化：通过加 读写锁 来避免并发访问数据，读加读锁、写加写锁，读写锁互斥，所以一个事务在读的时候，另一个事务不可进行写操作，反之亦然。","head":[["meta",{"property":"og:url","content":"https://code.0x3f4.run/backend/database/mysql/transaction/%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86.html"}],["meta",{"property":"og:site_name","content":"AruNi"}],["meta",{"property":"og:title","content":"隔离级别的实现原理"}],["meta",{"property":"og:description","content":"本文内容 1. 四种隔离级别是如何实现的？ 在四种隔离级别中，读未提交和串行化的实现是最简单的，基本不需要做过多的事情： 读未提交：每次读取数据时，不做任何措施，直接读取最新数据 就好了，所以可以读到未提交的数据； 串行化：通过加 读写锁 来避免并发访问数据，读加读锁、写加写锁，读写锁互斥，所以一个事务在读的时候，另一个事务不可进行写操作，反之亦然。"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2023-12-07T14:56:55.000Z"}],["meta",{"property":"article:author","content":"AruNi_Lu"}],["meta",{"property":"article:tag","content":"MySQL"}],["meta",{"property":"article:published_time","content":"2023-12-07T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2023-12-07T14:56:55.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"隔离级别的实现原理\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2023-12-07T00:00:00.000Z\\",\\"dateModified\\":\\"2023-12-07T14:56:55.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"AruNi_Lu\\",\\"url\\":\\"https://github.com/AruNi-01\\"}]}"]]},"headers":[{"level":2,"title":"1. 四种隔离级别是如何实现的？","slug":"_1-四种隔离级别是如何实现的","link":"#_1-四种隔离级别是如何实现的","children":[]},{"level":2,"title":"2. MVCC 如何工作？","slug":"_2-mvcc-如何工作","link":"#_2-mvcc-如何工作","children":[{"level":3,"title":"2.1 版本链长什么样？","slug":"_2-1-版本链长什么样","link":"#_2-1-版本链长什么样","children":[]},{"level":3,"title":"2.2 Read View","slug":"_2-2-read-view","link":"#_2-2-read-view","children":[]}]},{"level":2,"title":"3. 总结","slug":"_3-总结","link":"#_3-总结","children":[]},{"level":2,"title":"4. 参考文章","slug":"_4-参考文章","link":"#_4-参考文章","children":[]}],"git":{"createdTime":1701961015000,"updatedTime":1701961015000,"contributors":[{"name":"AarynLu","email":"hello@0x3f4.run","commits":1}]},"readingTime":{"minutes":8.43,"words":2529},"filePathRelative":"backend/database/mysql/transaction/隔离级别的实现原理.md","localizedDate":"2023年12月7日","excerpt":"<details class=\\"hint-container details\\"><summary>本文内容</summary>\\n\\n</details>\\n<h2> 1. 四种隔离级别是如何实现的？</h2>\\n<p>在四种隔离级别中，读未提交和串行化的实现是最简单的，基本不需要做过多的事情：</p>\\n<ul>\\n<li><strong>读未提交</strong>：每次读取数据时，不做任何措施，<strong>直接读取最新数据</strong> 就好了，所以可以读到未提交的数据；</li>\\n<li><strong>串行化</strong>：通过加 <strong>读写锁</strong> 来避免并发访问数据，读加读锁、写加写锁，读写锁互斥，所以一个事务在读的时候，另一个事务不可进行写操作，反之亦然。</li>\\n</ul>","autoDesc":true}');export{t as data};
