import{_ as l}from"./plugin-vue_export-helper-c27b6911.js";import{r,o as p,c as d,b as s,e as t,w as a,d as n,a as o}from"./app-61ed31ff.js";const c={},g={class:"hint-container details"},u=s("summary",null,"本文内容",-1),h={class:"table-of-contents"},m={class:"hint-container info"},b=s("p",{class:"hint-container-title"},"前言",-1),k=s("p",null,[n("Redis 并没有直接使用数据结构来实现键值对数据库，而是 "),s("strong",null,"基于数据结构创建了一些数据类型"),n("，简单的五种数据类型分别是："),s("strong",null,"字符串 String、列表 List、哈希 Hash、集合 Set、有序集合 zSet"),n("。此外还有一些高级的数据类型，例如 BitMap、HyperLogLog、GEO、Stream。")],-1),_=s("strong",null,"数据结构",-1),v={href:"https://code.0x3f4.run/backend/database/redis/data_structure/redis%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html",target:"_blank",rel:"noopener noreferrer"},S=o(`<h2 id="前置知识-redisobject" tabindex="-1"><a class="header-anchor" href="#前置知识-redisobject" aria-hidden="true">#</a> &gt; 前置知识：redisObject</h2><p>Redis 使用 <strong>redisObject 结构体表示各种数据结构</strong>（Redis 种把各种数据类型看成不同的对象），redisObject 结构体中的属性如下：</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">redisObject</span> <span class="token punctuation">{</span>
    <span class="token comment">// 类型</span>
    <span class="token keyword">unsigned</span> type<span class="token operator">:</span><span class="token number">4</span><span class="token punctuation">;</span>
    
    <span class="token comment">// 编码</span>
    <span class="token keyword">unsigned</span> encoding<span class="token operator">:</span><span class="token number">4</span><span class="token punctuation">;</span>
    
    <span class="token comment">// 指向 type 类型底层实现（数据结构）的指针</span>
    <span class="token keyword">void</span> <span class="token operator">*</span>ptr<span class="token punctuation">;</span>
<span class="token punctuation">}</span> robj<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>接下来分别简单的介绍一下这三个属性。</p><div class="hint-container info"><p class="hint-container-title">类型（type）</p><p><strong>type 属性记录了对象（数据结构）的类型</strong>，即 String、List、Hash、Set、zSet。</p><p>在 Redis 种，key 总是 String 类型，而 value 可以是任意一种对象。</p><p>我们也可以使用 <code>TYPE key</code> 命令来查看该 key 对应 <strong>value 的类型</strong>。</p></div><div class="hint-container info"><p class="hint-container-title">编码（encoding）和 底层实现的指针（ptr）</p><p><strong>encoding 属性记录了对象的编码</strong>，也就是 <strong>这个对象使用了什么数据结构作为底层实现</strong>，而 <strong>ptr 指针则指向了这个底层的数据结构</strong>。</p><p>Redis 中每种对象都至少使用了 2 种不同的编码，如下图列出了每种类型的对象可以使用的编码：</p><p><img src="https://run-notes.oss-cn-beijing.aliyuncs.com/notes/202302231858184.png" alt="image-20230223185531411" loading="lazy"></p><p>Redis 为对象提供至少 2 种不同的编码，Redis 为什么要这么做呢？</p><p>不同的编码对应着不同的底层数据结构，这就意味着可以 <strong>根据不同的场景来选择不同的数据结构</strong>，从而达到更加高效的数据存取，因为每种数据结构都有各自的优势与劣势。</p><blockquote><p>Redis 底层的数据结构本篇文章就不细讲了。</p></blockquote></div><p>知道了 redisObject 后，下面开始本篇文章的正题。</p><h2 id="_1-字符串-string" tabindex="-1"><a class="header-anchor" href="#_1-字符串-string" aria-hidden="true">#</a> 1. 字符串 String</h2><p>String 是使用频率最高的数据类型，除了 key 总是使用 String 外，value 使用 String 的场景也非常多。</p><h3 id="_1-1-编码方式" tabindex="-1"><a class="header-anchor" href="#_1-1-编码方式" aria-hidden="true">#</a> 1.1 编码方式</h3><p>需要注意的是，String 不仅仅是存储字符串，也可以存储数字（整数或浮点数），整数对应到编码里的 <code>REDIS_ENCODING_INT</code>，此时的 ptr 的类型就从 <code>void*</code> 转换成了 <code>long</code>。</p><p>例如，使用一个 SET 命令将 value 设置为一个数字 <code>SET number 10086</code>，那么这个 value 的字符串对象如下图所示：</p><p><img src="https://run-notes.oss-cn-beijing.aliyuncs.com/notes/数据结构%2FRedis 数据类型.assets-2023_12_26-1703597686.png" alt="image-20231226213444423" loading="lazy"></p><p>对于数值是一个字符串的对象，String 对象有两种编码方式：</p><ul><li><strong>raw</strong>：字符串 <strong>长度大于 39 字节</strong>；</li><li><strong>embstr</strong>：字符串 <strong>长度小于等于 39 字节</strong>。</li></ul><blockquote><p>注意：Redis 5.0 后字节分界点是 44 字节。</p></blockquote><p>下面是一个 raw 编码方式的 String 对象：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>redis<span class="token operator">&gt;</span> SET story <span class="token string">&quot;Long, long, long ago there lived a king ...&quot;</span>
OK
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><img src="https://run-notes.oss-cn-beijing.aliyuncs.com/notes/数据结构%2FRedis 数据类型.assets-2023_12_26-1703598245.png" alt="image-20231226214402779" loading="lazy"></p><p>那 embstr 编码与 raw 有什么区别？为什么字符串长度较短时要使用 embstr 呢？</p><p>其实，<strong>row 编码需要两次内存分配</strong>，分别为 redisObject 和 sdshdr 的内存分配，而 <strong>embstr 只需要一次</strong>，因为其分配的是 <strong>一块连续的内存区域</strong>。embstr 编码的 Sting 对象如下图所示：</p><p><img src="https://run-notes.oss-cn-beijing.aliyuncs.com/notes/数据结构%2FRedis 数据类型.assets-2023_12_26-1703598523.png" alt="image-20231226214841618" loading="lazy"></p><p>embstr 编码不仅 <strong>减少了内存分配/释放的次数</strong>，而且连续的内存区域也可以 <strong>更好的利用 CPU 缓存</strong>。</p><p>另外，<strong>String 对象也是可以保存 long、double 类型的</strong>，<strong>浮点数</strong> 在 Redis 中也是 <strong>作为字符串来保存</strong>，在有需要的时候（比如运算），程序会将字符串转回浮点数值，执行完操作后再转会字符串保存。</p><div class="hint-container danger"><p class="hint-container-title">注意</p><p>由于 Redis 没有为 embstr 编码的 String 对象提供修改值的命令，在修改时会先转为 raw 编码，所以 <strong>embstr 编码的 String 对象在执行完修改命令后总会变成一个 raw 编码的 String 对象</strong>。</p></div><h3 id="_1-2-应用场景" tabindex="-1"><a class="header-anchor" href="#_1-2-应用场景" aria-hidden="true">#</a> 1.2 应用场景</h3><p>String 对象的应用场景很经典，有如下：</p><ul><li><strong>缓存对象</strong>，例如给热榜帖子做缓存，key 为帖子 id，value 为帖子信息的 json 字符串；</li><li><strong>计数器</strong>，因为 Redis 在处理请求时是单线程，<strong>本身能保证操作的原子性</strong>，所以可以做计数器（通过 <code>INCR</code> 和 <code>DECR</code> 命令），例如访问次数、库存量等；</li><li><strong>分布式锁</strong>，String 数据类型有一个 <code>SET key value NX PX time</code> 原子命令，可以确保 key 不存在才 set 成功，而且 Redis 本身就支持分布式，因此可以把 key 作为锁 key，只有 set 成功才能获取到分布式锁；</li><li><strong>分布式 Session</strong>，当项目使用分布式部署时，Session 是保存到单独的服务器上的，所以需要额外的同步操作，而 Redis 本身支持分布式，所以可以把 Session 保存到 Redis 中，所有服务器都向 Redis 获取即可。</li></ul><h2 id="_2-列表-list" tabindex="-1"><a class="header-anchor" href="#_2-列表-list" aria-hidden="true">#</a> 2. 列表 List</h2><h3 id="_2-1-编码方式" tabindex="-1"><a class="header-anchor" href="#_2-1-编码方式" aria-hidden="true">#</a> 2.1 编码方式</h3><p>List 对象的编码方式有两种：</p><ul><li><strong>压缩列表 ziplist</strong>：存储的元素 <strong>长度小于 64 字节，且数量小于 512 个</strong>（条件可通过参数修改）；</li><li><strong>双向列表 linkedlist</strong>：不满足上面两个条件。</li></ul>`,32),y=s("strong",null,"Redis 3.2 后 List 的底层实现只有 quicklist",-1),E={href:"https://code.0x3f4.run/backend/database/redis/data_structure/redis%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html#_8-quicklist",target:"_blank",rel:"noopener noreferrer"},f=o(`<p>例如，简单的向一个 numbers 列表中插入三个数据：</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code>redis<span class="token operator">&gt;</span> RPUSH numbers <span class="token number">1</span> <span class="token string">&quot;three&quot;</span> <span class="token number">5</span>
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">3</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><img src="https://run-notes.oss-cn-beijing.aliyuncs.com/notes/数据结构%2FRedis 数据类型.assets-2023_12_26-1703603954.png" alt="image-20231226231912948" loading="lazy"></p><p>如果编码方式是 linkedlist，那么键值对示意图如下所示：</p><p><img src="https://run-notes.oss-cn-beijing.aliyuncs.com/notes/数据结构%2FRedis 数据类型.assets-2023_12_26-1703604426.png" alt="image-20231226232705281" loading="lazy"></p><p>需要注意的是，<strong>linkedlist 中的每个值对象，其实是一个 String 对象</strong>，在哈希、集合、有序集合中也会有嵌套 String 对象。</p><p>所以上面的 three 值对象其实是下面这样：</p><p><img src="https://run-notes.oss-cn-beijing.aliyuncs.com/notes/数据结构%2FRedis 数据类型.assets-2023_12_26-1703604540.png" alt="image-20231226232859058" loading="lazy"></p><h3 id="_2-2-使用场景" tabindex="-1"><a class="header-anchor" href="#_2-2-使用场景" aria-hidden="true">#</a> 2.2 使用场景</h3><p>List 是一个先进先出的有序队列，所以一般 <strong>要求顺序的业务场景</strong>，都可以使用 List，比如：</p><ul><li><p><strong>简单的消息队列</strong>，不够成熟，例如没有消息丢失重试机制、不支持多次消费，更推荐使用 Stream 或 RabbitMQ、Kafka 等消息队列；</p></li><li><p><strong>最新列表</strong>：某个帖子的点赞列表按最新顺序展示，就可以把 key 作为帖子 id，点赞者 id 作为 value 加入到 list 中；</p><blockquote><p>不过 <strong>不适用于更新频繁的分页列表</strong>，因为可能会导致 <strong>列表元素重复或遗漏</strong>，因为可能在两次分页查询过程中混入了一个插入到表头的操作，这样就会在第二页中查询到第一页中的数据；而且 <strong>List 不能实现范围查询</strong>，比如某个时间范围，需要通过 zSet 来实现。</p></blockquote></li><li><p><strong>定时排行榜</strong>：与上面最新列表类似，通过 <code>LRANGE key start stop</code> 命令获取排名在 start ~ stop 之间的数据。不过不能实现实时排名，因为元素入队后排名就定了，不能动态修改，只能重新插入，实时排行榜也需要通过 zSet 实现。</p></li></ul><p>可以发现，最新列表和排行榜其实都可以通过 zSet 实现，而且功能还更强大，为什么还要用 List？这是因为 <strong>List 类型占用的内存比 zSet 要少很多</strong>，所以没有其他必须因素，还是用 List 比较合适。</p><h2 id="_3-哈希-hash" tabindex="-1"><a class="header-anchor" href="#_3-哈希-hash" aria-hidden="true">#</a> 3. 哈希 Hash</h2><h3 id="_3-1-编码方式" tabindex="-1"><a class="header-anchor" href="#_3-1-编码方式" aria-hidden="true">#</a> 3.1 编码方式</h3><p>Hash 对象的编码方式也有两种：</p><ul><li><strong>压缩列表 ziplist</strong>：存储的所有键值对的 <strong>键和值 长度都小于 64 字节，且键值对数量小于 512 个</strong>（条件可通过参数修改）；</li><li><strong>哈希表 hashtable</strong>：不满足上面两个条件。</li></ul>`,16),R=s("strong",null,"Redis 7.0 后 压缩列表已经废弃，被 listpack 替代",-1),B={href:"https://code.0x3f4.run/backend/database/redis/data_structure/redis%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html#_9-listpack",target:"_blank",rel:"noopener noreferrer"},z=o('<p>当使用压缩列表保存键值对时，采用的是尾插法，如下图所示：</p><p><img src="https://run-notes.oss-cn-beijing.aliyuncs.com/notes/数据结构%2FRedis 数据类型.assets-2023_12_27-1703658692.png" alt="image-20231227143128794" loading="lazy"></p><p>当使用哈希表保存键值对时，<strong>哈希表的每个键都是一个字符串对象</strong>，该对象中保存了键值对的键，同理，哈希表的每个值也是一个字符串对象，如下图所示：</p><p><img src="https://run-notes.oss-cn-beijing.aliyuncs.com/notes/数据结构%2FRedis 数据类型.assets-2023_12_27-1703658820.png" alt="image-20231227143338258" loading="lazy"></p><h3 id="_3-2-使用场景" tabindex="-1"><a class="header-anchor" href="#_3-2-使用场景" aria-hidden="true">#</a> 3.2 使用场景</h3><p>Hash 数据类型主要有以下两个应用场景：</p><ul><li><p><strong>存储对象</strong>，如果需要 <strong>存储的对象不多时</strong>，可以把 <strong>key 设为固定值</strong>，field 为 ID:属性，value 为属性值；如果 <strong>存储的对象很多时</strong>，则可以 <strong>把 key 做一个动态分离</strong>，分配多个 key 槽位，将 key 设置成 user:序号（序号可为 0~999），这样对象需要通过一个哈希映射函数 <code>H(k) = k % 1000</code>，来确定对象分配到哪个 key 槽中；</p></li><li><p><strong>购物车</strong>，用户 id 为 key，商品 id 为 field，商品数量为 value，刚好构成了购物车三要素，如下图所示：</p><p><img src="https://run-notes.oss-cn-beijing.aliyuncs.com/notes/https%2Fcdn.xiaolincoding.com%2Fgh%2Fxiaolincoder%2Fredis%2F数据类型-2023_12_27-1703661242.png" alt="img" loading="lazy"></p></li></ul><p>在将 String 对象时说过，将对象使用 Json 序列化后也可以存储，<strong>那么 String + Json 和 Hash 到底应该用哪个存储对象</strong>？</p><p><strong>当对象的属性修改频繁时，不适合使用 String + Json</strong>，因为不够灵活，<strong>每次都需要重新将整个对象序列化</strong>，而 <strong>Hash 可以针对某个属性单独修改</strong>，无需序列化，比如商品的销量、评价数。</p><p>不过，<strong>当对象的某个属性不是基本类型或字符串时，Hash 对象需要手动进行序列化</strong>，比如用户标签，是一个标签对象 list，此时直接使用 String + Json 会更简单。</p><p>所以 <strong>对象存储一般使用 String + Json，某些修改频繁的属性可以单独抽出来使用 Hash</strong>。</p><h2 id="_4-集合-set" tabindex="-1"><a class="header-anchor" href="#_4-集合-set" aria-hidden="true">#</a> 4. 集合 Set</h2><h3 id="_4-1-编码方式" tabindex="-1"><a class="header-anchor" href="#_4-1-编码方式" aria-hidden="true">#</a> 4.1 编码方式</h3><p>Set 对象的编码方式也有两种：</p><ul><li><strong>整数集合 intset</strong>：存储的 <strong>元素都是整数值，且元素数量不超过 512 个</strong>；</li><li><strong>哈希表 hashtable</strong>：不满足上面两个条件。</li></ul><p>例如，下面是一个 intset 编码的 Set 对象：</p><p><img src="https://run-notes.oss-cn-beijing.aliyuncs.com/notes/数据结构%2FRedis 数据类型.assets-2023_12_27-1703662123.png" alt="image-20231227152842681" loading="lazy"></p><p>contents 数组的类型由 encoding 决定。</p><p>而如果是 hashtable 编码的 Set 对象，<strong>哈希表的每个键是一个字符串对象，该对象保存了集合元素，哈希表的值则都被置为 NULL</strong>。如下所示：</p><p><img src="https://run-notes.oss-cn-beijing.aliyuncs.com/notes/数据结构%2FRedis 数据类型.assets-2023_12_27-1703662542.png" alt="image-20231227153541118" loading="lazy"></p><h3 id="_4-2-使用场景" tabindex="-1"><a class="header-anchor" href="#_4-2-使用场景" aria-hidden="true">#</a> 4.2 使用场景</h3><p>Set 对象是无序、不重复的，并且支持去交并差集等操作，常见的使用场景如下：</p><ul><li><strong>点赞，收藏</strong>： <ul><li>点赞：SADD like:postId userId；</li><li>取消点赞：SREM like:postId userId；</li><li>用户是否点赞：SISMEMBER like:postId userId；</li><li>获取点赞列表：SMEMBERS like:postId；</li><li>获取点赞数量：SCARD like:postId。</li></ul></li><li><strong>[共同] 关注/粉丝/感兴趣的人集合</strong>：key 为 follow:userId，value 为 userId 关注的用户；粉丝类似，key 为 follower:userId，value 为该用户的粉丝列表。共同关注的人只需取两个 follow:userId 的交集即可；</li><li><strong>随机展示/随机抽奖</strong>：可使用 <code>SRANDMEMBER key [count]</code> 随机获取 Set 对象中的 count 个元素，若是需要不可重复获取，可使用 <code>SPOP key [count]</code>；</li><li><strong>黑白名单</strong>：可使用 SISMEMBER 快速判断某个用户、IP、设备是否处于黑白名单中。</li></ul><h2 id="_5-有序集合-zset" tabindex="-1"><a class="header-anchor" href="#_5-有序集合-zset" aria-hidden="true">#</a> 5. 有序集合 zSet</h2><h3 id="_5-1-编码方式" tabindex="-1"><a class="header-anchor" href="#_5-1-编码方式" aria-hidden="true">#</a> 5.1 编码方式</h3><p>zSet 对象的编码方式也有两种：</p><ul><li><strong>压缩列表 ziplist</strong>：存储的所有元素 <strong>长度都小于 64 字节，且数量小于 128 个</strong>（条件可通过参数修改）；</li><li><strong>跳表 skiplist</strong>：不满足上面两个条件。</li></ul>',27),O=s("strong",null,"Redis 7.0 后 压缩列表已经废弃，被 listpack 替代",-1),L={href:"https://code.0x3f4.run/backend/database/redis/data_structure/redis%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html#_9-listpack",target:"_blank",rel:"noopener noreferrer"},H=o(`<p>当使用 ziplist 编码时，<strong>每个集合元素使用两个紧挨在一起的压缩列表 entry 来保存</strong>，分别保存元素的成员 member 和分值 score，<strong>压缩列表内的集合元素按照 score 从小到大排序</strong>，如下所示：</p><p><img src="https://run-notes.oss-cn-beijing.aliyuncs.com/notes/数据结构%2FRedis 数据类型.assets-2023_12_27-1703666079.png" alt="image-20231227163438282" loading="lazy"></p><p>而使用 skiplist 编码时，zSet 对象使用 zset 结构作为底层实现，<strong>为了让 zSet 的查找和范围型操作都尽可能快地执行</strong>，其同时包含跳表和哈希字典：</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">zset</span> <span class="token punctuation">{</span>
    zskiplist <span class="token operator">*</span>zsl<span class="token punctuation">;</span>
    dict <span class="token operator">*</span>dict<span class="token punctuation">;</span>
<span class="token punctuation">}</span> zset<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>跳表按照分值从小到大保存了所有集合元素，哈希字典则只保存从成员到分值的映射</strong>，通过此可以使用 O(1) 复杂度获取某个成员的分值（ZSCORE 命令）。</p><p>跳表和哈希字典会通过一个指针来 <strong>共享相同元素的成员和分值</strong>，所以 <strong>不会造成额外的内存消耗</strong>。</p><p>skiplist 编码的 zSet 对象如下图所示（为了方便，图中并没有画出跳表和字典的共享属性）：</p><p><img src="https://run-notes.oss-cn-beijing.aliyuncs.com/notes/数据结构%2FRedis 数据类型.assets-2023_12_27-1703666663.png" alt="image-20231227164421865" loading="lazy"></p><h3 id="_5-2-使用场景" tabindex="-1"><a class="header-anchor" href="#_5-2-使用场景" aria-hidden="true">#</a> 5.2 使用场景</h3><p>由于 zSet 对象可以根据 score 来排序，所以在排序的应用场景很常见，例如 <strong>最新列表、排行榜</strong>，以及之前在 List 对象中讲到的 <strong>频繁更新的分页数据、范围查询</strong>。下面讲讲最经典的排行榜功能。</p><p>排行榜的 key 可以设置成某个排行榜的标识，比如 post:rank，score 设置为帖子的分数，用户在查看、点赞、评论后，都将该帖子的 score 加上对应的值，member 则为帖子的 id，则该 zSet 的操作有如下：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>ZADD post:rank <span class="token number">0</span> post:001	<span class="token comment"># 添加帖子</span>
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">1</span>

ZINCRBY post:rank <span class="token number">2</span> post:001	<span class="token comment"># 增加帖子的分数</span>
<span class="token string">&quot;2&quot;</span>

ZSCORE post:rank post:001	<span class="token comment"># 获取帖子的分数</span>
<span class="token string">&quot;2&quot;</span>

ZREVRANGE post:rank <span class="token number">0</span> <span class="token number">5</span> WITHSCORES	<span class="token comment"># 展示前 5 名（倒序获取）的帖子成员</span>
<span class="token string">&quot;post:001&quot;</span>

ZRANGEBYSCORE post:rank <span class="token number">2</span> <span class="token number">100</span> WITHSCORES   <span class="token comment"># 展示帖子分数在 2-100 的帖子成员</span>
<span class="token string">&quot;post:001&quot;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="_6-bitmap" tabindex="-1"><a class="header-anchor" href="#_6-bitmap" aria-hidden="true">#</a> 6. Bitmap</h2><p>Bitmap 使用 <strong>String 类型作为底层数据结构</strong> 的一种统计 <strong>二值状态</strong> 的数据类型。<strong>String 类型会保存为一个二进制的字节数组</strong>，每一个 bit 位表示一个元素的二值状态。</p><p>二值状态指的是元素的取值只有 0 和 1 两种，在统计打卡、签到等场景中非常经典。例如每个用户一天的签到只有一个 bit 位就能表示，一个月最多 31 个 bit 位，一年也只需要 365 个 bit 位，<strong>占用的空间十分少</strong>。</p><p>Bitmap 提供了 GETBIT 和 SETBIT 操作，使用偏移量 offset 对 bit 数组中的某一个 bit 位进行操作（offset 从 0 开始）。而且 Bitmap 还提供了 <strong>BITCOUNT 操作来统计 bit 数组中所有 1 的个数</strong>，以及 <strong>BITOP 命令对多个 Bitmap 按位做与、或、异或操作</strong>，结果会保存到一个新的 Bitmap 中。</p><p>例如统计用户在 2023 年 12 月的签到情况，可以进行如下操作：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>SETBIT user:sign:001:202312 <span class="token number">4</span> <span class="token number">1</span>		<span class="token comment"># 12 月 5 号 已签到</span>

GETBIT user:sign:001:202312 <span class="token number">4</span>	<span class="token comment"># 检查 001 用户 12 月 5 号是否签到</span>

BITCOUNT user:sign:001:202312 	<span class="token comment"># 统计 001 用户 12 月的签到次数</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果需要统计 1 亿个用户中，连续签到10 天的用户数，则可以把每天的日期作为 key，每个 key 对应一个 1 亿位的 Bitmap，然后对这 10 天的 Bitmap 做与操作，放入一个新的 Bitmap 中，最后对这个 Bitmap 做 BITCOUNT 操作，即可得到连续签到 10 天的用户数量。</p><p>使用 Bitmap 来统计，每天需要一个 1 亿位的 Bitmap，大约 12M 内存（1*10^8/8/1024/1024），10 天则需要 120M，是比较节省内存的。而且我们一般会给 Bitmap 设置过期时间以自动删除不需要的记录。</p><p>所以 <strong>Bitmap 非常适合用来统计数据的二值状态，在记录的数据量较大时，它能够有效的节省内存空间</strong>。</p><h2 id="_7-hyperloglog" tabindex="-1"><a class="header-anchor" href="#_7-hyperloglog" aria-hidden="true">#</a> 7. HyperLogLog</h2><p>HyperLogLog 是一种用于 <strong>统计基数</strong> 的数据类型（<strong>基数统计就是指统计一个集合中不重复的元素个数</strong>），即使 <strong>在集合数量非常多时，它所占用的空间都是固定且很小的</strong>。</p><p>在 Redis 中，一个 HyperLogLog 只需花费 12KB 内存，就能统计接近 2^64 个元素的基数，比 Set、Hash 这种元素越多越耗内存的类型要节省很多空间。</p><p>比如，在统计网页的 UV（Unique Visitor）：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>PFADD page1:uv user1 user2 user3 user4	<span class="token comment"># 向 page1:uv HyperLogLog 中添加元素</span>

PFCOUNT page1:uv	<span class="token comment"># 获取 page1 的 UV 值</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>另外，它还提供 PFMERGE 命令将多个 HyperLogLog 合并成一个。</p><p>HyperLogLog 虽然在海量数据的基数统计中非常节约内存，但是它的统计规则是 <strong>基于概率完成的</strong>，标准误算率是 0.81%，所以如果统计的 UV 是 100 万，但实际的可能有 101 万，误差不算大，<strong>但若要精确的统计，还得使用 Set 或 Hash 类型</strong>。</p><h2 id="_8-geo" tabindex="-1"><a class="header-anchor" href="#_8-geo" aria-hidden="true">#</a> 8. GEO</h2><p>GEO 类型也是 Redis 一种扩展类型，主要用于 <strong>位置信息服务（Location-Based Service, LBS）应用</strong>，例如附近餐厅、打车软件。</p><p>在 LBS 应用中，需要使用经纬度信息来计算两个实体之间的距离，比如一辆车或一个用户对应一组经纬度，然后 <strong>需要进行某个经纬度的范围查询</strong>。</p><p><strong>GEO 的底层数据结构是使用 zSet + GeoHash 编码来实现的</strong>，比如，我们使用 zSet 来保存车辆的经纬度信息，<strong>field 是车辆 ID，权重分数是经纬度信息</strong>，如下所示：</p><p><img src="https://run-notes.oss-cn-beijing.aliyuncs.com/notes/https%2Fstatic001.geekbang.org%2Fresource%2Fimage%2Fa9%2F4e-2023_12_27-1703679679.jpeg" alt="img" loading="lazy"></p><p>但 zSet 的 <strong>score 是一个浮点数，而 一组经纬度包含两个值，怎么保存呢</strong>？这就要用到 GEO 的 GeoHash 编码了。</p><h3 id="_8-1-geohash-编码" tabindex="-1"><a class="header-anchor" href="#_8-1-geohash-编码" aria-hidden="true">#</a> 8.1 GeoHash 编码</h3><p>GeoHash 编码并不是 Redis 设计出来的，而是在 LBS 应用业界中广泛使用的一种编码方法，这个方法的原理是 <strong>二分区间，区间编码</strong>。</p><p>当需要对一组经纬度进行 GeoHash 编码时，<strong>首先要对经度和纬度分别编码，然后再把这两个编码组合成一个最终编码</strong>。</p><p>先来看看经纬度的单独编码过程。</p><p>一个经度的范围是 [-180, 180]，GeoHash 编码会把一个经度值编码成一个 N 位的二进制值，即 <strong>对经度范围 [-180, 180] 做 N 次二分区操作</strong>（N 可自定义）。<strong>每二分一次区间，都会使经度值落在这两个区间的其中一个，如果落到左分区则用 0 表示，落到右分区则用 1 表示。这样每完成一次二分区，就可以得到 1 位编码值。这样当做完 N 次二分区后，经度值就可以使用一个 N bit 的数来表示了</strong>。</p><p>假设对经度值 116.37 进行 5 次的二分区，得到的编码如下所示：</p><p><img src="https://run-notes.oss-cn-beijing.aliyuncs.com/notes/https%2Fstatic001.geekbang.org%2Fresource%2Fimage%2F3c%2Ff2-2023_12_27-1703681060.jpeg" alt="img" loading="lazy"></p><p>对于纬度也同理，只是范围在 [-90, 90]，假设对纬度值 39.86 进行 5 次的二分区，得到的编码如下所示：</p><p><img src="https://run-notes.oss-cn-beijing.aliyuncs.com/notes/https%2Fstatic001.geekbang.org%2Fresource%2Fimage%2F65%2F6d-2023_12_27-1703681123.jpeg" alt="img" loading="lazy"></p><p>这样对经纬度的分别编码就完成了，接下来只需要将各自的编码组合在一起，组合规则是：<strong>最终编码值的偶数位上依次是经度得编码值，奇数位上依次是纬度得编码值</strong>，其中 <strong>偶数首位在奇数首位的前面</strong>。</p><p>上面的经纬度得到的首次编码分别是 11010 和 10111，组合之后的最终编码如下：</p><p><img src="https://run-notes.oss-cn-beijing.aliyuncs.com/notes/https%2Fstatic001.geekbang.org%2Fresource%2Fimage%2F4a%2F87-2023_12_27-1703681553.jpeg" alt="img" loading="lazy"></p><p>所以，使用了 GeoHash 编码后，一组经纬度（116.37, 39.86）就可以使用 1110011101 这一个值表示了，就可以保存为 zSet 的 score 了。</p><p><strong>使用了 GeoHash 编码后，就相当于把整个地理空间划分成了一个个方格，每个方格对应了 GeoHash 中的一个分区</strong>。例如，把经纬度分别做 1 次二分区，总共就会得到 4 个分区，如下图所示：</p><p><img src="https://run-notes.oss-cn-beijing.aliyuncs.com/notes/https%2Fstatic001.geekbang.org%2Fresource%2Fimage%2F2a%2F74-2023_12_27-1703682202.jpeg" alt="img" loading="lazy"></p><ul><li>分区一：[-180,0) 和 [-90,0)，编码 00；</li><li>分区二：[-180,0) 和 [0,90]，编码 01；</li><li>分区三：[0,180] 和 [-90,0)，编码 10；</li><li>分区四：[0,180] 和 [0,90]，编码 11。</li></ul><p>这样 <strong>在使用 zSet 范围查询得到相近的编码值，在实际的地理空间上，也是相邻的方格</strong>，所以实现了 LBS 应用中搜索附件的人或物的功能了。</p><p>不过，<strong>有些编码值虽然在大小上接近，但实际的方格却距离较远</strong>，比如下面对经纬度分别做 2 次二分区，得到 16 个分区：</p><p><img src="https://run-notes.oss-cn-beijing.aliyuncs.com/notes/https%2Fstatic001.geekbang.org%2Fresource%2Fimage%2F0d%2Fba-2023_12_27-1703682526.jpeg" alt="img" loading="lazy"></p><p>所以 <strong>为了避免查询不准确的问题，可以同时查询给定经纬度所在方格周围的 4 个或 8 个方格</strong>。</p><h3 id="_8-2-应用场景" tabindex="-1"><a class="header-anchor" href="#_8-2-应用场景" aria-hidden="true">#</a> 8.2 应用场景</h3><p>Redis 中的 GEO 类型最经典的应用场景就是 LBS 应用，查找附近的人，打车等。</p><p>在使用 GEO 时，最常用命令如下：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># 存储指定的地理空间位置，将经度(longitude)、纬度(latitude)、位置名称(member)添加到指定的 key 中。</span>
GEOADD key longitude latitude member <span class="token punctuation">[</span>longitude latitude member <span class="token punctuation">..</span>.<span class="token punctuation">]</span>

<span class="token comment"># 返回两个给定位置之间的距离。</span>
GEODIST key member1 member2 <span class="token punctuation">[</span>m<span class="token operator">|</span>km<span class="token operator">|</span>ft<span class="token operator">|</span>mi<span class="token punctuation">]</span>

<span class="token comment"># 根据用户给定的经纬度坐标来获取指定范围内的地理位置集合。</span>
GEORADIUS key longitude latitude radius m<span class="token operator">|</span>km<span class="token operator">|</span>ft<span class="token operator">|</span>mi <span class="token punctuation">[</span>WITHCOORD<span class="token punctuation">]</span> <span class="token punctuation">[</span>WITHDIST<span class="token punctuation">]</span> <span class="token punctuation">[</span>WITHHASH<span class="token punctuation">]</span> <span class="token punctuation">[</span>COUNT count<span class="token punctuation">]</span> <span class="token punctuation">[</span>ASC<span class="token operator">|</span>DESC<span class="token punctuation">]</span> <span class="token punctuation">[</span>STORE key<span class="token punctuation">]</span> <span class="token punctuation">[</span>STOREDIST key<span class="token punctuation">]</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>假设一个车辆的 ID 是 33，经纬度是（116.034579，39.030452），可以使用 GEO 集合保存所有车辆的经纬度，key 是 cars:locations：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>GEOADD cars:locations <span class="token number">116.034579</span> <span class="token number">39.030452</span> <span class="token number">33</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>查找附件的网约车时，就可以使用 GEORADIUS 命令：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>GEORADIUS cars:locations <span class="token number">116.054579</span> <span class="token number">39.030452</span> <span class="token number">5</span> km ASC COUNT <span class="token number">10</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>LBS 应用执行上面的命令时，Redis 会根据输入的用户的经纬度信息（116.054579，39.030452 ），升序（从近到远）查找以这个经纬度为中心的 5 公里内的车辆信息，并返回给 LBS 应用。</p><h2 id="_9-复杂度比较" tabindex="-1"><a class="header-anchor" href="#_9-复杂度比较" aria-hidden="true">#</a> 9. 复杂度比较</h2><h3 id="_9-1-不同底层实现的复杂度" tabindex="-1"><a class="header-anchor" href="#_9-1-不同底层实现的复杂度" aria-hidden="true">#</a> 9.1 不同底层实现的复杂度</h3><p>在了解了各种数据类型以及它们的底层数据结构后，就很容易得出它们在操作时的时间复杂度了。</p><p>由于 Redis 是一个键值对数据库，即本身就是一个通过哈希表组织起来的数据库，所以对于 <strong>String 类型</strong> 来说，只需要找到 key 对应的哈希桶，即可操作该 value 了，<strong>复杂度就是哈希表的 O(1)</strong>。</p><p>而对于 <strong>集合类型 List、Hash、Set 和 zSet</strong> 来说，通过 key 找到哈希桶后，<strong>还需要在集合中进一步操作 value</strong>：</p><ul><li>对于使用了 <strong>压缩列表/listpack的 List、Hash 和 zSet</strong> 来说，可以通过表头三个字段 zlbytes、tltail、zllen <strong>快速定位（O(1) 复杂度）到头尾元素</strong>，但 <strong>寻找中间元素也只能逐个查找，复杂度是 O(N)</strong>；</li><li>对于使用了 <strong>双向链表/quicklist 的 List</strong> 来说，其实和普通链表一样，<strong>除了定位头尾节点是 O(1) 复杂度，查找其他节点也是 O(N) 复杂度</strong>；</li><li>对于使用了 <strong>整数集合的 Set</strong> 来说，其实和普通数组一样，<strong>操作复杂度也是 O(N)</strong>。而对于使用了 <strong>哈希表的 Set</strong> 来说，<strong>操作复杂度可降到 O(1)</strong>；</li><li>对于使用了 <strong>哈希表的 Hash</strong> 来说，<strong>操作 value 同样还是 O(1) 复杂度</strong>；</li><li>对于使用了 <strong>跳表的 zSet</strong> 来说，由于跳表多了层级结构，所以可以使得在查找时可通过层级关系来避免像链表一样的逐一遍历查询，<strong>将复杂度降到了 O(logN)</strong>。</li></ul><h3 id="_9-2-不同操作的复杂度" tabindex="-1"><a class="header-anchor" href="#_9-2-不同操作的复杂度" aria-hidden="true">#</a> 9.2 不同操作的复杂度</h3><p>对于 String 类型的操作来说，更多都是对一个 key 的操作，而集合类型的操作则有很多，既有单个元素的操作，也有批量操作，还有整个集合的遍历操作等等，它们的复杂度都是不一样的。</p><p>下面分三种操作来讲，分别是 <strong>单元素操作、范围操作和统计操作</strong>。</p><div class="hint-container info"><p class="hint-container-title">单元素操作</p><p><strong>单元素操作，就是对单个元素的增删改查操作</strong>，例如 Hash 类型的 HSET、HGET、HDEL，Set 类型的 SADD、SREM、SRANDMEMBER 等。</p><p><strong>这些操作的复杂度由上面提到的底层实现的数据结构决定</strong>。不过如果是 <strong>对多个元素进行操作</strong>，比如 Hash 的 HMSET、HMGET，Set 的 SADD 一次性新增多个元素。这时 <strong>复杂度就从 O(1) 升到了 O(M)</strong>，M 为操作的元素个数。</p><blockquote><p><strong>注意</strong>：<strong>压缩列表/listpack 和双向链表/quicklist</strong> 都会在上一层结构体中 <strong>记录表头和表尾的偏移量/指针</strong>，所以对于 List 的 LPOP、RPOP、LPUSH、RPUSH 来说，<strong>复杂度也只有 O(1)</strong>。</p><p>所以在使用 List 时，尽量用在 PUSH/POP 的场景，复杂度较低，而不是用在随机读写的场景。</p></blockquote></div><div class="hint-container info"><p class="hint-container-title">范围操作</p><p><strong>范围操作，就是对集合进行遍历操作，可以返回所有/某个范围的数据</strong>，例如 Hash 类型的 HGETALL，Set 类型的 SMEMBERS，List 类型的 LRANGE，zSet 的 ZRANGE 等。</p><p><strong>这类操作的时间复杂度一般就是 O(N) 了，是比较耗时的，尽量少用</strong>。</p><p>Redis 提供了 <strong>SCAN 系列操作</strong>，例如 HSCAN、SSCAN、ZSCAN。这类操作实现了 <strong>渐进式遍历</strong>，<strong>并不会一次性返回所有数据，而是只返回特定数量的</strong>。这样可以避免一次性获取所有数据带来的 Redis 阻塞。</p></div><div class="hint-container info"><p class="hint-container-title">统计操作</p><p>统计操作，就是对集合中的元素个数做记录，例如 LLEN、SCARD。</p><p><strong>这类操作的复杂度只有 O(1)</strong>，因为集合类型的底层数据结构中，<strong>设计了专门的长度字段用来记录元素的个数</strong>，为的就是能快速获取集合的长度（元素个数）。</p></div><p>可以发现，其实 <strong>压缩列表/listpack 和整数数组这类紧凑型的数据结构在时间复杂度上并没有什么优势</strong>，那 Redis 为什么还要设计呢？</p><p>原因在于这种紧凑型的数据结构的 <strong>内存利用率更高</strong>，而链表、跳表这种，<strong>在每个节点都要花额外的空间</strong>。Redis 是内存数据库，内存对它是很宝贵的。</p><p>另外，<strong>数组对于 CPU 缓存也更友好</strong>，因为 <strong>CPU 在向内存读取数据时一次性是读取一块数据</strong>，大小受地址总线宽度影响。所以 <strong>数据越紧凑，CPU 一次性能读取到的数据就更多</strong>，下次访问数据时，若已经读取过了，就可以直接在缓存中获取了。</p><p><strong>在元素较少时利用了 CPU 缓存，所以操作速度也不会太差。当元素较多时便转为更快的数据结构比如哈希表、跳表来存储，又保证了操作速度</strong>。</p><h2 id="_10-参考文章" tabindex="-1"><a class="header-anchor" href="#_10-参考文章" aria-hidden="true">#</a> 10. 参考文章</h2>`,80),F={href:"https://www.cnblogs.com/pangzizhe/tag/Redis/",target:"_blank",rel:"noopener noreferrer"},x={href:"https://xiaolincoding.com",target:"_blank",rel:"noopener noreferrer"},I=s("li",null,"《Redis 设计与实战》",-1),T=s("li",null,"《Redis 核心技术与实战》",-1);function N(j,D){const e=r("router-link"),i=r("ExternalLinkIcon");return p(),d("div",null,[s("details",g,[u,s("nav",h,[s("ul",null,[s("li",null,[t(e,{to:"#前置知识-redisobject"},{default:a(()=>[n("> 前置知识：redisObject")]),_:1})]),s("li",null,[t(e,{to:"#_1-字符串-string"},{default:a(()=>[n("1. 字符串 String")]),_:1}),s("ul",null,[s("li",null,[t(e,{to:"#_1-1-编码方式"},{default:a(()=>[n("1.1 编码方式")]),_:1})]),s("li",null,[t(e,{to:"#_1-2-应用场景"},{default:a(()=>[n("1.2 应用场景")]),_:1})])])]),s("li",null,[t(e,{to:"#_2-列表-list"},{default:a(()=>[n("2. 列表 List")]),_:1}),s("ul",null,[s("li",null,[t(e,{to:"#_2-1-编码方式"},{default:a(()=>[n("2.1 编码方式")]),_:1})]),s("li",null,[t(e,{to:"#_2-2-使用场景"},{default:a(()=>[n("2.2 使用场景")]),_:1})])])]),s("li",null,[t(e,{to:"#_3-哈希-hash"},{default:a(()=>[n("3. 哈希 Hash")]),_:1}),s("ul",null,[s("li",null,[t(e,{to:"#_3-1-编码方式"},{default:a(()=>[n("3.1 编码方式")]),_:1})]),s("li",null,[t(e,{to:"#_3-2-使用场景"},{default:a(()=>[n("3.2 使用场景")]),_:1})])])]),s("li",null,[t(e,{to:"#_4-集合-set"},{default:a(()=>[n("4. 集合 Set")]),_:1}),s("ul",null,[s("li",null,[t(e,{to:"#_4-1-编码方式"},{default:a(()=>[n("4.1 编码方式")]),_:1})]),s("li",null,[t(e,{to:"#_4-2-使用场景"},{default:a(()=>[n("4.2 使用场景")]),_:1})])])]),s("li",null,[t(e,{to:"#_5-有序集合-zset"},{default:a(()=>[n("5. 有序集合 zSet")]),_:1}),s("ul",null,[s("li",null,[t(e,{to:"#_5-1-编码方式"},{default:a(()=>[n("5.1 编码方式")]),_:1})]),s("li",null,[t(e,{to:"#_5-2-使用场景"},{default:a(()=>[n("5.2 使用场景")]),_:1})])])]),s("li",null,[t(e,{to:"#_6-bitmap"},{default:a(()=>[n("6. Bitmap")]),_:1})]),s("li",null,[t(e,{to:"#_7-hyperloglog"},{default:a(()=>[n("7. HyperLogLog")]),_:1})]),s("li",null,[t(e,{to:"#_8-geo"},{default:a(()=>[n("8. GEO")]),_:1}),s("ul",null,[s("li",null,[t(e,{to:"#_8-1-geohash-编码"},{default:a(()=>[n("8.1 GeoHash 编码")]),_:1})]),s("li",null,[t(e,{to:"#_8-2-应用场景"},{default:a(()=>[n("8.2 应用场景")]),_:1})])])]),s("li",null,[t(e,{to:"#_9-复杂度比较"},{default:a(()=>[n("9. 复杂度比较")]),_:1}),s("ul",null,[s("li",null,[t(e,{to:"#_9-1-不同底层实现的复杂度"},{default:a(()=>[n("9.1 不同底层实现的复杂度")]),_:1})]),s("li",null,[t(e,{to:"#_9-2-不同操作的复杂度"},{default:a(()=>[n("9.2 不同操作的复杂度")]),_:1})])])]),s("li",null,[t(e,{to:"#_10-参考文章"},{default:a(()=>[n("10. 参考文章")]),_:1})])])])]),s("div",m,[b,k,s("blockquote",null,[s("p",null,[n("Redis 中的 "),_,n(" 包括：简单动态字符串 SDS、链表 List、压缩列表 ziplist、哈希表 hash、整数集合 intset、跳表 zskiplist、quicklist、listpack。本章主要是讲解数据类型，而不是底层实现的数据结构，数据结构可看 "),s("a",v,[n("Redis 底层数据结构"),t(i)]),n("。")])])]),S,s("blockquote",null,[s("p",null,[n("注意："),y,n("，代替了 ziplist 和 linkedlist，具体原因查看："),s("a",E,[n("Redis 底层数据结构"),t(i)]),n("。")])]),f,s("blockquote",null,[s("p",null,[n("注意："),R,n("，具体原因查看："),s("a",B,[n("Redis 底层数据结构"),t(i)]),n("。")])]),z,s("blockquote",null,[s("p",null,[n("注意："),O,n("，具体原因查看："),s("a",L,[n("Redis 底层数据结构"),t(i)]),n("。")])]),H,s("ul",null,[s("li",null,[s("a",F,[n("Redis 实战经验"),t(i)])]),s("li",null,[s("a",x,[n("小林 coding"),t(i)])]),I,T])])}const C=l(c,[["render",N],["__file","redis数据类型.html.vue"]]);export{C as default};
