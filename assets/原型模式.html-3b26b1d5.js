import{_ as o}from"./plugin-vue_export-helper-c27b6911.js";import{r as p,o as c,c as l,a as n,d as a,w as t,e as i,b as e}from"./app-268a9553.js";const u={},r={class:"hint-container details"},d=n("summary",null,"本文内容",-1),k={class:"table-of-contents"},m=i(`<h2 id="_1-什么是原型模式" tabindex="-1"><a class="header-anchor" href="#_1-什么是原型模式" aria-hidden="true">#</a> 1. 什么是原型模式</h2><p>原型模式也属于创建型模式，原型模式按照着字面意思来理解就好了，即 <strong>基于原型来创建对象的方式</strong> 就叫做 <strong>原型设计模式</strong>。</p><p>原型模式创建的新对象基于原型，那说明 <strong>新对象与原对象的差别不是很大</strong>，所以可以 <strong>直接采用复制（或叫拷贝）的方式来创建新对象，以达到节省创建时间的目的</strong>。但如果新对象本身的创建就十分简单，只消耗一点儿时间，那就没必要采用复制的方式创建了。</p><p>所以可以得出原型模式的 <strong>应用场景</strong>：<strong>对象的创建成本比较大</strong>，需要花费太多的时间，并且 <strong>新对象与原对象之间的差别不大时</strong>，便可以考虑原型模式。</p><div class="hint-container tip"><p class="hint-container-title">何为 “对象的创建成本比较大”？</p></div><p>如何定义这个创建成本呢？什么样对象的创建过程才算成本大呢？可以从下面的几种情况来判断：</p><ul><li>创建的对象中的数据需要经过 <strong>复杂的计算</strong> 才能得到（如排序、计算哈希值）；</li><li>创建的对象中的数据需要从网络、数据库、文件系统等 <strong>非常慢速的 IO 操作</strong> 中读取。</li></ul><p>如果需要创建的对象满足上述情况中的一种，创建对象消耗的时间就比较长了，自然创建的成本就比较大了。</p><h2 id="_2-原型模式的实现方式" tabindex="-1"><a class="header-anchor" href="#_2-原型模式的实现方式" aria-hidden="true">#</a> 2. 原型模式的实现方式</h2><p>上面讲到，通过复制的方式创建对象，就是原型模式，那么实现方式肯定就是复制嘛。</p><p>在 Java 中，使用 <strong><code>Object#clone()</code></strong> 方法可以很方便的复制一个对象，不过需要注意 <strong>浅拷贝和深拷贝</strong> 的问题。</p><p>深拷贝和浅拷贝的区别在于：</p><ul><li>浅拷贝只会拷贝对基本数据类型的数据和 <strong>引用对象类型的内存地址</strong>，而 <strong>不会拷贝引用对象本身</strong>；</li><li>而深拷贝除了会拷贝上面浅拷贝的数据外，<strong>对于引用类型的变量也会重新复制一份出来，而不是简单的引用地址值</strong>。</li></ul><p>举个例子，Person 类中有一个 Address 类：</p><ul><li>如果只是使用浅拷贝简单的克隆一个 person 对象，那么这个拷贝对象和原对象是共用一个 Address 的，因为只是拷贝了 Address 的引用地址；</li><li>但如果是使用深拷贝，那么这两个 Person 类对象都会有各自的 Address。</li></ul><p>对比图如下：</p><p><img src="https://run-notes.oss-cn-beijing.aliyuncs.com/notes/202304042156091.png" alt="image-20230404215620959" loading="lazy"></p><p>想使用深拷贝也很简单，在重写 <code>clone()</code> 方法时，<strong>直接将所有引用类型对象重新 new 一个，再重新设置即可</strong>；或者 <strong>将引用类型的对象也调用一下 <code>clone()</code> 方法即可</strong>。就像下面这样：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token annotation punctuation">@Override</span>
<span class="token keyword">public</span> <span class="token class-name">Person</span> <span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">try</span> <span class="token punctuation">{</span>
        <span class="token class-name">Person</span> person <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Person</span><span class="token punctuation">)</span> <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 把 Address 也克隆一下</span>
        person<span class="token punctuation">.</span><span class="token function">setAddress</span><span class="token punctuation">(</span>person<span class="token punctuation">.</span><span class="token function">getAddress</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> person<span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">CloneNotSupportedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">AssertionError</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>除此之外，还有另一种方式也能 <strong>实现深拷贝</strong>，那就是使用 <strong>序列化</strong>：先将对象序列化，然后再反序列化成新的对象。具体实现如下：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token class-name">Object</span> <span class="token function">deepCopy</span><span class="token punctuation">(</span><span class="token class-name">Object</span> object<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span><span class="token punctuation">,</span> <span class="token class-name">ClassNotFoundException</span> <span class="token punctuation">{</span>
        <span class="token class-name">ByteArrayOutputStream</span> bo <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ByteArrayOutputStream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">ObjectOutputStream</span> oo <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ObjectOutputStream</span><span class="token punctuation">(</span>bo<span class="token punctuation">)</span><span class="token punctuation">;</span>
        oo<span class="token punctuation">.</span><span class="token function">writeObject</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token class-name">ByteArrayInputStream</span> bi <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ByteArrayInputStream</span><span class="token punctuation">(</span>bo<span class="token punctuation">.</span><span class="token function">toByteArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">ObjectInputStream</span> oi <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ObjectInputStream</span><span class="token punctuation">(</span>bi<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token keyword">return</span> oi<span class="token punctuation">.</span><span class="token function">readObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>所以，对于原型模式，可以通过 <strong>浅拷贝、深拷贝（有需要）和序列化的方式实现</strong>，如果新对象与原型对象有一点点差异，那么在拷贝完后重新设置一下变量值即可。</p><h2 id="_3-总结" tabindex="-1"><a class="header-anchor" href="#_3-总结" aria-hidden="true">#</a> 3. 总结</h2><p>再来回顾一下原型模式的应用场景：<strong>对象的创建成本比较大</strong>，需要花费太多的时间，并且 <strong>新对象与原对象之间的差别不大时</strong>，便可以考虑原型模式。</p><p>实现原型模式也很简单，分别可以通过 <strong>浅拷贝、深拷贝（有需要）和序列化</strong> 的方式实现。</p>`,25);function v(g,b){const s=p("router-link");return c(),l("div",null,[n("details",r,[d,n("nav",k,[n("ul",null,[n("li",null,[a(s,{to:"#_1-什么是原型模式"},{default:t(()=>[e("1. 什么是原型模式")]),_:1})]),n("li",null,[a(s,{to:"#_2-原型模式的实现方式"},{default:t(()=>[e("2. 原型模式的实现方式")]),_:1})]),n("li",null,[a(s,{to:"#_3-总结"},{default:t(()=>[e("3. 总结")]),_:1})])])])]),m])}const y=o(u,[["render",v],["__file","原型模式.html.vue"]]);export{y as default};
