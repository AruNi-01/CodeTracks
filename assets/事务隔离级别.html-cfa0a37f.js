import{_ as i}from"./plugin-vue_export-helper-c27b6911.js";import{r,o as a,c as d,b as t,e as n,w as l,d as s,a as g}from"./app-5b8f6424.js";const p={},c={class:"hint-container details"},_=t("summary",null,"本文内容",-1),h={class:"table-of-contents"},u=g('<div class="hint-container info"><p class="hint-container-title">前言</p><p>上一篇文章中，介绍了事务的基本概念、MySQL 中的事务控制语句、事务的 ACID 特性等，本文将展开其中的 I，也就是 “隔离性”。</p></div><h2 id="_1-并发事务引发的问题" tabindex="-1"><a class="header-anchor" href="#_1-并发事务引发的问题" aria-hidden="true">#</a> 1. 并发事务引发的问题</h2><p>当一个数据库中有 <strong>多个事务在同时执行</strong> 时，可能会出现 <strong>脏读、不可重复读、幻读</strong> 的问题。下面来看看这三个问题分别是什么现象。</p><h3 id="_1-1-脏读" tabindex="-1"><a class="header-anchor" href="#_1-1-脏读" aria-hidden="true">#</a> 1.1 脏读</h3><p>所谓 <strong>脏读</strong>，意思是 <strong>一个事务（B）读取到了另一个事务（A）还没有提交的数据</strong>，那么当 A 回滚后，B 读取到的数据就成了脏数据。如下图所示：</p><p><img src="https://run-notes.oss-cn-beijing.aliyuncs.com/notes/事务%2F事务隔离级别.assets-2023_12_06-1701866552.png" alt="image-20231206204221577" loading="lazy"></p><p>可以发现，脏读现象是因为 <strong>读取到了别的事务未提交的数据 (可能发生回滚)</strong> 导致的。</p><h3 id="_1-2-不可重复读" tabindex="-1"><a class="header-anchor" href="#_1-2-不可重复读" aria-hidden="true">#</a> 1.2 不可重复读</h3><p>不可重复读也是见名知意，即 <strong>在一个事务内，重复读取多次相同的记录，出现了记录不一样</strong> 的情况，就说明发生了不可重复读现象。如下图所示：</p><p><img src="https://run-notes.oss-cn-beijing.aliyuncs.com/notes/事务%2F事务隔离级别.assets-2023_12_06-1701866801.png" alt="image-20231206204639105" loading="lazy"></p><p>可以发现，不可重复读现象是因为 <strong>读取到了别的事务提交的数据</strong> 导致的。</p><h3 id="_1-3-幻读" tabindex="-1"><a class="header-anchor" href="#_1-3-幻读" aria-hidden="true">#</a> 1.3 幻读</h3><p>幻读是指 <strong>在一个事务内，多次读取符合某个查询条件的记录，出现了记录数量不一样</strong> 的情况。注意，<strong>幻读强调的是读取记录的数量</strong>。如下图所示：</p><p><img src="https://run-notes.oss-cn-beijing.aliyuncs.com/notes/事务%2F事务隔离级别.assets-2023_12_06-1701867373.png" alt="image-20231206205611977" loading="lazy"></p><p>可以发现，幻读现象是因为 <strong>读取到了别的事务插入的数据 (已提交)</strong> 导致的。</p><h3 id="_1-4-补充-脏写" tabindex="-1"><a class="header-anchor" href="#_1-4-补充-脏写" aria-hidden="true">#</a> 1.4 补充：脏写</h3><p>这里补充一个并发事务可能会出现的另一个现象，脏写，不过在 MySQL 中一般不会出现。</p><p><strong>脏写</strong> 指的是一个事务（T1）先修改了数据，另一个事务（T2）也修改了同一个数据，而且还提交了。之后，T1 发生了回滚，此时也会 <strong>把 T2 已经提交的数据回滚掉</strong>。对于 <strong>T2</strong> 来说，<strong>明明已经提交了事务，但最后的数据还是原来的</strong>，这就是脏写现象。</p><p><img src="https://run-notes.oss-cn-beijing.aliyuncs.com/notes/事务%2F事务隔离级别.assets-2023_12_06-1701868881.png" alt="image-20231206212114666" loading="lazy"></p><p>可以发现，脏写现象是由于一个事务修改了另一个事务修改的数据导致的，但在 MySQL 中有行锁，更新操作是会加锁的，另一个事务再去更新时，会造成写写互斥，所以不会发生脏写问题。</p><h2 id="_2-事务隔离级别有哪些" tabindex="-1"><a class="header-anchor" href="#_2-事务隔离级别有哪些" aria-hidden="true">#</a> 2. 事务隔离级别有哪些？</h2><p>SQL 标准的事务隔离级别包括如下：</p><ul><li><p><strong>读未提交 (Read Uncommitted)</strong>：指一个事务 <strong>还没提交时</strong>，其更变就能被别的事务看见；</p></li><li><p><strong>读提交 (Read Committed)</strong>：指一个事务 <strong>提交后</strong>，其更变才会被别的事务看见；</p></li><li><p><strong>可重复读 (Repeatable Read)</strong>：指一个事务执行过程中看到的数据，<strong>总跟事务开启时看到的数据一样</strong>。RR 为 MySQL InnoDB 默认的隔离级别。</p><blockquote><p>在 RR 隔离级别下，未提交的更变对其他事务也是不可见的。</p></blockquote></li><li><p><strong>串行化 (Serializable)</strong>：顾名思义，<strong>对记录进行读写时都会加锁</strong>（写加写锁、读加读锁），当出现锁冲突时，后访问的事务需要等待。</p></li></ul><p>从上到下，隔离级别越来越高，而 <strong>效率越来越低</strong>。</p><p>在之前介绍并发事务会引发的问题时，都说明了出现这些问题的原因，那么根据原因和以上隔离级别的保证，可以得出：<strong>不同隔离级别所解决的并发事务问题的能力是不同的</strong>：</p><ul><li>要解决 <strong>脏读</strong> 问题，就要将隔离级别设置为「<strong>读提交</strong>」或更高；</li><li>要解决 <strong>不可重复读</strong> 问题，就要将隔离级别设置为「<strong>可重复读</strong>」或更高；</li><li>要解决 <strong>幻读</strong> 问题，就要将隔离级别设置为「<strong>串行化</strong>」或更高。</li></ul><p>不同隔离级别会出现的问题如下图所示：</p><table><thead><tr><th>隔离级别</th><th>并发事务会出现的问题</th></tr></thead><tbody><tr><td>读未提交</td><td>脏读、不可重复读、幻读</td></tr><tr><td>读提交</td><td>不可重复度、幻读</td></tr><tr><td>可重复读</td><td>幻读</td></tr><tr><td>串行化</td><td></td></tr></tbody></table><p>其实，MySQL 在 <strong>可重复读</strong> 隔离级别下，就可以 <strong>很大程度上避免幻读的出现</strong>，只不过不是完全避免，所以 MySQL 的默认隔离级别是可重复读，在争取 <strong>引发最少并发事务问题</strong> 的同时，以达到 <strong>最高的效率</strong>。</p><p><strong>每种隔离级别都有各自的使用场景</strong>，需要根据自己的业务情况而定。比如业务中没有重复读取记录的事务，那么就可以将隔离级别设置为读提交。</p><h2 id="_3-举例说明" tabindex="-1"><a class="header-anchor" href="#_3-举例说明" aria-hidden="true">#</a> 3. 举例说明</h2><p>下面例举一个具体的例子，来看看在不同的隔离级别下，并发事务引发的问题。</p><p>假设表 T 中有一个字段，只有一条记录，值为 1，两个事务并发的执行：</p><p><img src="https://run-notes.oss-cn-beijing.aliyuncs.com/notes/事务%2F事务隔离级别.assets-2023_12_06-1701874388.png" alt="image-20231206225305085" loading="lazy"></p><p>来看看在不同的隔离级别下，事务 A 会有哪些不同的结果：</p><ul><li>读未提交： <ul><li>V1 = 2：虽然事务 B 还没提交，但依旧能读取到事务 B 执行的修改；</li><li>V2 = 2：事务 B 提交后，自然也能读取到最新值；</li><li>V3 = 2：理由同上。</li></ul></li><li>读提交： <ul><li>V1 = 1：事务 B 还没提交，所以只能读取到之前的值；</li><li>V2 = 2：事务 B 已经提交了，能读取到最新值；</li><li>V3 = 2：理由同上。</li></ul></li><li>可重复读： <ul><li>V1 = 1：事务 B 还没提交，所以只能读取到之前的值；</li><li>V2 = 1：事务 B 虽然已经提交了，但在事务期间读取到的值和事务开启时的一样</li><li>V3 = 2：事务 A 已经结束，自然读取到了最新值。</li></ul></li><li>串行化： <ul><li>V1 = 1：事务 A 开启后查询到值 1，此查询会加读锁，所以事务 B 的修改操作会阻塞（读写冲突），故 V1 还是 1；</li><li>V2 = 1：理由同上；</li><li>V3 = 2：事务 A 结束，释放读锁，此时事务 B 才继续执行，提交后，V3 能读取到最新值 2。（注意按照时间线顺序，查询 V3 在提交事务 B 后面执行）</li></ul></li></ul><p>是不是觉得很神奇呢？这四个隔离级别是如何保证的呢？下一篇文章将详细介绍隔离级别的实现机制。</p><h2 id="_4-参考文章" tabindex="-1"><a class="header-anchor" href="#_4-参考文章" aria-hidden="true">#</a> 4. 参考文章</h2>',38),m=t("li",null,"《MySQL 实战 45 讲》",-1),f={href:"https://xiaolincoding.com",target:"_blank",rel:"noopener noreferrer"};function b(y,V){const o=r("router-link"),e=r("ExternalLinkIcon");return a(),d("div",null,[t("details",c,[_,t("nav",h,[t("ul",null,[t("li",null,[n(o,{to:"#_1-并发事务引发的问题"},{default:l(()=>[s("1. 并发事务引发的问题")]),_:1}),t("ul",null,[t("li",null,[n(o,{to:"#_1-1-脏读"},{default:l(()=>[s("1.1 脏读")]),_:1})]),t("li",null,[n(o,{to:"#_1-2-不可重复读"},{default:l(()=>[s("1.2 不可重复读")]),_:1})]),t("li",null,[n(o,{to:"#_1-3-幻读"},{default:l(()=>[s("1.3 幻读")]),_:1})]),t("li",null,[n(o,{to:"#_1-4-补充-脏写"},{default:l(()=>[s("1.4 补充：脏写")]),_:1})])])]),t("li",null,[n(o,{to:"#_2-事务隔离级别有哪些"},{default:l(()=>[s("2. 事务隔离级别有哪些？")]),_:1})]),t("li",null,[n(o,{to:"#_3-举例说明"},{default:l(()=>[s("3. 举例说明")]),_:1})]),t("li",null,[n(o,{to:"#_4-参考文章"},{default:l(()=>[s("4. 参考文章")]),_:1})])])])]),u,t("ul",null,[m,t("li",null,[t("a",f,[s("小林 coding"),n(e)])])])])}const L=i(p,[["render",b],["__file","事务隔离级别.html.vue"]]);export{L as default};
