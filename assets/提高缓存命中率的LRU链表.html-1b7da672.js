const e=JSON.parse(`{"key":"v-62b807c1","path":"/studynotes/database/mysql/buffer_pool/%E6%8F%90%E9%AB%98%E7%BC%93%E5%AD%98%E5%91%BD%E4%B8%AD%E7%8E%87%E7%9A%84LRU%E9%93%BE%E8%A1%A8.html","title":"提高缓存命中率的 LRU 链表","lang":"zh-CN","frontmatter":{"title":"提高缓存命中率的 LRU 链表","date":"2023-03-06T00:00:00.000Z","order":2,"icon":"write","category":["数据库"],"tag":["MySQL"],"sticky":false,"star":false,"article":true,"timeline":true,"description":"本文内容 1. 缓冲区不够了怎么办？ 在上一篇文章中我们知道，为了提高数据库的读写性能，InnoDB 建立了一个缓冲区 Buffer Pool。Buffer Pool 被划分为多个缓冲页，这些缓冲页通过链表（链表中保存的是控制块）来管理。 在 Buffer Pool 中，常用的链表有 free 链表、flush 链表，还有一个就是我们今天的主角 — LRU 链表。 缓冲区的大小是有限的，那么当 缓冲区的内存不足时，就需要淘汰一些旧的缓冲页，再来存放新的。这个事情，就由 LRU 链表负责。","head":[["meta",{"property":"og:url","content":"https://aruni.me/docs/studynotes/database/mysql/buffer_pool/%E6%8F%90%E9%AB%98%E7%BC%93%E5%AD%98%E5%91%BD%E4%B8%AD%E7%8E%87%E7%9A%84LRU%E9%93%BE%E8%A1%A8.html"}],["meta",{"property":"og:site_name","content":"AruNi's domain"}],["meta",{"property":"og:title","content":"提高缓存命中率的 LRU 链表"}],["meta",{"property":"og:description","content":"本文内容 1. 缓冲区不够了怎么办？ 在上一篇文章中我们知道，为了提高数据库的读写性能，InnoDB 建立了一个缓冲区 Buffer Pool。Buffer Pool 被划分为多个缓冲页，这些缓冲页通过链表（链表中保存的是控制块）来管理。 在 Buffer Pool 中，常用的链表有 free 链表、flush 链表，还有一个就是我们今天的主角 — LRU 链表。 缓冲区的大小是有限的，那么当 缓冲区的内存不足时，就需要淘汰一些旧的缓冲页，再来存放新的。这个事情，就由 LRU 链表负责。"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2023-06-10T13:25:13.000Z"}],["meta",{"property":"article:author","content":"AruNi_Lu"}],["meta",{"property":"article:tag","content":"MySQL"}],["meta",{"property":"article:published_time","content":"2023-03-06T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2023-06-10T13:25:13.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"提高缓存命中率的 LRU 链表\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2023-03-06T00:00:00.000Z\\",\\"dateModified\\":\\"2023-06-10T13:25:13.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"AruNi_Lu\\",\\"url\\":\\"https://github.com/AruNi-01/\\"}]}"]]},"headers":[{"level":2,"title":"1. 缓冲区不够了怎么办？","slug":"_1-缓冲区不够了怎么办","link":"#_1-缓冲区不够了怎么办","children":[]},{"level":2,"title":"2. 简单的 LRU 链表","slug":"_2-简单的-lru-链表","link":"#_2-简单的-lru-链表","children":[{"level":3,"title":"2.1 原始 LRU 是怎样的？","slug":"_2-1-原始-lru-是怎样的","link":"#_2-1-原始-lru-是怎样的","children":[]},{"level":3,"title":"2.1 预读失效","slug":"_2-1-预读失效","link":"#_2-1-预读失效","children":[]},{"level":3,"title":"2.2 Buffer Pool 缓存污染","slug":"_2-2-buffer-pool-缓存污染","link":"#_2-2-buffer-pool-缓存污染","children":[]}]},{"level":2,"title":"3. 改进的 LRU 链表","slug":"_3-改进的-lru-链表","link":"#_3-改进的-lru-链表","children":[{"level":3,"title":"3.1 针对预读失效","slug":"_3-1-针对预读失效","link":"#_3-1-针对预读失效","children":[]},{"level":3,"title":"3.2 针对缓存污染","slug":"_3-2-针对缓存污染","link":"#_3-2-针对缓存污染","children":[]},{"level":3,"title":"3.3 LRU 链表再优化","slug":"_3-3-lru-链表再优化","link":"#_3-3-lru-链表再优化","children":[]}]},{"level":2,"title":"4. 总结","slug":"_4-总结","link":"#_4-总结","children":[]},{"level":2,"title":"6. 参考文章","slug":"_6-参考文章","link":"#_6-参考文章","children":[]}],"git":{"createdTime":1678112922000,"updatedTime":1686403513000,"contributors":[{"name":"AruNi-01","email":"1298911600@qq.com","commits":1},{"name":"aarynlu","email":"aarynlu@tencent.com","commits":1}]},"readingTime":{"minutes":8.35,"words":2506},"filePathRelative":"studynotes/database/mysql/buffer_pool/提高缓存命中率的LRU链表.md","localizedDate":"2023年3月6日","excerpt":"<details class=\\"hint-container details\\"><summary>本文内容</summary>\\n\\n</details>\\n<h2> 1. 缓冲区不够了怎么办？</h2>\\n<p>在上一篇文章中我们知道，为了提高数据库的读写性能，InnoDB 建立了一个缓冲区 Buffer Pool。Buffer Pool 被划分为多个缓冲页，这些缓冲页通过链表（链表中保存的是控制块）来管理。</p>\\n<p>在 Buffer Pool 中，常用的链表有 free 链表、flush 链表，还有一个就是我们今天的主角 — <strong>LRU 链表</strong>。</p>\\n<p>缓冲区的大小是有限的，那么当 <strong>缓冲区的内存不足时</strong>，就需要淘汰一些旧的缓冲页，再来存放新的。这个事情，就由 LRU 链表负责。</p>","autoDesc":true}`);export{e as data};
